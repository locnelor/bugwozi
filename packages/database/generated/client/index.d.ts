
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model sys_user
 * 
 */
export type sys_user = $Result.DefaultSelection<Prisma.$sys_userPayload>
/**
 * Model sys_account
 * 
 */
export type sys_account = $Result.DefaultSelection<Prisma.$sys_accountPayload>
/**
 * Model sys_menu
 * 
 */
export type sys_menu = $Result.DefaultSelection<Prisma.$sys_menuPayload>
/**
 * Model sys_user_ban_menu
 * 
 */
export type sys_user_ban_menu = $Result.DefaultSelection<Prisma.$sys_user_ban_menuPayload>
/**
 * Model sys_menu_on_role
 * 
 */
export type sys_menu_on_role = $Result.DefaultSelection<Prisma.$sys_menu_on_rolePayload>
/**
 * Model sys_role
 * 
 */
export type sys_role = $Result.DefaultSelection<Prisma.$sys_rolePayload>
/**
 * Model blog_user
 * 
 */
export type blog_user = $Result.DefaultSelection<Prisma.$blog_userPayload>
/**
 * Model blog_categories
 * 
 */
export type blog_categories = $Result.DefaultSelection<Prisma.$blog_categoriesPayload>
/**
 * Model blog_posts
 * 
 */
export type blog_posts = $Result.DefaultSelection<Prisma.$blog_postsPayload>
/**
 * Model blog_notice
 * 
 */
export type blog_notice = $Result.DefaultSelection<Prisma.$blog_noticePayload>
/**
 * Model blog_posts_on_tags
 * 
 */
export type blog_posts_on_tags = $Result.DefaultSelection<Prisma.$blog_posts_on_tagsPayload>
/**
 * Model blog_tag
 * 
 */
export type blog_tag = $Result.DefaultSelection<Prisma.$blog_tagPayload>
/**
 * Model file_user
 * 
 */
export type file_user = $Result.DefaultSelection<Prisma.$file_userPayload>
/**
 * Model file_keys
 * 
 */
export type file_keys = $Result.DefaultSelection<Prisma.$file_keysPayload>
/**
 * Model file_config
 * 
 */
export type file_config = $Result.DefaultSelection<Prisma.$file_configPayload>
/**
 * Model file_user_on_media
 * 
 */
export type file_user_on_media = $Result.DefaultSelection<Prisma.$file_user_on_mediaPayload>
/**
 * Model file_block
 * 
 */
export type file_block = $Result.DefaultSelection<Prisma.$file_blockPayload>
/**
 * Model file_media
 * 
 */
export type file_media = $Result.DefaultSelection<Prisma.$file_mediaPayload>
/**
 * Model file_media_on_folder
 * 
 */
export type file_media_on_folder = $Result.DefaultSelection<Prisma.$file_media_on_folderPayload>
/**
 * Model file_folder
 * 
 */
export type file_folder = $Result.DefaultSelection<Prisma.$file_folderPayload>
/**
 * Model book_user
 * 
 */
export type book_user = $Result.DefaultSelection<Prisma.$book_userPayload>
/**
 * Model book_book
 * 
 */
export type book_book = $Result.DefaultSelection<Prisma.$book_bookPayload>
/**
 * Model book_category
 * 
 */
export type book_category = $Result.DefaultSelection<Prisma.$book_categoryPayload>
/**
 * Model book_borrowed
 * 
 */
export type book_borrowed = $Result.DefaultSelection<Prisma.$book_borrowedPayload>
/**
 * Model book_borrow_history
 * 
 */
export type book_borrow_history = $Result.DefaultSelection<Prisma.$book_borrow_historyPayload>
/**
 * Model book_rating
 * 
 */
export type book_rating = $Result.DefaultSelection<Prisma.$book_ratingPayload>
/**
 * Model study_user
 * 
 */
export type study_user = $Result.DefaultSelection<Prisma.$study_userPayload>
/**
 * Model study_store
 * 
 */
export type study_store = $Result.DefaultSelection<Prisma.$study_storePayload>
/**
 * Model study_floor
 * 
 */
export type study_floor = $Result.DefaultSelection<Prisma.$study_floorPayload>
/**
 * Model study_room
 * 
 */
export type study_room = $Result.DefaultSelection<Prisma.$study_roomPayload>
/**
 * Model study_seat
 * 
 */
export type study_seat = $Result.DefaultSelection<Prisma.$study_seatPayload>
/**
 * Model study_reservation
 * 
 */
export type study_reservation = $Result.DefaultSelection<Prisma.$study_reservationPayload>
/**
 * Model study_message
 * 
 */
export type study_message = $Result.DefaultSelection<Prisma.$study_messagePayload>
/**
 * Model study_announcement
 * 
 */
export type study_announcement = $Result.DefaultSelection<Prisma.$study_announcementPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const sys_account_provider: {
  we_chat: 'we_chat',
  github: 'github',
  qq: 'qq',
  email: 'email',
  phone: 'phone'
};

export type sys_account_provider = (typeof sys_account_provider)[keyof typeof sys_account_provider]


export const file_type: {
  image: 'image',
  video: 'video',
  audio: 'audio',
  document: 'document',
  archive: 'archive',
  other: 'other'
};

export type file_type = (typeof file_type)[keyof typeof file_type]


export const book_role: {
  book_user: 'book_user',
  book_admin: 'book_admin'
};

export type book_role = (typeof book_role)[keyof typeof book_role]

}

export type sys_account_provider = $Enums.sys_account_provider

export const sys_account_provider: typeof $Enums.sys_account_provider

export type file_type = $Enums.file_type

export const file_type: typeof $Enums.file_type

export type book_role = $Enums.book_role

export const book_role: typeof $Enums.book_role

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Sys_users
 * const sys_users = await prisma.sys_user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Sys_users
   * const sys_users = await prisma.sys_user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.sys_user`: Exposes CRUD operations for the **sys_user** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sys_users
    * const sys_users = await prisma.sys_user.findMany()
    * ```
    */
  get sys_user(): Prisma.sys_userDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sys_account`: Exposes CRUD operations for the **sys_account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sys_accounts
    * const sys_accounts = await prisma.sys_account.findMany()
    * ```
    */
  get sys_account(): Prisma.sys_accountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sys_menu`: Exposes CRUD operations for the **sys_menu** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sys_menus
    * const sys_menus = await prisma.sys_menu.findMany()
    * ```
    */
  get sys_menu(): Prisma.sys_menuDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sys_user_ban_menu`: Exposes CRUD operations for the **sys_user_ban_menu** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sys_user_ban_menus
    * const sys_user_ban_menus = await prisma.sys_user_ban_menu.findMany()
    * ```
    */
  get sys_user_ban_menu(): Prisma.sys_user_ban_menuDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sys_menu_on_role`: Exposes CRUD operations for the **sys_menu_on_role** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sys_menu_on_roles
    * const sys_menu_on_roles = await prisma.sys_menu_on_role.findMany()
    * ```
    */
  get sys_menu_on_role(): Prisma.sys_menu_on_roleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sys_role`: Exposes CRUD operations for the **sys_role** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sys_roles
    * const sys_roles = await prisma.sys_role.findMany()
    * ```
    */
  get sys_role(): Prisma.sys_roleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.blog_user`: Exposes CRUD operations for the **blog_user** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Blog_users
    * const blog_users = await prisma.blog_user.findMany()
    * ```
    */
  get blog_user(): Prisma.blog_userDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.blog_categories`: Exposes CRUD operations for the **blog_categories** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Blog_categories
    * const blog_categories = await prisma.blog_categories.findMany()
    * ```
    */
  get blog_categories(): Prisma.blog_categoriesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.blog_posts`: Exposes CRUD operations for the **blog_posts** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Blog_posts
    * const blog_posts = await prisma.blog_posts.findMany()
    * ```
    */
  get blog_posts(): Prisma.blog_postsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.blog_notice`: Exposes CRUD operations for the **blog_notice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Blog_notices
    * const blog_notices = await prisma.blog_notice.findMany()
    * ```
    */
  get blog_notice(): Prisma.blog_noticeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.blog_posts_on_tags`: Exposes CRUD operations for the **blog_posts_on_tags** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Blog_posts_on_tags
    * const blog_posts_on_tags = await prisma.blog_posts_on_tags.findMany()
    * ```
    */
  get blog_posts_on_tags(): Prisma.blog_posts_on_tagsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.blog_tag`: Exposes CRUD operations for the **blog_tag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Blog_tags
    * const blog_tags = await prisma.blog_tag.findMany()
    * ```
    */
  get blog_tag(): Prisma.blog_tagDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.file_user`: Exposes CRUD operations for the **file_user** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more File_users
    * const file_users = await prisma.file_user.findMany()
    * ```
    */
  get file_user(): Prisma.file_userDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.file_keys`: Exposes CRUD operations for the **file_keys** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more File_keys
    * const file_keys = await prisma.file_keys.findMany()
    * ```
    */
  get file_keys(): Prisma.file_keysDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.file_config`: Exposes CRUD operations for the **file_config** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more File_configs
    * const file_configs = await prisma.file_config.findMany()
    * ```
    */
  get file_config(): Prisma.file_configDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.file_user_on_media`: Exposes CRUD operations for the **file_user_on_media** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more File_user_on_medias
    * const file_user_on_medias = await prisma.file_user_on_media.findMany()
    * ```
    */
  get file_user_on_media(): Prisma.file_user_on_mediaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.file_block`: Exposes CRUD operations for the **file_block** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more File_blocks
    * const file_blocks = await prisma.file_block.findMany()
    * ```
    */
  get file_block(): Prisma.file_blockDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.file_media`: Exposes CRUD operations for the **file_media** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more File_medias
    * const file_medias = await prisma.file_media.findMany()
    * ```
    */
  get file_media(): Prisma.file_mediaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.file_media_on_folder`: Exposes CRUD operations for the **file_media_on_folder** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more File_media_on_folders
    * const file_media_on_folders = await prisma.file_media_on_folder.findMany()
    * ```
    */
  get file_media_on_folder(): Prisma.file_media_on_folderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.file_folder`: Exposes CRUD operations for the **file_folder** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more File_folders
    * const file_folders = await prisma.file_folder.findMany()
    * ```
    */
  get file_folder(): Prisma.file_folderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.book_user`: Exposes CRUD operations for the **book_user** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Book_users
    * const book_users = await prisma.book_user.findMany()
    * ```
    */
  get book_user(): Prisma.book_userDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.book_book`: Exposes CRUD operations for the **book_book** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Book_books
    * const book_books = await prisma.book_book.findMany()
    * ```
    */
  get book_book(): Prisma.book_bookDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.book_category`: Exposes CRUD operations for the **book_category** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Book_categories
    * const book_categories = await prisma.book_category.findMany()
    * ```
    */
  get book_category(): Prisma.book_categoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.book_borrowed`: Exposes CRUD operations for the **book_borrowed** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Book_borroweds
    * const book_borroweds = await prisma.book_borrowed.findMany()
    * ```
    */
  get book_borrowed(): Prisma.book_borrowedDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.book_borrow_history`: Exposes CRUD operations for the **book_borrow_history** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Book_borrow_histories
    * const book_borrow_histories = await prisma.book_borrow_history.findMany()
    * ```
    */
  get book_borrow_history(): Prisma.book_borrow_historyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.book_rating`: Exposes CRUD operations for the **book_rating** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Book_ratings
    * const book_ratings = await prisma.book_rating.findMany()
    * ```
    */
  get book_rating(): Prisma.book_ratingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.study_user`: Exposes CRUD operations for the **study_user** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Study_users
    * const study_users = await prisma.study_user.findMany()
    * ```
    */
  get study_user(): Prisma.study_userDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.study_store`: Exposes CRUD operations for the **study_store** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Study_stores
    * const study_stores = await prisma.study_store.findMany()
    * ```
    */
  get study_store(): Prisma.study_storeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.study_floor`: Exposes CRUD operations for the **study_floor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Study_floors
    * const study_floors = await prisma.study_floor.findMany()
    * ```
    */
  get study_floor(): Prisma.study_floorDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.study_room`: Exposes CRUD operations for the **study_room** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Study_rooms
    * const study_rooms = await prisma.study_room.findMany()
    * ```
    */
  get study_room(): Prisma.study_roomDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.study_seat`: Exposes CRUD operations for the **study_seat** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Study_seats
    * const study_seats = await prisma.study_seat.findMany()
    * ```
    */
  get study_seat(): Prisma.study_seatDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.study_reservation`: Exposes CRUD operations for the **study_reservation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Study_reservations
    * const study_reservations = await prisma.study_reservation.findMany()
    * ```
    */
  get study_reservation(): Prisma.study_reservationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.study_message`: Exposes CRUD operations for the **study_message** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Study_messages
    * const study_messages = await prisma.study_message.findMany()
    * ```
    */
  get study_message(): Prisma.study_messageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.study_announcement`: Exposes CRUD operations for the **study_announcement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Study_announcements
    * const study_announcements = await prisma.study_announcement.findMany()
    * ```
    */
  get study_announcement(): Prisma.study_announcementDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.6.0
   * Query Engine version: f676762280b54cd07c770017ed3711ddde35f37a
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    sys_user: 'sys_user',
    sys_account: 'sys_account',
    sys_menu: 'sys_menu',
    sys_user_ban_menu: 'sys_user_ban_menu',
    sys_menu_on_role: 'sys_menu_on_role',
    sys_role: 'sys_role',
    blog_user: 'blog_user',
    blog_categories: 'blog_categories',
    blog_posts: 'blog_posts',
    blog_notice: 'blog_notice',
    blog_posts_on_tags: 'blog_posts_on_tags',
    blog_tag: 'blog_tag',
    file_user: 'file_user',
    file_keys: 'file_keys',
    file_config: 'file_config',
    file_user_on_media: 'file_user_on_media',
    file_block: 'file_block',
    file_media: 'file_media',
    file_media_on_folder: 'file_media_on_folder',
    file_folder: 'file_folder',
    book_user: 'book_user',
    book_book: 'book_book',
    book_category: 'book_category',
    book_borrowed: 'book_borrowed',
    book_borrow_history: 'book_borrow_history',
    book_rating: 'book_rating',
    study_user: 'study_user',
    study_store: 'study_store',
    study_floor: 'study_floor',
    study_room: 'study_room',
    study_seat: 'study_seat',
    study_reservation: 'study_reservation',
    study_message: 'study_message',
    study_announcement: 'study_announcement'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "sys_user" | "sys_account" | "sys_menu" | "sys_user_ban_menu" | "sys_menu_on_role" | "sys_role" | "blog_user" | "blog_categories" | "blog_posts" | "blog_notice" | "blog_posts_on_tags" | "blog_tag" | "file_user" | "file_keys" | "file_config" | "file_user_on_media" | "file_block" | "file_media" | "file_media_on_folder" | "file_folder" | "book_user" | "book_book" | "book_category" | "book_borrowed" | "book_borrow_history" | "book_rating" | "study_user" | "study_store" | "study_floor" | "study_room" | "study_seat" | "study_reservation" | "study_message" | "study_announcement"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      sys_user: {
        payload: Prisma.$sys_userPayload<ExtArgs>
        fields: Prisma.sys_userFieldRefs
        operations: {
          findUnique: {
            args: Prisma.sys_userFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sys_userPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.sys_userFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sys_userPayload>
          }
          findFirst: {
            args: Prisma.sys_userFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sys_userPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.sys_userFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sys_userPayload>
          }
          findMany: {
            args: Prisma.sys_userFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sys_userPayload>[]
          }
          create: {
            args: Prisma.sys_userCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sys_userPayload>
          }
          createMany: {
            args: Prisma.sys_userCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.sys_userDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sys_userPayload>
          }
          update: {
            args: Prisma.sys_userUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sys_userPayload>
          }
          deleteMany: {
            args: Prisma.sys_userDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.sys_userUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.sys_userUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sys_userPayload>
          }
          aggregate: {
            args: Prisma.Sys_userAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSys_user>
          }
          groupBy: {
            args: Prisma.sys_userGroupByArgs<ExtArgs>
            result: $Utils.Optional<Sys_userGroupByOutputType>[]
          }
          count: {
            args: Prisma.sys_userCountArgs<ExtArgs>
            result: $Utils.Optional<Sys_userCountAggregateOutputType> | number
          }
        }
      }
      sys_account: {
        payload: Prisma.$sys_accountPayload<ExtArgs>
        fields: Prisma.sys_accountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.sys_accountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sys_accountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.sys_accountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sys_accountPayload>
          }
          findFirst: {
            args: Prisma.sys_accountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sys_accountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.sys_accountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sys_accountPayload>
          }
          findMany: {
            args: Prisma.sys_accountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sys_accountPayload>[]
          }
          create: {
            args: Prisma.sys_accountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sys_accountPayload>
          }
          createMany: {
            args: Prisma.sys_accountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.sys_accountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sys_accountPayload>
          }
          update: {
            args: Prisma.sys_accountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sys_accountPayload>
          }
          deleteMany: {
            args: Prisma.sys_accountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.sys_accountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.sys_accountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sys_accountPayload>
          }
          aggregate: {
            args: Prisma.Sys_accountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSys_account>
          }
          groupBy: {
            args: Prisma.sys_accountGroupByArgs<ExtArgs>
            result: $Utils.Optional<Sys_accountGroupByOutputType>[]
          }
          count: {
            args: Prisma.sys_accountCountArgs<ExtArgs>
            result: $Utils.Optional<Sys_accountCountAggregateOutputType> | number
          }
        }
      }
      sys_menu: {
        payload: Prisma.$sys_menuPayload<ExtArgs>
        fields: Prisma.sys_menuFieldRefs
        operations: {
          findUnique: {
            args: Prisma.sys_menuFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sys_menuPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.sys_menuFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sys_menuPayload>
          }
          findFirst: {
            args: Prisma.sys_menuFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sys_menuPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.sys_menuFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sys_menuPayload>
          }
          findMany: {
            args: Prisma.sys_menuFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sys_menuPayload>[]
          }
          create: {
            args: Prisma.sys_menuCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sys_menuPayload>
          }
          createMany: {
            args: Prisma.sys_menuCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.sys_menuDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sys_menuPayload>
          }
          update: {
            args: Prisma.sys_menuUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sys_menuPayload>
          }
          deleteMany: {
            args: Prisma.sys_menuDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.sys_menuUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.sys_menuUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sys_menuPayload>
          }
          aggregate: {
            args: Prisma.Sys_menuAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSys_menu>
          }
          groupBy: {
            args: Prisma.sys_menuGroupByArgs<ExtArgs>
            result: $Utils.Optional<Sys_menuGroupByOutputType>[]
          }
          count: {
            args: Prisma.sys_menuCountArgs<ExtArgs>
            result: $Utils.Optional<Sys_menuCountAggregateOutputType> | number
          }
        }
      }
      sys_user_ban_menu: {
        payload: Prisma.$sys_user_ban_menuPayload<ExtArgs>
        fields: Prisma.sys_user_ban_menuFieldRefs
        operations: {
          findUnique: {
            args: Prisma.sys_user_ban_menuFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sys_user_ban_menuPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.sys_user_ban_menuFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sys_user_ban_menuPayload>
          }
          findFirst: {
            args: Prisma.sys_user_ban_menuFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sys_user_ban_menuPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.sys_user_ban_menuFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sys_user_ban_menuPayload>
          }
          findMany: {
            args: Prisma.sys_user_ban_menuFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sys_user_ban_menuPayload>[]
          }
          create: {
            args: Prisma.sys_user_ban_menuCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sys_user_ban_menuPayload>
          }
          createMany: {
            args: Prisma.sys_user_ban_menuCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.sys_user_ban_menuDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sys_user_ban_menuPayload>
          }
          update: {
            args: Prisma.sys_user_ban_menuUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sys_user_ban_menuPayload>
          }
          deleteMany: {
            args: Prisma.sys_user_ban_menuDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.sys_user_ban_menuUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.sys_user_ban_menuUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sys_user_ban_menuPayload>
          }
          aggregate: {
            args: Prisma.Sys_user_ban_menuAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSys_user_ban_menu>
          }
          groupBy: {
            args: Prisma.sys_user_ban_menuGroupByArgs<ExtArgs>
            result: $Utils.Optional<Sys_user_ban_menuGroupByOutputType>[]
          }
          count: {
            args: Prisma.sys_user_ban_menuCountArgs<ExtArgs>
            result: $Utils.Optional<Sys_user_ban_menuCountAggregateOutputType> | number
          }
        }
      }
      sys_menu_on_role: {
        payload: Prisma.$sys_menu_on_rolePayload<ExtArgs>
        fields: Prisma.sys_menu_on_roleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.sys_menu_on_roleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sys_menu_on_rolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.sys_menu_on_roleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sys_menu_on_rolePayload>
          }
          findFirst: {
            args: Prisma.sys_menu_on_roleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sys_menu_on_rolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.sys_menu_on_roleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sys_menu_on_rolePayload>
          }
          findMany: {
            args: Prisma.sys_menu_on_roleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sys_menu_on_rolePayload>[]
          }
          create: {
            args: Prisma.sys_menu_on_roleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sys_menu_on_rolePayload>
          }
          createMany: {
            args: Prisma.sys_menu_on_roleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.sys_menu_on_roleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sys_menu_on_rolePayload>
          }
          update: {
            args: Prisma.sys_menu_on_roleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sys_menu_on_rolePayload>
          }
          deleteMany: {
            args: Prisma.sys_menu_on_roleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.sys_menu_on_roleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.sys_menu_on_roleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sys_menu_on_rolePayload>
          }
          aggregate: {
            args: Prisma.Sys_menu_on_roleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSys_menu_on_role>
          }
          groupBy: {
            args: Prisma.sys_menu_on_roleGroupByArgs<ExtArgs>
            result: $Utils.Optional<Sys_menu_on_roleGroupByOutputType>[]
          }
          count: {
            args: Prisma.sys_menu_on_roleCountArgs<ExtArgs>
            result: $Utils.Optional<Sys_menu_on_roleCountAggregateOutputType> | number
          }
        }
      }
      sys_role: {
        payload: Prisma.$sys_rolePayload<ExtArgs>
        fields: Prisma.sys_roleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.sys_roleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sys_rolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.sys_roleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sys_rolePayload>
          }
          findFirst: {
            args: Prisma.sys_roleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sys_rolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.sys_roleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sys_rolePayload>
          }
          findMany: {
            args: Prisma.sys_roleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sys_rolePayload>[]
          }
          create: {
            args: Prisma.sys_roleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sys_rolePayload>
          }
          createMany: {
            args: Prisma.sys_roleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.sys_roleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sys_rolePayload>
          }
          update: {
            args: Prisma.sys_roleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sys_rolePayload>
          }
          deleteMany: {
            args: Prisma.sys_roleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.sys_roleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.sys_roleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sys_rolePayload>
          }
          aggregate: {
            args: Prisma.Sys_roleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSys_role>
          }
          groupBy: {
            args: Prisma.sys_roleGroupByArgs<ExtArgs>
            result: $Utils.Optional<Sys_roleGroupByOutputType>[]
          }
          count: {
            args: Prisma.sys_roleCountArgs<ExtArgs>
            result: $Utils.Optional<Sys_roleCountAggregateOutputType> | number
          }
        }
      }
      blog_user: {
        payload: Prisma.$blog_userPayload<ExtArgs>
        fields: Prisma.blog_userFieldRefs
        operations: {
          findUnique: {
            args: Prisma.blog_userFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blog_userPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.blog_userFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blog_userPayload>
          }
          findFirst: {
            args: Prisma.blog_userFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blog_userPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.blog_userFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blog_userPayload>
          }
          findMany: {
            args: Prisma.blog_userFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blog_userPayload>[]
          }
          create: {
            args: Prisma.blog_userCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blog_userPayload>
          }
          createMany: {
            args: Prisma.blog_userCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.blog_userDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blog_userPayload>
          }
          update: {
            args: Prisma.blog_userUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blog_userPayload>
          }
          deleteMany: {
            args: Prisma.blog_userDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.blog_userUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.blog_userUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blog_userPayload>
          }
          aggregate: {
            args: Prisma.Blog_userAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBlog_user>
          }
          groupBy: {
            args: Prisma.blog_userGroupByArgs<ExtArgs>
            result: $Utils.Optional<Blog_userGroupByOutputType>[]
          }
          count: {
            args: Prisma.blog_userCountArgs<ExtArgs>
            result: $Utils.Optional<Blog_userCountAggregateOutputType> | number
          }
        }
      }
      blog_categories: {
        payload: Prisma.$blog_categoriesPayload<ExtArgs>
        fields: Prisma.blog_categoriesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.blog_categoriesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blog_categoriesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.blog_categoriesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blog_categoriesPayload>
          }
          findFirst: {
            args: Prisma.blog_categoriesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blog_categoriesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.blog_categoriesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blog_categoriesPayload>
          }
          findMany: {
            args: Prisma.blog_categoriesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blog_categoriesPayload>[]
          }
          create: {
            args: Prisma.blog_categoriesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blog_categoriesPayload>
          }
          createMany: {
            args: Prisma.blog_categoriesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.blog_categoriesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blog_categoriesPayload>
          }
          update: {
            args: Prisma.blog_categoriesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blog_categoriesPayload>
          }
          deleteMany: {
            args: Prisma.blog_categoriesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.blog_categoriesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.blog_categoriesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blog_categoriesPayload>
          }
          aggregate: {
            args: Prisma.Blog_categoriesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBlog_categories>
          }
          groupBy: {
            args: Prisma.blog_categoriesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Blog_categoriesGroupByOutputType>[]
          }
          count: {
            args: Prisma.blog_categoriesCountArgs<ExtArgs>
            result: $Utils.Optional<Blog_categoriesCountAggregateOutputType> | number
          }
        }
      }
      blog_posts: {
        payload: Prisma.$blog_postsPayload<ExtArgs>
        fields: Prisma.blog_postsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.blog_postsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blog_postsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.blog_postsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blog_postsPayload>
          }
          findFirst: {
            args: Prisma.blog_postsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blog_postsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.blog_postsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blog_postsPayload>
          }
          findMany: {
            args: Prisma.blog_postsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blog_postsPayload>[]
          }
          create: {
            args: Prisma.blog_postsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blog_postsPayload>
          }
          createMany: {
            args: Prisma.blog_postsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.blog_postsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blog_postsPayload>
          }
          update: {
            args: Prisma.blog_postsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blog_postsPayload>
          }
          deleteMany: {
            args: Prisma.blog_postsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.blog_postsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.blog_postsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blog_postsPayload>
          }
          aggregate: {
            args: Prisma.Blog_postsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBlog_posts>
          }
          groupBy: {
            args: Prisma.blog_postsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Blog_postsGroupByOutputType>[]
          }
          count: {
            args: Prisma.blog_postsCountArgs<ExtArgs>
            result: $Utils.Optional<Blog_postsCountAggregateOutputType> | number
          }
        }
      }
      blog_notice: {
        payload: Prisma.$blog_noticePayload<ExtArgs>
        fields: Prisma.blog_noticeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.blog_noticeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blog_noticePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.blog_noticeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blog_noticePayload>
          }
          findFirst: {
            args: Prisma.blog_noticeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blog_noticePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.blog_noticeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blog_noticePayload>
          }
          findMany: {
            args: Prisma.blog_noticeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blog_noticePayload>[]
          }
          create: {
            args: Prisma.blog_noticeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blog_noticePayload>
          }
          createMany: {
            args: Prisma.blog_noticeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.blog_noticeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blog_noticePayload>
          }
          update: {
            args: Prisma.blog_noticeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blog_noticePayload>
          }
          deleteMany: {
            args: Prisma.blog_noticeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.blog_noticeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.blog_noticeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blog_noticePayload>
          }
          aggregate: {
            args: Prisma.Blog_noticeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBlog_notice>
          }
          groupBy: {
            args: Prisma.blog_noticeGroupByArgs<ExtArgs>
            result: $Utils.Optional<Blog_noticeGroupByOutputType>[]
          }
          count: {
            args: Prisma.blog_noticeCountArgs<ExtArgs>
            result: $Utils.Optional<Blog_noticeCountAggregateOutputType> | number
          }
        }
      }
      blog_posts_on_tags: {
        payload: Prisma.$blog_posts_on_tagsPayload<ExtArgs>
        fields: Prisma.blog_posts_on_tagsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.blog_posts_on_tagsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blog_posts_on_tagsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.blog_posts_on_tagsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blog_posts_on_tagsPayload>
          }
          findFirst: {
            args: Prisma.blog_posts_on_tagsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blog_posts_on_tagsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.blog_posts_on_tagsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blog_posts_on_tagsPayload>
          }
          findMany: {
            args: Prisma.blog_posts_on_tagsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blog_posts_on_tagsPayload>[]
          }
          create: {
            args: Prisma.blog_posts_on_tagsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blog_posts_on_tagsPayload>
          }
          createMany: {
            args: Prisma.blog_posts_on_tagsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.blog_posts_on_tagsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blog_posts_on_tagsPayload>
          }
          update: {
            args: Prisma.blog_posts_on_tagsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blog_posts_on_tagsPayload>
          }
          deleteMany: {
            args: Prisma.blog_posts_on_tagsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.blog_posts_on_tagsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.blog_posts_on_tagsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blog_posts_on_tagsPayload>
          }
          aggregate: {
            args: Prisma.Blog_posts_on_tagsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBlog_posts_on_tags>
          }
          groupBy: {
            args: Prisma.blog_posts_on_tagsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Blog_posts_on_tagsGroupByOutputType>[]
          }
          count: {
            args: Prisma.blog_posts_on_tagsCountArgs<ExtArgs>
            result: $Utils.Optional<Blog_posts_on_tagsCountAggregateOutputType> | number
          }
        }
      }
      blog_tag: {
        payload: Prisma.$blog_tagPayload<ExtArgs>
        fields: Prisma.blog_tagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.blog_tagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blog_tagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.blog_tagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blog_tagPayload>
          }
          findFirst: {
            args: Prisma.blog_tagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blog_tagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.blog_tagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blog_tagPayload>
          }
          findMany: {
            args: Prisma.blog_tagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blog_tagPayload>[]
          }
          create: {
            args: Prisma.blog_tagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blog_tagPayload>
          }
          createMany: {
            args: Prisma.blog_tagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.blog_tagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blog_tagPayload>
          }
          update: {
            args: Prisma.blog_tagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blog_tagPayload>
          }
          deleteMany: {
            args: Prisma.blog_tagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.blog_tagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.blog_tagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blog_tagPayload>
          }
          aggregate: {
            args: Prisma.Blog_tagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBlog_tag>
          }
          groupBy: {
            args: Prisma.blog_tagGroupByArgs<ExtArgs>
            result: $Utils.Optional<Blog_tagGroupByOutputType>[]
          }
          count: {
            args: Prisma.blog_tagCountArgs<ExtArgs>
            result: $Utils.Optional<Blog_tagCountAggregateOutputType> | number
          }
        }
      }
      file_user: {
        payload: Prisma.$file_userPayload<ExtArgs>
        fields: Prisma.file_userFieldRefs
        operations: {
          findUnique: {
            args: Prisma.file_userFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$file_userPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.file_userFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$file_userPayload>
          }
          findFirst: {
            args: Prisma.file_userFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$file_userPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.file_userFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$file_userPayload>
          }
          findMany: {
            args: Prisma.file_userFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$file_userPayload>[]
          }
          create: {
            args: Prisma.file_userCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$file_userPayload>
          }
          createMany: {
            args: Prisma.file_userCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.file_userDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$file_userPayload>
          }
          update: {
            args: Prisma.file_userUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$file_userPayload>
          }
          deleteMany: {
            args: Prisma.file_userDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.file_userUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.file_userUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$file_userPayload>
          }
          aggregate: {
            args: Prisma.File_userAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFile_user>
          }
          groupBy: {
            args: Prisma.file_userGroupByArgs<ExtArgs>
            result: $Utils.Optional<File_userGroupByOutputType>[]
          }
          count: {
            args: Prisma.file_userCountArgs<ExtArgs>
            result: $Utils.Optional<File_userCountAggregateOutputType> | number
          }
        }
      }
      file_keys: {
        payload: Prisma.$file_keysPayload<ExtArgs>
        fields: Prisma.file_keysFieldRefs
        operations: {
          findUnique: {
            args: Prisma.file_keysFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$file_keysPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.file_keysFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$file_keysPayload>
          }
          findFirst: {
            args: Prisma.file_keysFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$file_keysPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.file_keysFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$file_keysPayload>
          }
          findMany: {
            args: Prisma.file_keysFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$file_keysPayload>[]
          }
          create: {
            args: Prisma.file_keysCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$file_keysPayload>
          }
          createMany: {
            args: Prisma.file_keysCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.file_keysDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$file_keysPayload>
          }
          update: {
            args: Prisma.file_keysUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$file_keysPayload>
          }
          deleteMany: {
            args: Prisma.file_keysDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.file_keysUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.file_keysUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$file_keysPayload>
          }
          aggregate: {
            args: Prisma.File_keysAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFile_keys>
          }
          groupBy: {
            args: Prisma.file_keysGroupByArgs<ExtArgs>
            result: $Utils.Optional<File_keysGroupByOutputType>[]
          }
          count: {
            args: Prisma.file_keysCountArgs<ExtArgs>
            result: $Utils.Optional<File_keysCountAggregateOutputType> | number
          }
        }
      }
      file_config: {
        payload: Prisma.$file_configPayload<ExtArgs>
        fields: Prisma.file_configFieldRefs
        operations: {
          findUnique: {
            args: Prisma.file_configFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$file_configPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.file_configFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$file_configPayload>
          }
          findFirst: {
            args: Prisma.file_configFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$file_configPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.file_configFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$file_configPayload>
          }
          findMany: {
            args: Prisma.file_configFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$file_configPayload>[]
          }
          create: {
            args: Prisma.file_configCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$file_configPayload>
          }
          createMany: {
            args: Prisma.file_configCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.file_configDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$file_configPayload>
          }
          update: {
            args: Prisma.file_configUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$file_configPayload>
          }
          deleteMany: {
            args: Prisma.file_configDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.file_configUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.file_configUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$file_configPayload>
          }
          aggregate: {
            args: Prisma.File_configAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFile_config>
          }
          groupBy: {
            args: Prisma.file_configGroupByArgs<ExtArgs>
            result: $Utils.Optional<File_configGroupByOutputType>[]
          }
          count: {
            args: Prisma.file_configCountArgs<ExtArgs>
            result: $Utils.Optional<File_configCountAggregateOutputType> | number
          }
        }
      }
      file_user_on_media: {
        payload: Prisma.$file_user_on_mediaPayload<ExtArgs>
        fields: Prisma.file_user_on_mediaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.file_user_on_mediaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$file_user_on_mediaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.file_user_on_mediaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$file_user_on_mediaPayload>
          }
          findFirst: {
            args: Prisma.file_user_on_mediaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$file_user_on_mediaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.file_user_on_mediaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$file_user_on_mediaPayload>
          }
          findMany: {
            args: Prisma.file_user_on_mediaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$file_user_on_mediaPayload>[]
          }
          create: {
            args: Prisma.file_user_on_mediaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$file_user_on_mediaPayload>
          }
          createMany: {
            args: Prisma.file_user_on_mediaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.file_user_on_mediaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$file_user_on_mediaPayload>
          }
          update: {
            args: Prisma.file_user_on_mediaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$file_user_on_mediaPayload>
          }
          deleteMany: {
            args: Prisma.file_user_on_mediaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.file_user_on_mediaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.file_user_on_mediaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$file_user_on_mediaPayload>
          }
          aggregate: {
            args: Prisma.File_user_on_mediaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFile_user_on_media>
          }
          groupBy: {
            args: Prisma.file_user_on_mediaGroupByArgs<ExtArgs>
            result: $Utils.Optional<File_user_on_mediaGroupByOutputType>[]
          }
          count: {
            args: Prisma.file_user_on_mediaCountArgs<ExtArgs>
            result: $Utils.Optional<File_user_on_mediaCountAggregateOutputType> | number
          }
        }
      }
      file_block: {
        payload: Prisma.$file_blockPayload<ExtArgs>
        fields: Prisma.file_blockFieldRefs
        operations: {
          findUnique: {
            args: Prisma.file_blockFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$file_blockPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.file_blockFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$file_blockPayload>
          }
          findFirst: {
            args: Prisma.file_blockFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$file_blockPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.file_blockFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$file_blockPayload>
          }
          findMany: {
            args: Prisma.file_blockFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$file_blockPayload>[]
          }
          create: {
            args: Prisma.file_blockCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$file_blockPayload>
          }
          createMany: {
            args: Prisma.file_blockCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.file_blockDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$file_blockPayload>
          }
          update: {
            args: Prisma.file_blockUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$file_blockPayload>
          }
          deleteMany: {
            args: Prisma.file_blockDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.file_blockUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.file_blockUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$file_blockPayload>
          }
          aggregate: {
            args: Prisma.File_blockAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFile_block>
          }
          groupBy: {
            args: Prisma.file_blockGroupByArgs<ExtArgs>
            result: $Utils.Optional<File_blockGroupByOutputType>[]
          }
          count: {
            args: Prisma.file_blockCountArgs<ExtArgs>
            result: $Utils.Optional<File_blockCountAggregateOutputType> | number
          }
        }
      }
      file_media: {
        payload: Prisma.$file_mediaPayload<ExtArgs>
        fields: Prisma.file_mediaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.file_mediaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$file_mediaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.file_mediaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$file_mediaPayload>
          }
          findFirst: {
            args: Prisma.file_mediaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$file_mediaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.file_mediaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$file_mediaPayload>
          }
          findMany: {
            args: Prisma.file_mediaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$file_mediaPayload>[]
          }
          create: {
            args: Prisma.file_mediaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$file_mediaPayload>
          }
          createMany: {
            args: Prisma.file_mediaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.file_mediaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$file_mediaPayload>
          }
          update: {
            args: Prisma.file_mediaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$file_mediaPayload>
          }
          deleteMany: {
            args: Prisma.file_mediaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.file_mediaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.file_mediaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$file_mediaPayload>
          }
          aggregate: {
            args: Prisma.File_mediaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFile_media>
          }
          groupBy: {
            args: Prisma.file_mediaGroupByArgs<ExtArgs>
            result: $Utils.Optional<File_mediaGroupByOutputType>[]
          }
          count: {
            args: Prisma.file_mediaCountArgs<ExtArgs>
            result: $Utils.Optional<File_mediaCountAggregateOutputType> | number
          }
        }
      }
      file_media_on_folder: {
        payload: Prisma.$file_media_on_folderPayload<ExtArgs>
        fields: Prisma.file_media_on_folderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.file_media_on_folderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$file_media_on_folderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.file_media_on_folderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$file_media_on_folderPayload>
          }
          findFirst: {
            args: Prisma.file_media_on_folderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$file_media_on_folderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.file_media_on_folderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$file_media_on_folderPayload>
          }
          findMany: {
            args: Prisma.file_media_on_folderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$file_media_on_folderPayload>[]
          }
          create: {
            args: Prisma.file_media_on_folderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$file_media_on_folderPayload>
          }
          createMany: {
            args: Prisma.file_media_on_folderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.file_media_on_folderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$file_media_on_folderPayload>
          }
          update: {
            args: Prisma.file_media_on_folderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$file_media_on_folderPayload>
          }
          deleteMany: {
            args: Prisma.file_media_on_folderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.file_media_on_folderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.file_media_on_folderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$file_media_on_folderPayload>
          }
          aggregate: {
            args: Prisma.File_media_on_folderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFile_media_on_folder>
          }
          groupBy: {
            args: Prisma.file_media_on_folderGroupByArgs<ExtArgs>
            result: $Utils.Optional<File_media_on_folderGroupByOutputType>[]
          }
          count: {
            args: Prisma.file_media_on_folderCountArgs<ExtArgs>
            result: $Utils.Optional<File_media_on_folderCountAggregateOutputType> | number
          }
        }
      }
      file_folder: {
        payload: Prisma.$file_folderPayload<ExtArgs>
        fields: Prisma.file_folderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.file_folderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$file_folderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.file_folderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$file_folderPayload>
          }
          findFirst: {
            args: Prisma.file_folderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$file_folderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.file_folderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$file_folderPayload>
          }
          findMany: {
            args: Prisma.file_folderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$file_folderPayload>[]
          }
          create: {
            args: Prisma.file_folderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$file_folderPayload>
          }
          createMany: {
            args: Prisma.file_folderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.file_folderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$file_folderPayload>
          }
          update: {
            args: Prisma.file_folderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$file_folderPayload>
          }
          deleteMany: {
            args: Prisma.file_folderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.file_folderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.file_folderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$file_folderPayload>
          }
          aggregate: {
            args: Prisma.File_folderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFile_folder>
          }
          groupBy: {
            args: Prisma.file_folderGroupByArgs<ExtArgs>
            result: $Utils.Optional<File_folderGroupByOutputType>[]
          }
          count: {
            args: Prisma.file_folderCountArgs<ExtArgs>
            result: $Utils.Optional<File_folderCountAggregateOutputType> | number
          }
        }
      }
      book_user: {
        payload: Prisma.$book_userPayload<ExtArgs>
        fields: Prisma.book_userFieldRefs
        operations: {
          findUnique: {
            args: Prisma.book_userFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$book_userPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.book_userFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$book_userPayload>
          }
          findFirst: {
            args: Prisma.book_userFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$book_userPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.book_userFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$book_userPayload>
          }
          findMany: {
            args: Prisma.book_userFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$book_userPayload>[]
          }
          create: {
            args: Prisma.book_userCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$book_userPayload>
          }
          createMany: {
            args: Prisma.book_userCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.book_userDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$book_userPayload>
          }
          update: {
            args: Prisma.book_userUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$book_userPayload>
          }
          deleteMany: {
            args: Prisma.book_userDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.book_userUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.book_userUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$book_userPayload>
          }
          aggregate: {
            args: Prisma.Book_userAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBook_user>
          }
          groupBy: {
            args: Prisma.book_userGroupByArgs<ExtArgs>
            result: $Utils.Optional<Book_userGroupByOutputType>[]
          }
          count: {
            args: Prisma.book_userCountArgs<ExtArgs>
            result: $Utils.Optional<Book_userCountAggregateOutputType> | number
          }
        }
      }
      book_book: {
        payload: Prisma.$book_bookPayload<ExtArgs>
        fields: Prisma.book_bookFieldRefs
        operations: {
          findUnique: {
            args: Prisma.book_bookFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$book_bookPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.book_bookFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$book_bookPayload>
          }
          findFirst: {
            args: Prisma.book_bookFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$book_bookPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.book_bookFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$book_bookPayload>
          }
          findMany: {
            args: Prisma.book_bookFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$book_bookPayload>[]
          }
          create: {
            args: Prisma.book_bookCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$book_bookPayload>
          }
          createMany: {
            args: Prisma.book_bookCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.book_bookDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$book_bookPayload>
          }
          update: {
            args: Prisma.book_bookUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$book_bookPayload>
          }
          deleteMany: {
            args: Prisma.book_bookDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.book_bookUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.book_bookUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$book_bookPayload>
          }
          aggregate: {
            args: Prisma.Book_bookAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBook_book>
          }
          groupBy: {
            args: Prisma.book_bookGroupByArgs<ExtArgs>
            result: $Utils.Optional<Book_bookGroupByOutputType>[]
          }
          count: {
            args: Prisma.book_bookCountArgs<ExtArgs>
            result: $Utils.Optional<Book_bookCountAggregateOutputType> | number
          }
        }
      }
      book_category: {
        payload: Prisma.$book_categoryPayload<ExtArgs>
        fields: Prisma.book_categoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.book_categoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$book_categoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.book_categoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$book_categoryPayload>
          }
          findFirst: {
            args: Prisma.book_categoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$book_categoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.book_categoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$book_categoryPayload>
          }
          findMany: {
            args: Prisma.book_categoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$book_categoryPayload>[]
          }
          create: {
            args: Prisma.book_categoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$book_categoryPayload>
          }
          createMany: {
            args: Prisma.book_categoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.book_categoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$book_categoryPayload>
          }
          update: {
            args: Prisma.book_categoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$book_categoryPayload>
          }
          deleteMany: {
            args: Prisma.book_categoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.book_categoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.book_categoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$book_categoryPayload>
          }
          aggregate: {
            args: Prisma.Book_categoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBook_category>
          }
          groupBy: {
            args: Prisma.book_categoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<Book_categoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.book_categoryCountArgs<ExtArgs>
            result: $Utils.Optional<Book_categoryCountAggregateOutputType> | number
          }
        }
      }
      book_borrowed: {
        payload: Prisma.$book_borrowedPayload<ExtArgs>
        fields: Prisma.book_borrowedFieldRefs
        operations: {
          findUnique: {
            args: Prisma.book_borrowedFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$book_borrowedPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.book_borrowedFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$book_borrowedPayload>
          }
          findFirst: {
            args: Prisma.book_borrowedFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$book_borrowedPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.book_borrowedFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$book_borrowedPayload>
          }
          findMany: {
            args: Prisma.book_borrowedFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$book_borrowedPayload>[]
          }
          create: {
            args: Prisma.book_borrowedCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$book_borrowedPayload>
          }
          createMany: {
            args: Prisma.book_borrowedCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.book_borrowedDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$book_borrowedPayload>
          }
          update: {
            args: Prisma.book_borrowedUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$book_borrowedPayload>
          }
          deleteMany: {
            args: Prisma.book_borrowedDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.book_borrowedUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.book_borrowedUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$book_borrowedPayload>
          }
          aggregate: {
            args: Prisma.Book_borrowedAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBook_borrowed>
          }
          groupBy: {
            args: Prisma.book_borrowedGroupByArgs<ExtArgs>
            result: $Utils.Optional<Book_borrowedGroupByOutputType>[]
          }
          count: {
            args: Prisma.book_borrowedCountArgs<ExtArgs>
            result: $Utils.Optional<Book_borrowedCountAggregateOutputType> | number
          }
        }
      }
      book_borrow_history: {
        payload: Prisma.$book_borrow_historyPayload<ExtArgs>
        fields: Prisma.book_borrow_historyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.book_borrow_historyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$book_borrow_historyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.book_borrow_historyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$book_borrow_historyPayload>
          }
          findFirst: {
            args: Prisma.book_borrow_historyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$book_borrow_historyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.book_borrow_historyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$book_borrow_historyPayload>
          }
          findMany: {
            args: Prisma.book_borrow_historyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$book_borrow_historyPayload>[]
          }
          create: {
            args: Prisma.book_borrow_historyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$book_borrow_historyPayload>
          }
          createMany: {
            args: Prisma.book_borrow_historyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.book_borrow_historyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$book_borrow_historyPayload>
          }
          update: {
            args: Prisma.book_borrow_historyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$book_borrow_historyPayload>
          }
          deleteMany: {
            args: Prisma.book_borrow_historyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.book_borrow_historyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.book_borrow_historyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$book_borrow_historyPayload>
          }
          aggregate: {
            args: Prisma.Book_borrow_historyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBook_borrow_history>
          }
          groupBy: {
            args: Prisma.book_borrow_historyGroupByArgs<ExtArgs>
            result: $Utils.Optional<Book_borrow_historyGroupByOutputType>[]
          }
          count: {
            args: Prisma.book_borrow_historyCountArgs<ExtArgs>
            result: $Utils.Optional<Book_borrow_historyCountAggregateOutputType> | number
          }
        }
      }
      book_rating: {
        payload: Prisma.$book_ratingPayload<ExtArgs>
        fields: Prisma.book_ratingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.book_ratingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$book_ratingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.book_ratingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$book_ratingPayload>
          }
          findFirst: {
            args: Prisma.book_ratingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$book_ratingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.book_ratingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$book_ratingPayload>
          }
          findMany: {
            args: Prisma.book_ratingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$book_ratingPayload>[]
          }
          create: {
            args: Prisma.book_ratingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$book_ratingPayload>
          }
          createMany: {
            args: Prisma.book_ratingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.book_ratingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$book_ratingPayload>
          }
          update: {
            args: Prisma.book_ratingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$book_ratingPayload>
          }
          deleteMany: {
            args: Prisma.book_ratingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.book_ratingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.book_ratingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$book_ratingPayload>
          }
          aggregate: {
            args: Prisma.Book_ratingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBook_rating>
          }
          groupBy: {
            args: Prisma.book_ratingGroupByArgs<ExtArgs>
            result: $Utils.Optional<Book_ratingGroupByOutputType>[]
          }
          count: {
            args: Prisma.book_ratingCountArgs<ExtArgs>
            result: $Utils.Optional<Book_ratingCountAggregateOutputType> | number
          }
        }
      }
      study_user: {
        payload: Prisma.$study_userPayload<ExtArgs>
        fields: Prisma.study_userFieldRefs
        operations: {
          findUnique: {
            args: Prisma.study_userFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$study_userPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.study_userFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$study_userPayload>
          }
          findFirst: {
            args: Prisma.study_userFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$study_userPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.study_userFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$study_userPayload>
          }
          findMany: {
            args: Prisma.study_userFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$study_userPayload>[]
          }
          create: {
            args: Prisma.study_userCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$study_userPayload>
          }
          createMany: {
            args: Prisma.study_userCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.study_userDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$study_userPayload>
          }
          update: {
            args: Prisma.study_userUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$study_userPayload>
          }
          deleteMany: {
            args: Prisma.study_userDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.study_userUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.study_userUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$study_userPayload>
          }
          aggregate: {
            args: Prisma.Study_userAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudy_user>
          }
          groupBy: {
            args: Prisma.study_userGroupByArgs<ExtArgs>
            result: $Utils.Optional<Study_userGroupByOutputType>[]
          }
          count: {
            args: Prisma.study_userCountArgs<ExtArgs>
            result: $Utils.Optional<Study_userCountAggregateOutputType> | number
          }
        }
      }
      study_store: {
        payload: Prisma.$study_storePayload<ExtArgs>
        fields: Prisma.study_storeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.study_storeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$study_storePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.study_storeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$study_storePayload>
          }
          findFirst: {
            args: Prisma.study_storeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$study_storePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.study_storeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$study_storePayload>
          }
          findMany: {
            args: Prisma.study_storeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$study_storePayload>[]
          }
          create: {
            args: Prisma.study_storeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$study_storePayload>
          }
          createMany: {
            args: Prisma.study_storeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.study_storeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$study_storePayload>
          }
          update: {
            args: Prisma.study_storeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$study_storePayload>
          }
          deleteMany: {
            args: Prisma.study_storeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.study_storeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.study_storeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$study_storePayload>
          }
          aggregate: {
            args: Prisma.Study_storeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudy_store>
          }
          groupBy: {
            args: Prisma.study_storeGroupByArgs<ExtArgs>
            result: $Utils.Optional<Study_storeGroupByOutputType>[]
          }
          count: {
            args: Prisma.study_storeCountArgs<ExtArgs>
            result: $Utils.Optional<Study_storeCountAggregateOutputType> | number
          }
        }
      }
      study_floor: {
        payload: Prisma.$study_floorPayload<ExtArgs>
        fields: Prisma.study_floorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.study_floorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$study_floorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.study_floorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$study_floorPayload>
          }
          findFirst: {
            args: Prisma.study_floorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$study_floorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.study_floorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$study_floorPayload>
          }
          findMany: {
            args: Prisma.study_floorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$study_floorPayload>[]
          }
          create: {
            args: Prisma.study_floorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$study_floorPayload>
          }
          createMany: {
            args: Prisma.study_floorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.study_floorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$study_floorPayload>
          }
          update: {
            args: Prisma.study_floorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$study_floorPayload>
          }
          deleteMany: {
            args: Prisma.study_floorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.study_floorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.study_floorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$study_floorPayload>
          }
          aggregate: {
            args: Prisma.Study_floorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudy_floor>
          }
          groupBy: {
            args: Prisma.study_floorGroupByArgs<ExtArgs>
            result: $Utils.Optional<Study_floorGroupByOutputType>[]
          }
          count: {
            args: Prisma.study_floorCountArgs<ExtArgs>
            result: $Utils.Optional<Study_floorCountAggregateOutputType> | number
          }
        }
      }
      study_room: {
        payload: Prisma.$study_roomPayload<ExtArgs>
        fields: Prisma.study_roomFieldRefs
        operations: {
          findUnique: {
            args: Prisma.study_roomFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$study_roomPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.study_roomFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$study_roomPayload>
          }
          findFirst: {
            args: Prisma.study_roomFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$study_roomPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.study_roomFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$study_roomPayload>
          }
          findMany: {
            args: Prisma.study_roomFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$study_roomPayload>[]
          }
          create: {
            args: Prisma.study_roomCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$study_roomPayload>
          }
          createMany: {
            args: Prisma.study_roomCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.study_roomDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$study_roomPayload>
          }
          update: {
            args: Prisma.study_roomUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$study_roomPayload>
          }
          deleteMany: {
            args: Prisma.study_roomDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.study_roomUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.study_roomUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$study_roomPayload>
          }
          aggregate: {
            args: Prisma.Study_roomAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudy_room>
          }
          groupBy: {
            args: Prisma.study_roomGroupByArgs<ExtArgs>
            result: $Utils.Optional<Study_roomGroupByOutputType>[]
          }
          count: {
            args: Prisma.study_roomCountArgs<ExtArgs>
            result: $Utils.Optional<Study_roomCountAggregateOutputType> | number
          }
        }
      }
      study_seat: {
        payload: Prisma.$study_seatPayload<ExtArgs>
        fields: Prisma.study_seatFieldRefs
        operations: {
          findUnique: {
            args: Prisma.study_seatFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$study_seatPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.study_seatFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$study_seatPayload>
          }
          findFirst: {
            args: Prisma.study_seatFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$study_seatPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.study_seatFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$study_seatPayload>
          }
          findMany: {
            args: Prisma.study_seatFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$study_seatPayload>[]
          }
          create: {
            args: Prisma.study_seatCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$study_seatPayload>
          }
          createMany: {
            args: Prisma.study_seatCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.study_seatDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$study_seatPayload>
          }
          update: {
            args: Prisma.study_seatUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$study_seatPayload>
          }
          deleteMany: {
            args: Prisma.study_seatDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.study_seatUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.study_seatUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$study_seatPayload>
          }
          aggregate: {
            args: Prisma.Study_seatAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudy_seat>
          }
          groupBy: {
            args: Prisma.study_seatGroupByArgs<ExtArgs>
            result: $Utils.Optional<Study_seatGroupByOutputType>[]
          }
          count: {
            args: Prisma.study_seatCountArgs<ExtArgs>
            result: $Utils.Optional<Study_seatCountAggregateOutputType> | number
          }
        }
      }
      study_reservation: {
        payload: Prisma.$study_reservationPayload<ExtArgs>
        fields: Prisma.study_reservationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.study_reservationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$study_reservationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.study_reservationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$study_reservationPayload>
          }
          findFirst: {
            args: Prisma.study_reservationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$study_reservationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.study_reservationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$study_reservationPayload>
          }
          findMany: {
            args: Prisma.study_reservationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$study_reservationPayload>[]
          }
          create: {
            args: Prisma.study_reservationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$study_reservationPayload>
          }
          createMany: {
            args: Prisma.study_reservationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.study_reservationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$study_reservationPayload>
          }
          update: {
            args: Prisma.study_reservationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$study_reservationPayload>
          }
          deleteMany: {
            args: Prisma.study_reservationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.study_reservationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.study_reservationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$study_reservationPayload>
          }
          aggregate: {
            args: Prisma.Study_reservationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudy_reservation>
          }
          groupBy: {
            args: Prisma.study_reservationGroupByArgs<ExtArgs>
            result: $Utils.Optional<Study_reservationGroupByOutputType>[]
          }
          count: {
            args: Prisma.study_reservationCountArgs<ExtArgs>
            result: $Utils.Optional<Study_reservationCountAggregateOutputType> | number
          }
        }
      }
      study_message: {
        payload: Prisma.$study_messagePayload<ExtArgs>
        fields: Prisma.study_messageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.study_messageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$study_messagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.study_messageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$study_messagePayload>
          }
          findFirst: {
            args: Prisma.study_messageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$study_messagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.study_messageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$study_messagePayload>
          }
          findMany: {
            args: Prisma.study_messageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$study_messagePayload>[]
          }
          create: {
            args: Prisma.study_messageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$study_messagePayload>
          }
          createMany: {
            args: Prisma.study_messageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.study_messageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$study_messagePayload>
          }
          update: {
            args: Prisma.study_messageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$study_messagePayload>
          }
          deleteMany: {
            args: Prisma.study_messageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.study_messageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.study_messageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$study_messagePayload>
          }
          aggregate: {
            args: Prisma.Study_messageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudy_message>
          }
          groupBy: {
            args: Prisma.study_messageGroupByArgs<ExtArgs>
            result: $Utils.Optional<Study_messageGroupByOutputType>[]
          }
          count: {
            args: Prisma.study_messageCountArgs<ExtArgs>
            result: $Utils.Optional<Study_messageCountAggregateOutputType> | number
          }
        }
      }
      study_announcement: {
        payload: Prisma.$study_announcementPayload<ExtArgs>
        fields: Prisma.study_announcementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.study_announcementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$study_announcementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.study_announcementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$study_announcementPayload>
          }
          findFirst: {
            args: Prisma.study_announcementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$study_announcementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.study_announcementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$study_announcementPayload>
          }
          findMany: {
            args: Prisma.study_announcementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$study_announcementPayload>[]
          }
          create: {
            args: Prisma.study_announcementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$study_announcementPayload>
          }
          createMany: {
            args: Prisma.study_announcementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.study_announcementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$study_announcementPayload>
          }
          update: {
            args: Prisma.study_announcementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$study_announcementPayload>
          }
          deleteMany: {
            args: Prisma.study_announcementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.study_announcementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.study_announcementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$study_announcementPayload>
          }
          aggregate: {
            args: Prisma.Study_announcementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudy_announcement>
          }
          groupBy: {
            args: Prisma.study_announcementGroupByArgs<ExtArgs>
            result: $Utils.Optional<Study_announcementGroupByOutputType>[]
          }
          count: {
            args: Prisma.study_announcementCountArgs<ExtArgs>
            result: $Utils.Optional<Study_announcementCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    sys_user?: sys_userOmit
    sys_account?: sys_accountOmit
    sys_menu?: sys_menuOmit
    sys_user_ban_menu?: sys_user_ban_menuOmit
    sys_menu_on_role?: sys_menu_on_roleOmit
    sys_role?: sys_roleOmit
    blog_user?: blog_userOmit
    blog_categories?: blog_categoriesOmit
    blog_posts?: blog_postsOmit
    blog_notice?: blog_noticeOmit
    blog_posts_on_tags?: blog_posts_on_tagsOmit
    blog_tag?: blog_tagOmit
    file_user?: file_userOmit
    file_keys?: file_keysOmit
    file_config?: file_configOmit
    file_user_on_media?: file_user_on_mediaOmit
    file_block?: file_blockOmit
    file_media?: file_mediaOmit
    file_media_on_folder?: file_media_on_folderOmit
    file_folder?: file_folderOmit
    book_user?: book_userOmit
    book_book?: book_bookOmit
    book_category?: book_categoryOmit
    book_borrowed?: book_borrowedOmit
    book_borrow_history?: book_borrow_historyOmit
    book_rating?: book_ratingOmit
    study_user?: study_userOmit
    study_store?: study_storeOmit
    study_floor?: study_floorOmit
    study_room?: study_roomOmit
    study_seat?: study_seatOmit
    study_reservation?: study_reservationOmit
    study_message?: study_messageOmit
    study_announcement?: study_announcementOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type Sys_userCountOutputType
   */

  export type Sys_userCountOutputType = {
    accounts: number
    ban_menus: number
  }

  export type Sys_userCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accounts?: boolean | Sys_userCountOutputTypeCountAccountsArgs
    ban_menus?: boolean | Sys_userCountOutputTypeCountBan_menusArgs
  }

  // Custom InputTypes
  /**
   * Sys_userCountOutputType without action
   */
  export type Sys_userCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sys_userCountOutputType
     */
    select?: Sys_userCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Sys_userCountOutputType without action
   */
  export type Sys_userCountOutputTypeCountAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: sys_accountWhereInput
  }

  /**
   * Sys_userCountOutputType without action
   */
  export type Sys_userCountOutputTypeCountBan_menusArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: sys_user_ban_menuWhereInput
  }


  /**
   * Count Type Sys_menuCountOutputType
   */

  export type Sys_menuCountOutputType = {
    children: number
    roles: number
    user_bans: number
  }

  export type Sys_menuCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    children?: boolean | Sys_menuCountOutputTypeCountChildrenArgs
    roles?: boolean | Sys_menuCountOutputTypeCountRolesArgs
    user_bans?: boolean | Sys_menuCountOutputTypeCountUser_bansArgs
  }

  // Custom InputTypes
  /**
   * Sys_menuCountOutputType without action
   */
  export type Sys_menuCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sys_menuCountOutputType
     */
    select?: Sys_menuCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Sys_menuCountOutputType without action
   */
  export type Sys_menuCountOutputTypeCountChildrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: sys_menuWhereInput
  }

  /**
   * Sys_menuCountOutputType without action
   */
  export type Sys_menuCountOutputTypeCountRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: sys_menu_on_roleWhereInput
  }

  /**
   * Sys_menuCountOutputType without action
   */
  export type Sys_menuCountOutputTypeCountUser_bansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: sys_user_ban_menuWhereInput
  }


  /**
   * Count Type Sys_roleCountOutputType
   */

  export type Sys_roleCountOutputType = {
    menus: number
    users: number
  }

  export type Sys_roleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    menus?: boolean | Sys_roleCountOutputTypeCountMenusArgs
    users?: boolean | Sys_roleCountOutputTypeCountUsersArgs
  }

  // Custom InputTypes
  /**
   * Sys_roleCountOutputType without action
   */
  export type Sys_roleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sys_roleCountOutputType
     */
    select?: Sys_roleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Sys_roleCountOutputType without action
   */
  export type Sys_roleCountOutputTypeCountMenusArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: sys_menu_on_roleWhereInput
  }

  /**
   * Sys_roleCountOutputType without action
   */
  export type Sys_roleCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: sys_userWhereInput
  }


  /**
   * Count Type Blog_userCountOutputType
   */

  export type Blog_userCountOutputType = {
    posts: number
  }

  export type Blog_userCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    posts?: boolean | Blog_userCountOutputTypeCountPostsArgs
  }

  // Custom InputTypes
  /**
   * Blog_userCountOutputType without action
   */
  export type Blog_userCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blog_userCountOutputType
     */
    select?: Blog_userCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Blog_userCountOutputType without action
   */
  export type Blog_userCountOutputTypeCountPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: blog_postsWhereInput
  }


  /**
   * Count Type Blog_categoriesCountOutputType
   */

  export type Blog_categoriesCountOutputType = {
    posts: number
  }

  export type Blog_categoriesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    posts?: boolean | Blog_categoriesCountOutputTypeCountPostsArgs
  }

  // Custom InputTypes
  /**
   * Blog_categoriesCountOutputType without action
   */
  export type Blog_categoriesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blog_categoriesCountOutputType
     */
    select?: Blog_categoriesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Blog_categoriesCountOutputType without action
   */
  export type Blog_categoriesCountOutputTypeCountPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: blog_postsWhereInput
  }


  /**
   * Count Type Blog_postsCountOutputType
   */

  export type Blog_postsCountOutputType = {
    tags: number
  }

  export type Blog_postsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tags?: boolean | Blog_postsCountOutputTypeCountTagsArgs
  }

  // Custom InputTypes
  /**
   * Blog_postsCountOutputType without action
   */
  export type Blog_postsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blog_postsCountOutputType
     */
    select?: Blog_postsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Blog_postsCountOutputType without action
   */
  export type Blog_postsCountOutputTypeCountTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: blog_posts_on_tagsWhereInput
  }


  /**
   * Count Type Blog_tagCountOutputType
   */

  export type Blog_tagCountOutputType = {
    blog_posts_on_tags: number
  }

  export type Blog_tagCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    blog_posts_on_tags?: boolean | Blog_tagCountOutputTypeCountBlog_posts_on_tagsArgs
  }

  // Custom InputTypes
  /**
   * Blog_tagCountOutputType without action
   */
  export type Blog_tagCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blog_tagCountOutputType
     */
    select?: Blog_tagCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Blog_tagCountOutputType without action
   */
  export type Blog_tagCountOutputTypeCountBlog_posts_on_tagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: blog_posts_on_tagsWhereInput
  }


  /**
   * Count Type File_userCountOutputType
   */

  export type File_userCountOutputType = {
    medias: number
    folders: number
    keys: number
  }

  export type File_userCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    medias?: boolean | File_userCountOutputTypeCountMediasArgs
    folders?: boolean | File_userCountOutputTypeCountFoldersArgs
    keys?: boolean | File_userCountOutputTypeCountKeysArgs
  }

  // Custom InputTypes
  /**
   * File_userCountOutputType without action
   */
  export type File_userCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File_userCountOutputType
     */
    select?: File_userCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * File_userCountOutputType without action
   */
  export type File_userCountOutputTypeCountMediasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: file_user_on_mediaWhereInput
  }

  /**
   * File_userCountOutputType without action
   */
  export type File_userCountOutputTypeCountFoldersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: file_folderWhereInput
  }

  /**
   * File_userCountOutputType without action
   */
  export type File_userCountOutputTypeCountKeysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: file_keysWhereInput
  }


  /**
   * Count Type File_mediaCountOutputType
   */

  export type File_mediaCountOutputType = {
    blocks: number
    users: number
    folders: number
  }

  export type File_mediaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    blocks?: boolean | File_mediaCountOutputTypeCountBlocksArgs
    users?: boolean | File_mediaCountOutputTypeCountUsersArgs
    folders?: boolean | File_mediaCountOutputTypeCountFoldersArgs
  }

  // Custom InputTypes
  /**
   * File_mediaCountOutputType without action
   */
  export type File_mediaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File_mediaCountOutputType
     */
    select?: File_mediaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * File_mediaCountOutputType without action
   */
  export type File_mediaCountOutputTypeCountBlocksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: file_blockWhereInput
  }

  /**
   * File_mediaCountOutputType without action
   */
  export type File_mediaCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: file_user_on_mediaWhereInput
  }

  /**
   * File_mediaCountOutputType without action
   */
  export type File_mediaCountOutputTypeCountFoldersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: file_media_on_folderWhereInput
  }


  /**
   * Count Type File_folderCountOutputType
   */

  export type File_folderCountOutputType = {
    children: number
    medias: number
  }

  export type File_folderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    children?: boolean | File_folderCountOutputTypeCountChildrenArgs
    medias?: boolean | File_folderCountOutputTypeCountMediasArgs
  }

  // Custom InputTypes
  /**
   * File_folderCountOutputType without action
   */
  export type File_folderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File_folderCountOutputType
     */
    select?: File_folderCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * File_folderCountOutputType without action
   */
  export type File_folderCountOutputTypeCountChildrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: file_folderWhereInput
  }

  /**
   * File_folderCountOutputType without action
   */
  export type File_folderCountOutputTypeCountMediasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: file_media_on_folderWhereInput
  }


  /**
   * Count Type Book_userCountOutputType
   */

  export type Book_userCountOutputType = {
    borrowed: number
    book_borrow_history: number
    book_rating: number
  }

  export type Book_userCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    borrowed?: boolean | Book_userCountOutputTypeCountBorrowedArgs
    book_borrow_history?: boolean | Book_userCountOutputTypeCountBook_borrow_historyArgs
    book_rating?: boolean | Book_userCountOutputTypeCountBook_ratingArgs
  }

  // Custom InputTypes
  /**
   * Book_userCountOutputType without action
   */
  export type Book_userCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Book_userCountOutputType
     */
    select?: Book_userCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Book_userCountOutputType without action
   */
  export type Book_userCountOutputTypeCountBorrowedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: book_borrowedWhereInput
  }

  /**
   * Book_userCountOutputType without action
   */
  export type Book_userCountOutputTypeCountBook_borrow_historyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: book_borrow_historyWhereInput
  }

  /**
   * Book_userCountOutputType without action
   */
  export type Book_userCountOutputTypeCountBook_ratingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: book_ratingWhereInput
  }


  /**
   * Count Type Book_bookCountOutputType
   */

  export type Book_bookCountOutputType = {
    borrowed: number
    book_borrow_history: number
    book_rating: number
  }

  export type Book_bookCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    borrowed?: boolean | Book_bookCountOutputTypeCountBorrowedArgs
    book_borrow_history?: boolean | Book_bookCountOutputTypeCountBook_borrow_historyArgs
    book_rating?: boolean | Book_bookCountOutputTypeCountBook_ratingArgs
  }

  // Custom InputTypes
  /**
   * Book_bookCountOutputType without action
   */
  export type Book_bookCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Book_bookCountOutputType
     */
    select?: Book_bookCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Book_bookCountOutputType without action
   */
  export type Book_bookCountOutputTypeCountBorrowedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: book_borrowedWhereInput
  }

  /**
   * Book_bookCountOutputType without action
   */
  export type Book_bookCountOutputTypeCountBook_borrow_historyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: book_borrow_historyWhereInput
  }

  /**
   * Book_bookCountOutputType without action
   */
  export type Book_bookCountOutputTypeCountBook_ratingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: book_ratingWhereInput
  }


  /**
   * Count Type Book_categoryCountOutputType
   */

  export type Book_categoryCountOutputType = {
    books: number
  }

  export type Book_categoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    books?: boolean | Book_categoryCountOutputTypeCountBooksArgs
  }

  // Custom InputTypes
  /**
   * Book_categoryCountOutputType without action
   */
  export type Book_categoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Book_categoryCountOutputType
     */
    select?: Book_categoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Book_categoryCountOutputType without action
   */
  export type Book_categoryCountOutputTypeCountBooksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: book_bookWhereInput
  }


  /**
   * Count Type Study_userCountOutputType
   */

  export type Study_userCountOutputType = {
    reservation: number
    message: number
  }

  export type Study_userCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reservation?: boolean | Study_userCountOutputTypeCountReservationArgs
    message?: boolean | Study_userCountOutputTypeCountMessageArgs
  }

  // Custom InputTypes
  /**
   * Study_userCountOutputType without action
   */
  export type Study_userCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Study_userCountOutputType
     */
    select?: Study_userCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Study_userCountOutputType without action
   */
  export type Study_userCountOutputTypeCountReservationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: study_reservationWhereInput
  }

  /**
   * Study_userCountOutputType without action
   */
  export type Study_userCountOutputTypeCountMessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: study_messageWhereInput
  }


  /**
   * Count Type Study_storeCountOutputType
   */

  export type Study_storeCountOutputType = {
    floors: number
  }

  export type Study_storeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    floors?: boolean | Study_storeCountOutputTypeCountFloorsArgs
  }

  // Custom InputTypes
  /**
   * Study_storeCountOutputType without action
   */
  export type Study_storeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Study_storeCountOutputType
     */
    select?: Study_storeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Study_storeCountOutputType without action
   */
  export type Study_storeCountOutputTypeCountFloorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: study_floorWhereInput
  }


  /**
   * Count Type Study_floorCountOutputType
   */

  export type Study_floorCountOutputType = {
    studyRooms: number
  }

  export type Study_floorCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    studyRooms?: boolean | Study_floorCountOutputTypeCountStudyRoomsArgs
  }

  // Custom InputTypes
  /**
   * Study_floorCountOutputType without action
   */
  export type Study_floorCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Study_floorCountOutputType
     */
    select?: Study_floorCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Study_floorCountOutputType without action
   */
  export type Study_floorCountOutputTypeCountStudyRoomsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: study_roomWhereInput
  }


  /**
   * Count Type Study_roomCountOutputType
   */

  export type Study_roomCountOutputType = {
    seats: number
  }

  export type Study_roomCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    seats?: boolean | Study_roomCountOutputTypeCountSeatsArgs
  }

  // Custom InputTypes
  /**
   * Study_roomCountOutputType without action
   */
  export type Study_roomCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Study_roomCountOutputType
     */
    select?: Study_roomCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Study_roomCountOutputType without action
   */
  export type Study_roomCountOutputTypeCountSeatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: study_seatWhereInput
  }


  /**
   * Count Type Study_seatCountOutputType
   */

  export type Study_seatCountOutputType = {
    reservations: number
  }

  export type Study_seatCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reservations?: boolean | Study_seatCountOutputTypeCountReservationsArgs
  }

  // Custom InputTypes
  /**
   * Study_seatCountOutputType without action
   */
  export type Study_seatCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Study_seatCountOutputType
     */
    select?: Study_seatCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Study_seatCountOutputType without action
   */
  export type Study_seatCountOutputTypeCountReservationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: study_reservationWhereInput
  }


  /**
   * Models
   */

  /**
   * Model sys_user
   */

  export type AggregateSys_user = {
    _count: Sys_userCountAggregateOutputType | null
    _min: Sys_userMinAggregateOutputType | null
    _max: Sys_userMaxAggregateOutputType | null
  }

  export type Sys_userMinAggregateOutputType = {
    uid: string | null
    createAt: Date | null
    updateAt: Date | null
    name: string | null
    password: string | null
    salt: string | null
    roleId: string | null
  }

  export type Sys_userMaxAggregateOutputType = {
    uid: string | null
    createAt: Date | null
    updateAt: Date | null
    name: string | null
    password: string | null
    salt: string | null
    roleId: string | null
  }

  export type Sys_userCountAggregateOutputType = {
    uid: number
    createAt: number
    updateAt: number
    name: number
    password: number
    salt: number
    roleId: number
    _all: number
  }


  export type Sys_userMinAggregateInputType = {
    uid?: true
    createAt?: true
    updateAt?: true
    name?: true
    password?: true
    salt?: true
    roleId?: true
  }

  export type Sys_userMaxAggregateInputType = {
    uid?: true
    createAt?: true
    updateAt?: true
    name?: true
    password?: true
    salt?: true
    roleId?: true
  }

  export type Sys_userCountAggregateInputType = {
    uid?: true
    createAt?: true
    updateAt?: true
    name?: true
    password?: true
    salt?: true
    roleId?: true
    _all?: true
  }

  export type Sys_userAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which sys_user to aggregate.
     */
    where?: sys_userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sys_users to fetch.
     */
    orderBy?: sys_userOrderByWithRelationInput | sys_userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: sys_userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sys_users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sys_users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned sys_users
    **/
    _count?: true | Sys_userCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Sys_userMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Sys_userMaxAggregateInputType
  }

  export type GetSys_userAggregateType<T extends Sys_userAggregateArgs> = {
        [P in keyof T & keyof AggregateSys_user]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSys_user[P]>
      : GetScalarType<T[P], AggregateSys_user[P]>
  }




  export type sys_userGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: sys_userWhereInput
    orderBy?: sys_userOrderByWithAggregationInput | sys_userOrderByWithAggregationInput[]
    by: Sys_userScalarFieldEnum[] | Sys_userScalarFieldEnum
    having?: sys_userScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Sys_userCountAggregateInputType | true
    _min?: Sys_userMinAggregateInputType
    _max?: Sys_userMaxAggregateInputType
  }

  export type Sys_userGroupByOutputType = {
    uid: string
    createAt: Date
    updateAt: Date
    name: string
    password: string
    salt: string
    roleId: string | null
    _count: Sys_userCountAggregateOutputType | null
    _min: Sys_userMinAggregateOutputType | null
    _max: Sys_userMaxAggregateOutputType | null
  }

  type GetSys_userGroupByPayload<T extends sys_userGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Sys_userGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Sys_userGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Sys_userGroupByOutputType[P]>
            : GetScalarType<T[P], Sys_userGroupByOutputType[P]>
        }
      >
    >


  export type sys_userSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    uid?: boolean
    createAt?: boolean
    updateAt?: boolean
    name?: boolean
    password?: boolean
    salt?: boolean
    roleId?: boolean
    accounts?: boolean | sys_user$accountsArgs<ExtArgs>
    role?: boolean | sys_user$roleArgs<ExtArgs>
    ban_menus?: boolean | sys_user$ban_menusArgs<ExtArgs>
    _count?: boolean | Sys_userCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sys_user"]>



  export type sys_userSelectScalar = {
    uid?: boolean
    createAt?: boolean
    updateAt?: boolean
    name?: boolean
    password?: boolean
    salt?: boolean
    roleId?: boolean
  }

  export type sys_userOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"uid" | "createAt" | "updateAt" | "name" | "password" | "salt" | "roleId", ExtArgs["result"]["sys_user"]>
  export type sys_userInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accounts?: boolean | sys_user$accountsArgs<ExtArgs>
    role?: boolean | sys_user$roleArgs<ExtArgs>
    ban_menus?: boolean | sys_user$ban_menusArgs<ExtArgs>
    _count?: boolean | Sys_userCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $sys_userPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "sys_user"
    objects: {
      accounts: Prisma.$sys_accountPayload<ExtArgs>[]
      role: Prisma.$sys_rolePayload<ExtArgs> | null
      ban_menus: Prisma.$sys_user_ban_menuPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      uid: string
      createAt: Date
      updateAt: Date
      name: string
      password: string
      salt: string
      roleId: string | null
    }, ExtArgs["result"]["sys_user"]>
    composites: {}
  }

  type sys_userGetPayload<S extends boolean | null | undefined | sys_userDefaultArgs> = $Result.GetResult<Prisma.$sys_userPayload, S>

  type sys_userCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<sys_userFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Sys_userCountAggregateInputType | true
    }

  export interface sys_userDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['sys_user'], meta: { name: 'sys_user' } }
    /**
     * Find zero or one Sys_user that matches the filter.
     * @param {sys_userFindUniqueArgs} args - Arguments to find a Sys_user
     * @example
     * // Get one Sys_user
     * const sys_user = await prisma.sys_user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends sys_userFindUniqueArgs>(args: SelectSubset<T, sys_userFindUniqueArgs<ExtArgs>>): Prisma__sys_userClient<$Result.GetResult<Prisma.$sys_userPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Sys_user that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {sys_userFindUniqueOrThrowArgs} args - Arguments to find a Sys_user
     * @example
     * // Get one Sys_user
     * const sys_user = await prisma.sys_user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends sys_userFindUniqueOrThrowArgs>(args: SelectSubset<T, sys_userFindUniqueOrThrowArgs<ExtArgs>>): Prisma__sys_userClient<$Result.GetResult<Prisma.$sys_userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sys_user that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sys_userFindFirstArgs} args - Arguments to find a Sys_user
     * @example
     * // Get one Sys_user
     * const sys_user = await prisma.sys_user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends sys_userFindFirstArgs>(args?: SelectSubset<T, sys_userFindFirstArgs<ExtArgs>>): Prisma__sys_userClient<$Result.GetResult<Prisma.$sys_userPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sys_user that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sys_userFindFirstOrThrowArgs} args - Arguments to find a Sys_user
     * @example
     * // Get one Sys_user
     * const sys_user = await prisma.sys_user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends sys_userFindFirstOrThrowArgs>(args?: SelectSubset<T, sys_userFindFirstOrThrowArgs<ExtArgs>>): Prisma__sys_userClient<$Result.GetResult<Prisma.$sys_userPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sys_users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sys_userFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sys_users
     * const sys_users = await prisma.sys_user.findMany()
     * 
     * // Get first 10 Sys_users
     * const sys_users = await prisma.sys_user.findMany({ take: 10 })
     * 
     * // Only select the `uid`
     * const sys_userWithUidOnly = await prisma.sys_user.findMany({ select: { uid: true } })
     * 
     */
    findMany<T extends sys_userFindManyArgs>(args?: SelectSubset<T, sys_userFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sys_userPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Sys_user.
     * @param {sys_userCreateArgs} args - Arguments to create a Sys_user.
     * @example
     * // Create one Sys_user
     * const Sys_user = await prisma.sys_user.create({
     *   data: {
     *     // ... data to create a Sys_user
     *   }
     * })
     * 
     */
    create<T extends sys_userCreateArgs>(args: SelectSubset<T, sys_userCreateArgs<ExtArgs>>): Prisma__sys_userClient<$Result.GetResult<Prisma.$sys_userPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sys_users.
     * @param {sys_userCreateManyArgs} args - Arguments to create many Sys_users.
     * @example
     * // Create many Sys_users
     * const sys_user = await prisma.sys_user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends sys_userCreateManyArgs>(args?: SelectSubset<T, sys_userCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Sys_user.
     * @param {sys_userDeleteArgs} args - Arguments to delete one Sys_user.
     * @example
     * // Delete one Sys_user
     * const Sys_user = await prisma.sys_user.delete({
     *   where: {
     *     // ... filter to delete one Sys_user
     *   }
     * })
     * 
     */
    delete<T extends sys_userDeleteArgs>(args: SelectSubset<T, sys_userDeleteArgs<ExtArgs>>): Prisma__sys_userClient<$Result.GetResult<Prisma.$sys_userPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Sys_user.
     * @param {sys_userUpdateArgs} args - Arguments to update one Sys_user.
     * @example
     * // Update one Sys_user
     * const sys_user = await prisma.sys_user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends sys_userUpdateArgs>(args: SelectSubset<T, sys_userUpdateArgs<ExtArgs>>): Prisma__sys_userClient<$Result.GetResult<Prisma.$sys_userPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sys_users.
     * @param {sys_userDeleteManyArgs} args - Arguments to filter Sys_users to delete.
     * @example
     * // Delete a few Sys_users
     * const { count } = await prisma.sys_user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends sys_userDeleteManyArgs>(args?: SelectSubset<T, sys_userDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sys_users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sys_userUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sys_users
     * const sys_user = await prisma.sys_user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends sys_userUpdateManyArgs>(args: SelectSubset<T, sys_userUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Sys_user.
     * @param {sys_userUpsertArgs} args - Arguments to update or create a Sys_user.
     * @example
     * // Update or create a Sys_user
     * const sys_user = await prisma.sys_user.upsert({
     *   create: {
     *     // ... data to create a Sys_user
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Sys_user we want to update
     *   }
     * })
     */
    upsert<T extends sys_userUpsertArgs>(args: SelectSubset<T, sys_userUpsertArgs<ExtArgs>>): Prisma__sys_userClient<$Result.GetResult<Prisma.$sys_userPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sys_users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sys_userCountArgs} args - Arguments to filter Sys_users to count.
     * @example
     * // Count the number of Sys_users
     * const count = await prisma.sys_user.count({
     *   where: {
     *     // ... the filter for the Sys_users we want to count
     *   }
     * })
    **/
    count<T extends sys_userCountArgs>(
      args?: Subset<T, sys_userCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Sys_userCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Sys_user.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Sys_userAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Sys_userAggregateArgs>(args: Subset<T, Sys_userAggregateArgs>): Prisma.PrismaPromise<GetSys_userAggregateType<T>>

    /**
     * Group by Sys_user.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sys_userGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends sys_userGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: sys_userGroupByArgs['orderBy'] }
        : { orderBy?: sys_userGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, sys_userGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSys_userGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the sys_user model
   */
  readonly fields: sys_userFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for sys_user.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__sys_userClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    accounts<T extends sys_user$accountsArgs<ExtArgs> = {}>(args?: Subset<T, sys_user$accountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sys_accountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    role<T extends sys_user$roleArgs<ExtArgs> = {}>(args?: Subset<T, sys_user$roleArgs<ExtArgs>>): Prisma__sys_roleClient<$Result.GetResult<Prisma.$sys_rolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    ban_menus<T extends sys_user$ban_menusArgs<ExtArgs> = {}>(args?: Subset<T, sys_user$ban_menusArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sys_user_ban_menuPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the sys_user model
   */
  interface sys_userFieldRefs {
    readonly uid: FieldRef<"sys_user", 'String'>
    readonly createAt: FieldRef<"sys_user", 'DateTime'>
    readonly updateAt: FieldRef<"sys_user", 'DateTime'>
    readonly name: FieldRef<"sys_user", 'String'>
    readonly password: FieldRef<"sys_user", 'String'>
    readonly salt: FieldRef<"sys_user", 'String'>
    readonly roleId: FieldRef<"sys_user", 'String'>
  }
    

  // Custom InputTypes
  /**
   * sys_user findUnique
   */
  export type sys_userFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sys_user
     */
    select?: sys_userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sys_user
     */
    omit?: sys_userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sys_userInclude<ExtArgs> | null
    /**
     * Filter, which sys_user to fetch.
     */
    where: sys_userWhereUniqueInput
  }

  /**
   * sys_user findUniqueOrThrow
   */
  export type sys_userFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sys_user
     */
    select?: sys_userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sys_user
     */
    omit?: sys_userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sys_userInclude<ExtArgs> | null
    /**
     * Filter, which sys_user to fetch.
     */
    where: sys_userWhereUniqueInput
  }

  /**
   * sys_user findFirst
   */
  export type sys_userFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sys_user
     */
    select?: sys_userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sys_user
     */
    omit?: sys_userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sys_userInclude<ExtArgs> | null
    /**
     * Filter, which sys_user to fetch.
     */
    where?: sys_userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sys_users to fetch.
     */
    orderBy?: sys_userOrderByWithRelationInput | sys_userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sys_users.
     */
    cursor?: sys_userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sys_users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sys_users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sys_users.
     */
    distinct?: Sys_userScalarFieldEnum | Sys_userScalarFieldEnum[]
  }

  /**
   * sys_user findFirstOrThrow
   */
  export type sys_userFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sys_user
     */
    select?: sys_userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sys_user
     */
    omit?: sys_userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sys_userInclude<ExtArgs> | null
    /**
     * Filter, which sys_user to fetch.
     */
    where?: sys_userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sys_users to fetch.
     */
    orderBy?: sys_userOrderByWithRelationInput | sys_userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sys_users.
     */
    cursor?: sys_userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sys_users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sys_users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sys_users.
     */
    distinct?: Sys_userScalarFieldEnum | Sys_userScalarFieldEnum[]
  }

  /**
   * sys_user findMany
   */
  export type sys_userFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sys_user
     */
    select?: sys_userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sys_user
     */
    omit?: sys_userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sys_userInclude<ExtArgs> | null
    /**
     * Filter, which sys_users to fetch.
     */
    where?: sys_userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sys_users to fetch.
     */
    orderBy?: sys_userOrderByWithRelationInput | sys_userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing sys_users.
     */
    cursor?: sys_userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sys_users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sys_users.
     */
    skip?: number
    distinct?: Sys_userScalarFieldEnum | Sys_userScalarFieldEnum[]
  }

  /**
   * sys_user create
   */
  export type sys_userCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sys_user
     */
    select?: sys_userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sys_user
     */
    omit?: sys_userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sys_userInclude<ExtArgs> | null
    /**
     * The data needed to create a sys_user.
     */
    data: XOR<sys_userCreateInput, sys_userUncheckedCreateInput>
  }

  /**
   * sys_user createMany
   */
  export type sys_userCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many sys_users.
     */
    data: sys_userCreateManyInput | sys_userCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * sys_user update
   */
  export type sys_userUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sys_user
     */
    select?: sys_userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sys_user
     */
    omit?: sys_userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sys_userInclude<ExtArgs> | null
    /**
     * The data needed to update a sys_user.
     */
    data: XOR<sys_userUpdateInput, sys_userUncheckedUpdateInput>
    /**
     * Choose, which sys_user to update.
     */
    where: sys_userWhereUniqueInput
  }

  /**
   * sys_user updateMany
   */
  export type sys_userUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update sys_users.
     */
    data: XOR<sys_userUpdateManyMutationInput, sys_userUncheckedUpdateManyInput>
    /**
     * Filter which sys_users to update
     */
    where?: sys_userWhereInput
    /**
     * Limit how many sys_users to update.
     */
    limit?: number
  }

  /**
   * sys_user upsert
   */
  export type sys_userUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sys_user
     */
    select?: sys_userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sys_user
     */
    omit?: sys_userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sys_userInclude<ExtArgs> | null
    /**
     * The filter to search for the sys_user to update in case it exists.
     */
    where: sys_userWhereUniqueInput
    /**
     * In case the sys_user found by the `where` argument doesn't exist, create a new sys_user with this data.
     */
    create: XOR<sys_userCreateInput, sys_userUncheckedCreateInput>
    /**
     * In case the sys_user was found with the provided `where` argument, update it with this data.
     */
    update: XOR<sys_userUpdateInput, sys_userUncheckedUpdateInput>
  }

  /**
   * sys_user delete
   */
  export type sys_userDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sys_user
     */
    select?: sys_userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sys_user
     */
    omit?: sys_userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sys_userInclude<ExtArgs> | null
    /**
     * Filter which sys_user to delete.
     */
    where: sys_userWhereUniqueInput
  }

  /**
   * sys_user deleteMany
   */
  export type sys_userDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which sys_users to delete
     */
    where?: sys_userWhereInput
    /**
     * Limit how many sys_users to delete.
     */
    limit?: number
  }

  /**
   * sys_user.accounts
   */
  export type sys_user$accountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sys_account
     */
    select?: sys_accountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sys_account
     */
    omit?: sys_accountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sys_accountInclude<ExtArgs> | null
    where?: sys_accountWhereInput
    orderBy?: sys_accountOrderByWithRelationInput | sys_accountOrderByWithRelationInput[]
    cursor?: sys_accountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Sys_accountScalarFieldEnum | Sys_accountScalarFieldEnum[]
  }

  /**
   * sys_user.role
   */
  export type sys_user$roleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sys_role
     */
    select?: sys_roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sys_role
     */
    omit?: sys_roleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sys_roleInclude<ExtArgs> | null
    where?: sys_roleWhereInput
  }

  /**
   * sys_user.ban_menus
   */
  export type sys_user$ban_menusArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sys_user_ban_menu
     */
    select?: sys_user_ban_menuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sys_user_ban_menu
     */
    omit?: sys_user_ban_menuOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sys_user_ban_menuInclude<ExtArgs> | null
    where?: sys_user_ban_menuWhereInput
    orderBy?: sys_user_ban_menuOrderByWithRelationInput | sys_user_ban_menuOrderByWithRelationInput[]
    cursor?: sys_user_ban_menuWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Sys_user_ban_menuScalarFieldEnum | Sys_user_ban_menuScalarFieldEnum[]
  }

  /**
   * sys_user without action
   */
  export type sys_userDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sys_user
     */
    select?: sys_userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sys_user
     */
    omit?: sys_userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sys_userInclude<ExtArgs> | null
  }


  /**
   * Model sys_account
   */

  export type AggregateSys_account = {
    _count: Sys_accountCountAggregateOutputType | null
    _min: Sys_accountMinAggregateOutputType | null
    _max: Sys_accountMaxAggregateOutputType | null
  }

  export type Sys_accountMinAggregateOutputType = {
    createAt: Date | null
    updateAt: Date | null
    provider: $Enums.sys_account_provider | null
    provider_id: string | null
    userId: string | null
  }

  export type Sys_accountMaxAggregateOutputType = {
    createAt: Date | null
    updateAt: Date | null
    provider: $Enums.sys_account_provider | null
    provider_id: string | null
    userId: string | null
  }

  export type Sys_accountCountAggregateOutputType = {
    createAt: number
    updateAt: number
    provider: number
    provider_id: number
    userId: number
    _all: number
  }


  export type Sys_accountMinAggregateInputType = {
    createAt?: true
    updateAt?: true
    provider?: true
    provider_id?: true
    userId?: true
  }

  export type Sys_accountMaxAggregateInputType = {
    createAt?: true
    updateAt?: true
    provider?: true
    provider_id?: true
    userId?: true
  }

  export type Sys_accountCountAggregateInputType = {
    createAt?: true
    updateAt?: true
    provider?: true
    provider_id?: true
    userId?: true
    _all?: true
  }

  export type Sys_accountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which sys_account to aggregate.
     */
    where?: sys_accountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sys_accounts to fetch.
     */
    orderBy?: sys_accountOrderByWithRelationInput | sys_accountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: sys_accountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sys_accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sys_accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned sys_accounts
    **/
    _count?: true | Sys_accountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Sys_accountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Sys_accountMaxAggregateInputType
  }

  export type GetSys_accountAggregateType<T extends Sys_accountAggregateArgs> = {
        [P in keyof T & keyof AggregateSys_account]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSys_account[P]>
      : GetScalarType<T[P], AggregateSys_account[P]>
  }




  export type sys_accountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: sys_accountWhereInput
    orderBy?: sys_accountOrderByWithAggregationInput | sys_accountOrderByWithAggregationInput[]
    by: Sys_accountScalarFieldEnum[] | Sys_accountScalarFieldEnum
    having?: sys_accountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Sys_accountCountAggregateInputType | true
    _min?: Sys_accountMinAggregateInputType
    _max?: Sys_accountMaxAggregateInputType
  }

  export type Sys_accountGroupByOutputType = {
    createAt: Date
    updateAt: Date
    provider: $Enums.sys_account_provider
    provider_id: string
    userId: string | null
    _count: Sys_accountCountAggregateOutputType | null
    _min: Sys_accountMinAggregateOutputType | null
    _max: Sys_accountMaxAggregateOutputType | null
  }

  type GetSys_accountGroupByPayload<T extends sys_accountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Sys_accountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Sys_accountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Sys_accountGroupByOutputType[P]>
            : GetScalarType<T[P], Sys_accountGroupByOutputType[P]>
        }
      >
    >


  export type sys_accountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    createAt?: boolean
    updateAt?: boolean
    provider?: boolean
    provider_id?: boolean
    userId?: boolean
    user?: boolean | sys_account$userArgs<ExtArgs>
  }, ExtArgs["result"]["sys_account"]>



  export type sys_accountSelectScalar = {
    createAt?: boolean
    updateAt?: boolean
    provider?: boolean
    provider_id?: boolean
    userId?: boolean
  }

  export type sys_accountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"createAt" | "updateAt" | "provider" | "provider_id" | "userId", ExtArgs["result"]["sys_account"]>
  export type sys_accountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | sys_account$userArgs<ExtArgs>
  }

  export type $sys_accountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "sys_account"
    objects: {
      user: Prisma.$sys_userPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      createAt: Date
      updateAt: Date
      provider: $Enums.sys_account_provider
      provider_id: string
      userId: string | null
    }, ExtArgs["result"]["sys_account"]>
    composites: {}
  }

  type sys_accountGetPayload<S extends boolean | null | undefined | sys_accountDefaultArgs> = $Result.GetResult<Prisma.$sys_accountPayload, S>

  type sys_accountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<sys_accountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Sys_accountCountAggregateInputType | true
    }

  export interface sys_accountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['sys_account'], meta: { name: 'sys_account' } }
    /**
     * Find zero or one Sys_account that matches the filter.
     * @param {sys_accountFindUniqueArgs} args - Arguments to find a Sys_account
     * @example
     * // Get one Sys_account
     * const sys_account = await prisma.sys_account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends sys_accountFindUniqueArgs>(args: SelectSubset<T, sys_accountFindUniqueArgs<ExtArgs>>): Prisma__sys_accountClient<$Result.GetResult<Prisma.$sys_accountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Sys_account that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {sys_accountFindUniqueOrThrowArgs} args - Arguments to find a Sys_account
     * @example
     * // Get one Sys_account
     * const sys_account = await prisma.sys_account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends sys_accountFindUniqueOrThrowArgs>(args: SelectSubset<T, sys_accountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__sys_accountClient<$Result.GetResult<Prisma.$sys_accountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sys_account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sys_accountFindFirstArgs} args - Arguments to find a Sys_account
     * @example
     * // Get one Sys_account
     * const sys_account = await prisma.sys_account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends sys_accountFindFirstArgs>(args?: SelectSubset<T, sys_accountFindFirstArgs<ExtArgs>>): Prisma__sys_accountClient<$Result.GetResult<Prisma.$sys_accountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sys_account that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sys_accountFindFirstOrThrowArgs} args - Arguments to find a Sys_account
     * @example
     * // Get one Sys_account
     * const sys_account = await prisma.sys_account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends sys_accountFindFirstOrThrowArgs>(args?: SelectSubset<T, sys_accountFindFirstOrThrowArgs<ExtArgs>>): Prisma__sys_accountClient<$Result.GetResult<Prisma.$sys_accountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sys_accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sys_accountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sys_accounts
     * const sys_accounts = await prisma.sys_account.findMany()
     * 
     * // Get first 10 Sys_accounts
     * const sys_accounts = await prisma.sys_account.findMany({ take: 10 })
     * 
     * // Only select the `createAt`
     * const sys_accountWithCreateAtOnly = await prisma.sys_account.findMany({ select: { createAt: true } })
     * 
     */
    findMany<T extends sys_accountFindManyArgs>(args?: SelectSubset<T, sys_accountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sys_accountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Sys_account.
     * @param {sys_accountCreateArgs} args - Arguments to create a Sys_account.
     * @example
     * // Create one Sys_account
     * const Sys_account = await prisma.sys_account.create({
     *   data: {
     *     // ... data to create a Sys_account
     *   }
     * })
     * 
     */
    create<T extends sys_accountCreateArgs>(args: SelectSubset<T, sys_accountCreateArgs<ExtArgs>>): Prisma__sys_accountClient<$Result.GetResult<Prisma.$sys_accountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sys_accounts.
     * @param {sys_accountCreateManyArgs} args - Arguments to create many Sys_accounts.
     * @example
     * // Create many Sys_accounts
     * const sys_account = await prisma.sys_account.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends sys_accountCreateManyArgs>(args?: SelectSubset<T, sys_accountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Sys_account.
     * @param {sys_accountDeleteArgs} args - Arguments to delete one Sys_account.
     * @example
     * // Delete one Sys_account
     * const Sys_account = await prisma.sys_account.delete({
     *   where: {
     *     // ... filter to delete one Sys_account
     *   }
     * })
     * 
     */
    delete<T extends sys_accountDeleteArgs>(args: SelectSubset<T, sys_accountDeleteArgs<ExtArgs>>): Prisma__sys_accountClient<$Result.GetResult<Prisma.$sys_accountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Sys_account.
     * @param {sys_accountUpdateArgs} args - Arguments to update one Sys_account.
     * @example
     * // Update one Sys_account
     * const sys_account = await prisma.sys_account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends sys_accountUpdateArgs>(args: SelectSubset<T, sys_accountUpdateArgs<ExtArgs>>): Prisma__sys_accountClient<$Result.GetResult<Prisma.$sys_accountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sys_accounts.
     * @param {sys_accountDeleteManyArgs} args - Arguments to filter Sys_accounts to delete.
     * @example
     * // Delete a few Sys_accounts
     * const { count } = await prisma.sys_account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends sys_accountDeleteManyArgs>(args?: SelectSubset<T, sys_accountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sys_accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sys_accountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sys_accounts
     * const sys_account = await prisma.sys_account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends sys_accountUpdateManyArgs>(args: SelectSubset<T, sys_accountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Sys_account.
     * @param {sys_accountUpsertArgs} args - Arguments to update or create a Sys_account.
     * @example
     * // Update or create a Sys_account
     * const sys_account = await prisma.sys_account.upsert({
     *   create: {
     *     // ... data to create a Sys_account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Sys_account we want to update
     *   }
     * })
     */
    upsert<T extends sys_accountUpsertArgs>(args: SelectSubset<T, sys_accountUpsertArgs<ExtArgs>>): Prisma__sys_accountClient<$Result.GetResult<Prisma.$sys_accountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sys_accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sys_accountCountArgs} args - Arguments to filter Sys_accounts to count.
     * @example
     * // Count the number of Sys_accounts
     * const count = await prisma.sys_account.count({
     *   where: {
     *     // ... the filter for the Sys_accounts we want to count
     *   }
     * })
    **/
    count<T extends sys_accountCountArgs>(
      args?: Subset<T, sys_accountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Sys_accountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Sys_account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Sys_accountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Sys_accountAggregateArgs>(args: Subset<T, Sys_accountAggregateArgs>): Prisma.PrismaPromise<GetSys_accountAggregateType<T>>

    /**
     * Group by Sys_account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sys_accountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends sys_accountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: sys_accountGroupByArgs['orderBy'] }
        : { orderBy?: sys_accountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, sys_accountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSys_accountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the sys_account model
   */
  readonly fields: sys_accountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for sys_account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__sys_accountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends sys_account$userArgs<ExtArgs> = {}>(args?: Subset<T, sys_account$userArgs<ExtArgs>>): Prisma__sys_userClient<$Result.GetResult<Prisma.$sys_userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the sys_account model
   */
  interface sys_accountFieldRefs {
    readonly createAt: FieldRef<"sys_account", 'DateTime'>
    readonly updateAt: FieldRef<"sys_account", 'DateTime'>
    readonly provider: FieldRef<"sys_account", 'sys_account_provider'>
    readonly provider_id: FieldRef<"sys_account", 'String'>
    readonly userId: FieldRef<"sys_account", 'String'>
  }
    

  // Custom InputTypes
  /**
   * sys_account findUnique
   */
  export type sys_accountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sys_account
     */
    select?: sys_accountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sys_account
     */
    omit?: sys_accountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sys_accountInclude<ExtArgs> | null
    /**
     * Filter, which sys_account to fetch.
     */
    where: sys_accountWhereUniqueInput
  }

  /**
   * sys_account findUniqueOrThrow
   */
  export type sys_accountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sys_account
     */
    select?: sys_accountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sys_account
     */
    omit?: sys_accountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sys_accountInclude<ExtArgs> | null
    /**
     * Filter, which sys_account to fetch.
     */
    where: sys_accountWhereUniqueInput
  }

  /**
   * sys_account findFirst
   */
  export type sys_accountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sys_account
     */
    select?: sys_accountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sys_account
     */
    omit?: sys_accountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sys_accountInclude<ExtArgs> | null
    /**
     * Filter, which sys_account to fetch.
     */
    where?: sys_accountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sys_accounts to fetch.
     */
    orderBy?: sys_accountOrderByWithRelationInput | sys_accountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sys_accounts.
     */
    cursor?: sys_accountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sys_accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sys_accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sys_accounts.
     */
    distinct?: Sys_accountScalarFieldEnum | Sys_accountScalarFieldEnum[]
  }

  /**
   * sys_account findFirstOrThrow
   */
  export type sys_accountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sys_account
     */
    select?: sys_accountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sys_account
     */
    omit?: sys_accountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sys_accountInclude<ExtArgs> | null
    /**
     * Filter, which sys_account to fetch.
     */
    where?: sys_accountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sys_accounts to fetch.
     */
    orderBy?: sys_accountOrderByWithRelationInput | sys_accountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sys_accounts.
     */
    cursor?: sys_accountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sys_accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sys_accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sys_accounts.
     */
    distinct?: Sys_accountScalarFieldEnum | Sys_accountScalarFieldEnum[]
  }

  /**
   * sys_account findMany
   */
  export type sys_accountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sys_account
     */
    select?: sys_accountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sys_account
     */
    omit?: sys_accountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sys_accountInclude<ExtArgs> | null
    /**
     * Filter, which sys_accounts to fetch.
     */
    where?: sys_accountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sys_accounts to fetch.
     */
    orderBy?: sys_accountOrderByWithRelationInput | sys_accountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing sys_accounts.
     */
    cursor?: sys_accountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sys_accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sys_accounts.
     */
    skip?: number
    distinct?: Sys_accountScalarFieldEnum | Sys_accountScalarFieldEnum[]
  }

  /**
   * sys_account create
   */
  export type sys_accountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sys_account
     */
    select?: sys_accountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sys_account
     */
    omit?: sys_accountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sys_accountInclude<ExtArgs> | null
    /**
     * The data needed to create a sys_account.
     */
    data: XOR<sys_accountCreateInput, sys_accountUncheckedCreateInput>
  }

  /**
   * sys_account createMany
   */
  export type sys_accountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many sys_accounts.
     */
    data: sys_accountCreateManyInput | sys_accountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * sys_account update
   */
  export type sys_accountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sys_account
     */
    select?: sys_accountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sys_account
     */
    omit?: sys_accountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sys_accountInclude<ExtArgs> | null
    /**
     * The data needed to update a sys_account.
     */
    data: XOR<sys_accountUpdateInput, sys_accountUncheckedUpdateInput>
    /**
     * Choose, which sys_account to update.
     */
    where: sys_accountWhereUniqueInput
  }

  /**
   * sys_account updateMany
   */
  export type sys_accountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update sys_accounts.
     */
    data: XOR<sys_accountUpdateManyMutationInput, sys_accountUncheckedUpdateManyInput>
    /**
     * Filter which sys_accounts to update
     */
    where?: sys_accountWhereInput
    /**
     * Limit how many sys_accounts to update.
     */
    limit?: number
  }

  /**
   * sys_account upsert
   */
  export type sys_accountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sys_account
     */
    select?: sys_accountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sys_account
     */
    omit?: sys_accountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sys_accountInclude<ExtArgs> | null
    /**
     * The filter to search for the sys_account to update in case it exists.
     */
    where: sys_accountWhereUniqueInput
    /**
     * In case the sys_account found by the `where` argument doesn't exist, create a new sys_account with this data.
     */
    create: XOR<sys_accountCreateInput, sys_accountUncheckedCreateInput>
    /**
     * In case the sys_account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<sys_accountUpdateInput, sys_accountUncheckedUpdateInput>
  }

  /**
   * sys_account delete
   */
  export type sys_accountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sys_account
     */
    select?: sys_accountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sys_account
     */
    omit?: sys_accountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sys_accountInclude<ExtArgs> | null
    /**
     * Filter which sys_account to delete.
     */
    where: sys_accountWhereUniqueInput
  }

  /**
   * sys_account deleteMany
   */
  export type sys_accountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which sys_accounts to delete
     */
    where?: sys_accountWhereInput
    /**
     * Limit how many sys_accounts to delete.
     */
    limit?: number
  }

  /**
   * sys_account.user
   */
  export type sys_account$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sys_user
     */
    select?: sys_userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sys_user
     */
    omit?: sys_userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sys_userInclude<ExtArgs> | null
    where?: sys_userWhereInput
  }

  /**
   * sys_account without action
   */
  export type sys_accountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sys_account
     */
    select?: sys_accountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sys_account
     */
    omit?: sys_accountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sys_accountInclude<ExtArgs> | null
  }


  /**
   * Model sys_menu
   */

  export type AggregateSys_menu = {
    _count: Sys_menuCountAggregateOutputType | null
    _avg: Sys_menuAvgAggregateOutputType | null
    _sum: Sys_menuSumAggregateOutputType | null
    _min: Sys_menuMinAggregateOutputType | null
    _max: Sys_menuMaxAggregateOutputType | null
  }

  export type Sys_menuAvgAggregateOutputType = {
    powers: number | null
  }

  export type Sys_menuSumAggregateOutputType = {
    powers: number | null
  }

  export type Sys_menuMinAggregateOutputType = {
    uid: string | null
    createAt: Date | null
    updateAt: Date | null
    name: string | null
    path: string | null
    powers: number | null
    comment: string | null
    parentId: string | null
  }

  export type Sys_menuMaxAggregateOutputType = {
    uid: string | null
    createAt: Date | null
    updateAt: Date | null
    name: string | null
    path: string | null
    powers: number | null
    comment: string | null
    parentId: string | null
  }

  export type Sys_menuCountAggregateOutputType = {
    uid: number
    createAt: number
    updateAt: number
    name: number
    path: number
    powers: number
    comment: number
    parentId: number
    _all: number
  }


  export type Sys_menuAvgAggregateInputType = {
    powers?: true
  }

  export type Sys_menuSumAggregateInputType = {
    powers?: true
  }

  export type Sys_menuMinAggregateInputType = {
    uid?: true
    createAt?: true
    updateAt?: true
    name?: true
    path?: true
    powers?: true
    comment?: true
    parentId?: true
  }

  export type Sys_menuMaxAggregateInputType = {
    uid?: true
    createAt?: true
    updateAt?: true
    name?: true
    path?: true
    powers?: true
    comment?: true
    parentId?: true
  }

  export type Sys_menuCountAggregateInputType = {
    uid?: true
    createAt?: true
    updateAt?: true
    name?: true
    path?: true
    powers?: true
    comment?: true
    parentId?: true
    _all?: true
  }

  export type Sys_menuAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which sys_menu to aggregate.
     */
    where?: sys_menuWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sys_menus to fetch.
     */
    orderBy?: sys_menuOrderByWithRelationInput | sys_menuOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: sys_menuWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sys_menus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sys_menus.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned sys_menus
    **/
    _count?: true | Sys_menuCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Sys_menuAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Sys_menuSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Sys_menuMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Sys_menuMaxAggregateInputType
  }

  export type GetSys_menuAggregateType<T extends Sys_menuAggregateArgs> = {
        [P in keyof T & keyof AggregateSys_menu]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSys_menu[P]>
      : GetScalarType<T[P], AggregateSys_menu[P]>
  }




  export type sys_menuGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: sys_menuWhereInput
    orderBy?: sys_menuOrderByWithAggregationInput | sys_menuOrderByWithAggregationInput[]
    by: Sys_menuScalarFieldEnum[] | Sys_menuScalarFieldEnum
    having?: sys_menuScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Sys_menuCountAggregateInputType | true
    _avg?: Sys_menuAvgAggregateInputType
    _sum?: Sys_menuSumAggregateInputType
    _min?: Sys_menuMinAggregateInputType
    _max?: Sys_menuMaxAggregateInputType
  }

  export type Sys_menuGroupByOutputType = {
    uid: string
    createAt: Date
    updateAt: Date
    name: string
    path: string
    powers: number
    comment: string | null
    parentId: string | null
    _count: Sys_menuCountAggregateOutputType | null
    _avg: Sys_menuAvgAggregateOutputType | null
    _sum: Sys_menuSumAggregateOutputType | null
    _min: Sys_menuMinAggregateOutputType | null
    _max: Sys_menuMaxAggregateOutputType | null
  }

  type GetSys_menuGroupByPayload<T extends sys_menuGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Sys_menuGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Sys_menuGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Sys_menuGroupByOutputType[P]>
            : GetScalarType<T[P], Sys_menuGroupByOutputType[P]>
        }
      >
    >


  export type sys_menuSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    uid?: boolean
    createAt?: boolean
    updateAt?: boolean
    name?: boolean
    path?: boolean
    powers?: boolean
    comment?: boolean
    parentId?: boolean
    parent?: boolean | sys_menu$parentArgs<ExtArgs>
    children?: boolean | sys_menu$childrenArgs<ExtArgs>
    roles?: boolean | sys_menu$rolesArgs<ExtArgs>
    user_bans?: boolean | sys_menu$user_bansArgs<ExtArgs>
    _count?: boolean | Sys_menuCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sys_menu"]>



  export type sys_menuSelectScalar = {
    uid?: boolean
    createAt?: boolean
    updateAt?: boolean
    name?: boolean
    path?: boolean
    powers?: boolean
    comment?: boolean
    parentId?: boolean
  }

  export type sys_menuOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"uid" | "createAt" | "updateAt" | "name" | "path" | "powers" | "comment" | "parentId", ExtArgs["result"]["sys_menu"]>
  export type sys_menuInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | sys_menu$parentArgs<ExtArgs>
    children?: boolean | sys_menu$childrenArgs<ExtArgs>
    roles?: boolean | sys_menu$rolesArgs<ExtArgs>
    user_bans?: boolean | sys_menu$user_bansArgs<ExtArgs>
    _count?: boolean | Sys_menuCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $sys_menuPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "sys_menu"
    objects: {
      parent: Prisma.$sys_menuPayload<ExtArgs> | null
      children: Prisma.$sys_menuPayload<ExtArgs>[]
      roles: Prisma.$sys_menu_on_rolePayload<ExtArgs>[]
      user_bans: Prisma.$sys_user_ban_menuPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      uid: string
      createAt: Date
      updateAt: Date
      name: string
      path: string
      powers: number
      comment: string | null
      parentId: string | null
    }, ExtArgs["result"]["sys_menu"]>
    composites: {}
  }

  type sys_menuGetPayload<S extends boolean | null | undefined | sys_menuDefaultArgs> = $Result.GetResult<Prisma.$sys_menuPayload, S>

  type sys_menuCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<sys_menuFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Sys_menuCountAggregateInputType | true
    }

  export interface sys_menuDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['sys_menu'], meta: { name: 'sys_menu' } }
    /**
     * Find zero or one Sys_menu that matches the filter.
     * @param {sys_menuFindUniqueArgs} args - Arguments to find a Sys_menu
     * @example
     * // Get one Sys_menu
     * const sys_menu = await prisma.sys_menu.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends sys_menuFindUniqueArgs>(args: SelectSubset<T, sys_menuFindUniqueArgs<ExtArgs>>): Prisma__sys_menuClient<$Result.GetResult<Prisma.$sys_menuPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Sys_menu that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {sys_menuFindUniqueOrThrowArgs} args - Arguments to find a Sys_menu
     * @example
     * // Get one Sys_menu
     * const sys_menu = await prisma.sys_menu.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends sys_menuFindUniqueOrThrowArgs>(args: SelectSubset<T, sys_menuFindUniqueOrThrowArgs<ExtArgs>>): Prisma__sys_menuClient<$Result.GetResult<Prisma.$sys_menuPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sys_menu that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sys_menuFindFirstArgs} args - Arguments to find a Sys_menu
     * @example
     * // Get one Sys_menu
     * const sys_menu = await prisma.sys_menu.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends sys_menuFindFirstArgs>(args?: SelectSubset<T, sys_menuFindFirstArgs<ExtArgs>>): Prisma__sys_menuClient<$Result.GetResult<Prisma.$sys_menuPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sys_menu that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sys_menuFindFirstOrThrowArgs} args - Arguments to find a Sys_menu
     * @example
     * // Get one Sys_menu
     * const sys_menu = await prisma.sys_menu.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends sys_menuFindFirstOrThrowArgs>(args?: SelectSubset<T, sys_menuFindFirstOrThrowArgs<ExtArgs>>): Prisma__sys_menuClient<$Result.GetResult<Prisma.$sys_menuPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sys_menus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sys_menuFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sys_menus
     * const sys_menus = await prisma.sys_menu.findMany()
     * 
     * // Get first 10 Sys_menus
     * const sys_menus = await prisma.sys_menu.findMany({ take: 10 })
     * 
     * // Only select the `uid`
     * const sys_menuWithUidOnly = await prisma.sys_menu.findMany({ select: { uid: true } })
     * 
     */
    findMany<T extends sys_menuFindManyArgs>(args?: SelectSubset<T, sys_menuFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sys_menuPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Sys_menu.
     * @param {sys_menuCreateArgs} args - Arguments to create a Sys_menu.
     * @example
     * // Create one Sys_menu
     * const Sys_menu = await prisma.sys_menu.create({
     *   data: {
     *     // ... data to create a Sys_menu
     *   }
     * })
     * 
     */
    create<T extends sys_menuCreateArgs>(args: SelectSubset<T, sys_menuCreateArgs<ExtArgs>>): Prisma__sys_menuClient<$Result.GetResult<Prisma.$sys_menuPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sys_menus.
     * @param {sys_menuCreateManyArgs} args - Arguments to create many Sys_menus.
     * @example
     * // Create many Sys_menus
     * const sys_menu = await prisma.sys_menu.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends sys_menuCreateManyArgs>(args?: SelectSubset<T, sys_menuCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Sys_menu.
     * @param {sys_menuDeleteArgs} args - Arguments to delete one Sys_menu.
     * @example
     * // Delete one Sys_menu
     * const Sys_menu = await prisma.sys_menu.delete({
     *   where: {
     *     // ... filter to delete one Sys_menu
     *   }
     * })
     * 
     */
    delete<T extends sys_menuDeleteArgs>(args: SelectSubset<T, sys_menuDeleteArgs<ExtArgs>>): Prisma__sys_menuClient<$Result.GetResult<Prisma.$sys_menuPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Sys_menu.
     * @param {sys_menuUpdateArgs} args - Arguments to update one Sys_menu.
     * @example
     * // Update one Sys_menu
     * const sys_menu = await prisma.sys_menu.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends sys_menuUpdateArgs>(args: SelectSubset<T, sys_menuUpdateArgs<ExtArgs>>): Prisma__sys_menuClient<$Result.GetResult<Prisma.$sys_menuPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sys_menus.
     * @param {sys_menuDeleteManyArgs} args - Arguments to filter Sys_menus to delete.
     * @example
     * // Delete a few Sys_menus
     * const { count } = await prisma.sys_menu.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends sys_menuDeleteManyArgs>(args?: SelectSubset<T, sys_menuDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sys_menus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sys_menuUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sys_menus
     * const sys_menu = await prisma.sys_menu.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends sys_menuUpdateManyArgs>(args: SelectSubset<T, sys_menuUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Sys_menu.
     * @param {sys_menuUpsertArgs} args - Arguments to update or create a Sys_menu.
     * @example
     * // Update or create a Sys_menu
     * const sys_menu = await prisma.sys_menu.upsert({
     *   create: {
     *     // ... data to create a Sys_menu
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Sys_menu we want to update
     *   }
     * })
     */
    upsert<T extends sys_menuUpsertArgs>(args: SelectSubset<T, sys_menuUpsertArgs<ExtArgs>>): Prisma__sys_menuClient<$Result.GetResult<Prisma.$sys_menuPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sys_menus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sys_menuCountArgs} args - Arguments to filter Sys_menus to count.
     * @example
     * // Count the number of Sys_menus
     * const count = await prisma.sys_menu.count({
     *   where: {
     *     // ... the filter for the Sys_menus we want to count
     *   }
     * })
    **/
    count<T extends sys_menuCountArgs>(
      args?: Subset<T, sys_menuCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Sys_menuCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Sys_menu.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Sys_menuAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Sys_menuAggregateArgs>(args: Subset<T, Sys_menuAggregateArgs>): Prisma.PrismaPromise<GetSys_menuAggregateType<T>>

    /**
     * Group by Sys_menu.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sys_menuGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends sys_menuGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: sys_menuGroupByArgs['orderBy'] }
        : { orderBy?: sys_menuGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, sys_menuGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSys_menuGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the sys_menu model
   */
  readonly fields: sys_menuFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for sys_menu.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__sys_menuClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    parent<T extends sys_menu$parentArgs<ExtArgs> = {}>(args?: Subset<T, sys_menu$parentArgs<ExtArgs>>): Prisma__sys_menuClient<$Result.GetResult<Prisma.$sys_menuPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    children<T extends sys_menu$childrenArgs<ExtArgs> = {}>(args?: Subset<T, sys_menu$childrenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sys_menuPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    roles<T extends sys_menu$rolesArgs<ExtArgs> = {}>(args?: Subset<T, sys_menu$rolesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sys_menu_on_rolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    user_bans<T extends sys_menu$user_bansArgs<ExtArgs> = {}>(args?: Subset<T, sys_menu$user_bansArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sys_user_ban_menuPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the sys_menu model
   */
  interface sys_menuFieldRefs {
    readonly uid: FieldRef<"sys_menu", 'String'>
    readonly createAt: FieldRef<"sys_menu", 'DateTime'>
    readonly updateAt: FieldRef<"sys_menu", 'DateTime'>
    readonly name: FieldRef<"sys_menu", 'String'>
    readonly path: FieldRef<"sys_menu", 'String'>
    readonly powers: FieldRef<"sys_menu", 'Int'>
    readonly comment: FieldRef<"sys_menu", 'String'>
    readonly parentId: FieldRef<"sys_menu", 'String'>
  }
    

  // Custom InputTypes
  /**
   * sys_menu findUnique
   */
  export type sys_menuFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sys_menu
     */
    select?: sys_menuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sys_menu
     */
    omit?: sys_menuOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sys_menuInclude<ExtArgs> | null
    /**
     * Filter, which sys_menu to fetch.
     */
    where: sys_menuWhereUniqueInput
  }

  /**
   * sys_menu findUniqueOrThrow
   */
  export type sys_menuFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sys_menu
     */
    select?: sys_menuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sys_menu
     */
    omit?: sys_menuOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sys_menuInclude<ExtArgs> | null
    /**
     * Filter, which sys_menu to fetch.
     */
    where: sys_menuWhereUniqueInput
  }

  /**
   * sys_menu findFirst
   */
  export type sys_menuFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sys_menu
     */
    select?: sys_menuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sys_menu
     */
    omit?: sys_menuOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sys_menuInclude<ExtArgs> | null
    /**
     * Filter, which sys_menu to fetch.
     */
    where?: sys_menuWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sys_menus to fetch.
     */
    orderBy?: sys_menuOrderByWithRelationInput | sys_menuOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sys_menus.
     */
    cursor?: sys_menuWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sys_menus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sys_menus.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sys_menus.
     */
    distinct?: Sys_menuScalarFieldEnum | Sys_menuScalarFieldEnum[]
  }

  /**
   * sys_menu findFirstOrThrow
   */
  export type sys_menuFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sys_menu
     */
    select?: sys_menuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sys_menu
     */
    omit?: sys_menuOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sys_menuInclude<ExtArgs> | null
    /**
     * Filter, which sys_menu to fetch.
     */
    where?: sys_menuWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sys_menus to fetch.
     */
    orderBy?: sys_menuOrderByWithRelationInput | sys_menuOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sys_menus.
     */
    cursor?: sys_menuWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sys_menus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sys_menus.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sys_menus.
     */
    distinct?: Sys_menuScalarFieldEnum | Sys_menuScalarFieldEnum[]
  }

  /**
   * sys_menu findMany
   */
  export type sys_menuFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sys_menu
     */
    select?: sys_menuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sys_menu
     */
    omit?: sys_menuOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sys_menuInclude<ExtArgs> | null
    /**
     * Filter, which sys_menus to fetch.
     */
    where?: sys_menuWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sys_menus to fetch.
     */
    orderBy?: sys_menuOrderByWithRelationInput | sys_menuOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing sys_menus.
     */
    cursor?: sys_menuWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sys_menus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sys_menus.
     */
    skip?: number
    distinct?: Sys_menuScalarFieldEnum | Sys_menuScalarFieldEnum[]
  }

  /**
   * sys_menu create
   */
  export type sys_menuCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sys_menu
     */
    select?: sys_menuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sys_menu
     */
    omit?: sys_menuOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sys_menuInclude<ExtArgs> | null
    /**
     * The data needed to create a sys_menu.
     */
    data: XOR<sys_menuCreateInput, sys_menuUncheckedCreateInput>
  }

  /**
   * sys_menu createMany
   */
  export type sys_menuCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many sys_menus.
     */
    data: sys_menuCreateManyInput | sys_menuCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * sys_menu update
   */
  export type sys_menuUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sys_menu
     */
    select?: sys_menuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sys_menu
     */
    omit?: sys_menuOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sys_menuInclude<ExtArgs> | null
    /**
     * The data needed to update a sys_menu.
     */
    data: XOR<sys_menuUpdateInput, sys_menuUncheckedUpdateInput>
    /**
     * Choose, which sys_menu to update.
     */
    where: sys_menuWhereUniqueInput
  }

  /**
   * sys_menu updateMany
   */
  export type sys_menuUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update sys_menus.
     */
    data: XOR<sys_menuUpdateManyMutationInput, sys_menuUncheckedUpdateManyInput>
    /**
     * Filter which sys_menus to update
     */
    where?: sys_menuWhereInput
    /**
     * Limit how many sys_menus to update.
     */
    limit?: number
  }

  /**
   * sys_menu upsert
   */
  export type sys_menuUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sys_menu
     */
    select?: sys_menuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sys_menu
     */
    omit?: sys_menuOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sys_menuInclude<ExtArgs> | null
    /**
     * The filter to search for the sys_menu to update in case it exists.
     */
    where: sys_menuWhereUniqueInput
    /**
     * In case the sys_menu found by the `where` argument doesn't exist, create a new sys_menu with this data.
     */
    create: XOR<sys_menuCreateInput, sys_menuUncheckedCreateInput>
    /**
     * In case the sys_menu was found with the provided `where` argument, update it with this data.
     */
    update: XOR<sys_menuUpdateInput, sys_menuUncheckedUpdateInput>
  }

  /**
   * sys_menu delete
   */
  export type sys_menuDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sys_menu
     */
    select?: sys_menuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sys_menu
     */
    omit?: sys_menuOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sys_menuInclude<ExtArgs> | null
    /**
     * Filter which sys_menu to delete.
     */
    where: sys_menuWhereUniqueInput
  }

  /**
   * sys_menu deleteMany
   */
  export type sys_menuDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which sys_menus to delete
     */
    where?: sys_menuWhereInput
    /**
     * Limit how many sys_menus to delete.
     */
    limit?: number
  }

  /**
   * sys_menu.parent
   */
  export type sys_menu$parentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sys_menu
     */
    select?: sys_menuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sys_menu
     */
    omit?: sys_menuOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sys_menuInclude<ExtArgs> | null
    where?: sys_menuWhereInput
  }

  /**
   * sys_menu.children
   */
  export type sys_menu$childrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sys_menu
     */
    select?: sys_menuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sys_menu
     */
    omit?: sys_menuOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sys_menuInclude<ExtArgs> | null
    where?: sys_menuWhereInput
    orderBy?: sys_menuOrderByWithRelationInput | sys_menuOrderByWithRelationInput[]
    cursor?: sys_menuWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Sys_menuScalarFieldEnum | Sys_menuScalarFieldEnum[]
  }

  /**
   * sys_menu.roles
   */
  export type sys_menu$rolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sys_menu_on_role
     */
    select?: sys_menu_on_roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sys_menu_on_role
     */
    omit?: sys_menu_on_roleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sys_menu_on_roleInclude<ExtArgs> | null
    where?: sys_menu_on_roleWhereInput
    orderBy?: sys_menu_on_roleOrderByWithRelationInput | sys_menu_on_roleOrderByWithRelationInput[]
    cursor?: sys_menu_on_roleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Sys_menu_on_roleScalarFieldEnum | Sys_menu_on_roleScalarFieldEnum[]
  }

  /**
   * sys_menu.user_bans
   */
  export type sys_menu$user_bansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sys_user_ban_menu
     */
    select?: sys_user_ban_menuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sys_user_ban_menu
     */
    omit?: sys_user_ban_menuOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sys_user_ban_menuInclude<ExtArgs> | null
    where?: sys_user_ban_menuWhereInput
    orderBy?: sys_user_ban_menuOrderByWithRelationInput | sys_user_ban_menuOrderByWithRelationInput[]
    cursor?: sys_user_ban_menuWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Sys_user_ban_menuScalarFieldEnum | Sys_user_ban_menuScalarFieldEnum[]
  }

  /**
   * sys_menu without action
   */
  export type sys_menuDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sys_menu
     */
    select?: sys_menuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sys_menu
     */
    omit?: sys_menuOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sys_menuInclude<ExtArgs> | null
  }


  /**
   * Model sys_user_ban_menu
   */

  export type AggregateSys_user_ban_menu = {
    _count: Sys_user_ban_menuCountAggregateOutputType | null
    _min: Sys_user_ban_menuMinAggregateOutputType | null
    _max: Sys_user_ban_menuMaxAggregateOutputType | null
  }

  export type Sys_user_ban_menuMinAggregateOutputType = {
    userId: string | null
    menuId: string | null
  }

  export type Sys_user_ban_menuMaxAggregateOutputType = {
    userId: string | null
    menuId: string | null
  }

  export type Sys_user_ban_menuCountAggregateOutputType = {
    userId: number
    menuId: number
    _all: number
  }


  export type Sys_user_ban_menuMinAggregateInputType = {
    userId?: true
    menuId?: true
  }

  export type Sys_user_ban_menuMaxAggregateInputType = {
    userId?: true
    menuId?: true
  }

  export type Sys_user_ban_menuCountAggregateInputType = {
    userId?: true
    menuId?: true
    _all?: true
  }

  export type Sys_user_ban_menuAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which sys_user_ban_menu to aggregate.
     */
    where?: sys_user_ban_menuWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sys_user_ban_menus to fetch.
     */
    orderBy?: sys_user_ban_menuOrderByWithRelationInput | sys_user_ban_menuOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: sys_user_ban_menuWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sys_user_ban_menus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sys_user_ban_menus.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned sys_user_ban_menus
    **/
    _count?: true | Sys_user_ban_menuCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Sys_user_ban_menuMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Sys_user_ban_menuMaxAggregateInputType
  }

  export type GetSys_user_ban_menuAggregateType<T extends Sys_user_ban_menuAggregateArgs> = {
        [P in keyof T & keyof AggregateSys_user_ban_menu]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSys_user_ban_menu[P]>
      : GetScalarType<T[P], AggregateSys_user_ban_menu[P]>
  }




  export type sys_user_ban_menuGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: sys_user_ban_menuWhereInput
    orderBy?: sys_user_ban_menuOrderByWithAggregationInput | sys_user_ban_menuOrderByWithAggregationInput[]
    by: Sys_user_ban_menuScalarFieldEnum[] | Sys_user_ban_menuScalarFieldEnum
    having?: sys_user_ban_menuScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Sys_user_ban_menuCountAggregateInputType | true
    _min?: Sys_user_ban_menuMinAggregateInputType
    _max?: Sys_user_ban_menuMaxAggregateInputType
  }

  export type Sys_user_ban_menuGroupByOutputType = {
    userId: string
    menuId: string
    _count: Sys_user_ban_menuCountAggregateOutputType | null
    _min: Sys_user_ban_menuMinAggregateOutputType | null
    _max: Sys_user_ban_menuMaxAggregateOutputType | null
  }

  type GetSys_user_ban_menuGroupByPayload<T extends sys_user_ban_menuGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Sys_user_ban_menuGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Sys_user_ban_menuGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Sys_user_ban_menuGroupByOutputType[P]>
            : GetScalarType<T[P], Sys_user_ban_menuGroupByOutputType[P]>
        }
      >
    >


  export type sys_user_ban_menuSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    menuId?: boolean
    user?: boolean | sys_userDefaultArgs<ExtArgs>
    menu?: boolean | sys_menuDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sys_user_ban_menu"]>



  export type sys_user_ban_menuSelectScalar = {
    userId?: boolean
    menuId?: boolean
  }

  export type sys_user_ban_menuOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"userId" | "menuId", ExtArgs["result"]["sys_user_ban_menu"]>
  export type sys_user_ban_menuInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | sys_userDefaultArgs<ExtArgs>
    menu?: boolean | sys_menuDefaultArgs<ExtArgs>
  }

  export type $sys_user_ban_menuPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "sys_user_ban_menu"
    objects: {
      user: Prisma.$sys_userPayload<ExtArgs>
      menu: Prisma.$sys_menuPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: string
      menuId: string
    }, ExtArgs["result"]["sys_user_ban_menu"]>
    composites: {}
  }

  type sys_user_ban_menuGetPayload<S extends boolean | null | undefined | sys_user_ban_menuDefaultArgs> = $Result.GetResult<Prisma.$sys_user_ban_menuPayload, S>

  type sys_user_ban_menuCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<sys_user_ban_menuFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Sys_user_ban_menuCountAggregateInputType | true
    }

  export interface sys_user_ban_menuDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['sys_user_ban_menu'], meta: { name: 'sys_user_ban_menu' } }
    /**
     * Find zero or one Sys_user_ban_menu that matches the filter.
     * @param {sys_user_ban_menuFindUniqueArgs} args - Arguments to find a Sys_user_ban_menu
     * @example
     * // Get one Sys_user_ban_menu
     * const sys_user_ban_menu = await prisma.sys_user_ban_menu.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends sys_user_ban_menuFindUniqueArgs>(args: SelectSubset<T, sys_user_ban_menuFindUniqueArgs<ExtArgs>>): Prisma__sys_user_ban_menuClient<$Result.GetResult<Prisma.$sys_user_ban_menuPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Sys_user_ban_menu that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {sys_user_ban_menuFindUniqueOrThrowArgs} args - Arguments to find a Sys_user_ban_menu
     * @example
     * // Get one Sys_user_ban_menu
     * const sys_user_ban_menu = await prisma.sys_user_ban_menu.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends sys_user_ban_menuFindUniqueOrThrowArgs>(args: SelectSubset<T, sys_user_ban_menuFindUniqueOrThrowArgs<ExtArgs>>): Prisma__sys_user_ban_menuClient<$Result.GetResult<Prisma.$sys_user_ban_menuPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sys_user_ban_menu that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sys_user_ban_menuFindFirstArgs} args - Arguments to find a Sys_user_ban_menu
     * @example
     * // Get one Sys_user_ban_menu
     * const sys_user_ban_menu = await prisma.sys_user_ban_menu.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends sys_user_ban_menuFindFirstArgs>(args?: SelectSubset<T, sys_user_ban_menuFindFirstArgs<ExtArgs>>): Prisma__sys_user_ban_menuClient<$Result.GetResult<Prisma.$sys_user_ban_menuPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sys_user_ban_menu that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sys_user_ban_menuFindFirstOrThrowArgs} args - Arguments to find a Sys_user_ban_menu
     * @example
     * // Get one Sys_user_ban_menu
     * const sys_user_ban_menu = await prisma.sys_user_ban_menu.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends sys_user_ban_menuFindFirstOrThrowArgs>(args?: SelectSubset<T, sys_user_ban_menuFindFirstOrThrowArgs<ExtArgs>>): Prisma__sys_user_ban_menuClient<$Result.GetResult<Prisma.$sys_user_ban_menuPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sys_user_ban_menus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sys_user_ban_menuFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sys_user_ban_menus
     * const sys_user_ban_menus = await prisma.sys_user_ban_menu.findMany()
     * 
     * // Get first 10 Sys_user_ban_menus
     * const sys_user_ban_menus = await prisma.sys_user_ban_menu.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const sys_user_ban_menuWithUserIdOnly = await prisma.sys_user_ban_menu.findMany({ select: { userId: true } })
     * 
     */
    findMany<T extends sys_user_ban_menuFindManyArgs>(args?: SelectSubset<T, sys_user_ban_menuFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sys_user_ban_menuPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Sys_user_ban_menu.
     * @param {sys_user_ban_menuCreateArgs} args - Arguments to create a Sys_user_ban_menu.
     * @example
     * // Create one Sys_user_ban_menu
     * const Sys_user_ban_menu = await prisma.sys_user_ban_menu.create({
     *   data: {
     *     // ... data to create a Sys_user_ban_menu
     *   }
     * })
     * 
     */
    create<T extends sys_user_ban_menuCreateArgs>(args: SelectSubset<T, sys_user_ban_menuCreateArgs<ExtArgs>>): Prisma__sys_user_ban_menuClient<$Result.GetResult<Prisma.$sys_user_ban_menuPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sys_user_ban_menus.
     * @param {sys_user_ban_menuCreateManyArgs} args - Arguments to create many Sys_user_ban_menus.
     * @example
     * // Create many Sys_user_ban_menus
     * const sys_user_ban_menu = await prisma.sys_user_ban_menu.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends sys_user_ban_menuCreateManyArgs>(args?: SelectSubset<T, sys_user_ban_menuCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Sys_user_ban_menu.
     * @param {sys_user_ban_menuDeleteArgs} args - Arguments to delete one Sys_user_ban_menu.
     * @example
     * // Delete one Sys_user_ban_menu
     * const Sys_user_ban_menu = await prisma.sys_user_ban_menu.delete({
     *   where: {
     *     // ... filter to delete one Sys_user_ban_menu
     *   }
     * })
     * 
     */
    delete<T extends sys_user_ban_menuDeleteArgs>(args: SelectSubset<T, sys_user_ban_menuDeleteArgs<ExtArgs>>): Prisma__sys_user_ban_menuClient<$Result.GetResult<Prisma.$sys_user_ban_menuPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Sys_user_ban_menu.
     * @param {sys_user_ban_menuUpdateArgs} args - Arguments to update one Sys_user_ban_menu.
     * @example
     * // Update one Sys_user_ban_menu
     * const sys_user_ban_menu = await prisma.sys_user_ban_menu.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends sys_user_ban_menuUpdateArgs>(args: SelectSubset<T, sys_user_ban_menuUpdateArgs<ExtArgs>>): Prisma__sys_user_ban_menuClient<$Result.GetResult<Prisma.$sys_user_ban_menuPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sys_user_ban_menus.
     * @param {sys_user_ban_menuDeleteManyArgs} args - Arguments to filter Sys_user_ban_menus to delete.
     * @example
     * // Delete a few Sys_user_ban_menus
     * const { count } = await prisma.sys_user_ban_menu.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends sys_user_ban_menuDeleteManyArgs>(args?: SelectSubset<T, sys_user_ban_menuDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sys_user_ban_menus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sys_user_ban_menuUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sys_user_ban_menus
     * const sys_user_ban_menu = await prisma.sys_user_ban_menu.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends sys_user_ban_menuUpdateManyArgs>(args: SelectSubset<T, sys_user_ban_menuUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Sys_user_ban_menu.
     * @param {sys_user_ban_menuUpsertArgs} args - Arguments to update or create a Sys_user_ban_menu.
     * @example
     * // Update or create a Sys_user_ban_menu
     * const sys_user_ban_menu = await prisma.sys_user_ban_menu.upsert({
     *   create: {
     *     // ... data to create a Sys_user_ban_menu
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Sys_user_ban_menu we want to update
     *   }
     * })
     */
    upsert<T extends sys_user_ban_menuUpsertArgs>(args: SelectSubset<T, sys_user_ban_menuUpsertArgs<ExtArgs>>): Prisma__sys_user_ban_menuClient<$Result.GetResult<Prisma.$sys_user_ban_menuPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sys_user_ban_menus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sys_user_ban_menuCountArgs} args - Arguments to filter Sys_user_ban_menus to count.
     * @example
     * // Count the number of Sys_user_ban_menus
     * const count = await prisma.sys_user_ban_menu.count({
     *   where: {
     *     // ... the filter for the Sys_user_ban_menus we want to count
     *   }
     * })
    **/
    count<T extends sys_user_ban_menuCountArgs>(
      args?: Subset<T, sys_user_ban_menuCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Sys_user_ban_menuCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Sys_user_ban_menu.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Sys_user_ban_menuAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Sys_user_ban_menuAggregateArgs>(args: Subset<T, Sys_user_ban_menuAggregateArgs>): Prisma.PrismaPromise<GetSys_user_ban_menuAggregateType<T>>

    /**
     * Group by Sys_user_ban_menu.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sys_user_ban_menuGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends sys_user_ban_menuGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: sys_user_ban_menuGroupByArgs['orderBy'] }
        : { orderBy?: sys_user_ban_menuGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, sys_user_ban_menuGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSys_user_ban_menuGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the sys_user_ban_menu model
   */
  readonly fields: sys_user_ban_menuFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for sys_user_ban_menu.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__sys_user_ban_menuClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends sys_userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, sys_userDefaultArgs<ExtArgs>>): Prisma__sys_userClient<$Result.GetResult<Prisma.$sys_userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    menu<T extends sys_menuDefaultArgs<ExtArgs> = {}>(args?: Subset<T, sys_menuDefaultArgs<ExtArgs>>): Prisma__sys_menuClient<$Result.GetResult<Prisma.$sys_menuPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the sys_user_ban_menu model
   */
  interface sys_user_ban_menuFieldRefs {
    readonly userId: FieldRef<"sys_user_ban_menu", 'String'>
    readonly menuId: FieldRef<"sys_user_ban_menu", 'String'>
  }
    

  // Custom InputTypes
  /**
   * sys_user_ban_menu findUnique
   */
  export type sys_user_ban_menuFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sys_user_ban_menu
     */
    select?: sys_user_ban_menuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sys_user_ban_menu
     */
    omit?: sys_user_ban_menuOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sys_user_ban_menuInclude<ExtArgs> | null
    /**
     * Filter, which sys_user_ban_menu to fetch.
     */
    where: sys_user_ban_menuWhereUniqueInput
  }

  /**
   * sys_user_ban_menu findUniqueOrThrow
   */
  export type sys_user_ban_menuFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sys_user_ban_menu
     */
    select?: sys_user_ban_menuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sys_user_ban_menu
     */
    omit?: sys_user_ban_menuOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sys_user_ban_menuInclude<ExtArgs> | null
    /**
     * Filter, which sys_user_ban_menu to fetch.
     */
    where: sys_user_ban_menuWhereUniqueInput
  }

  /**
   * sys_user_ban_menu findFirst
   */
  export type sys_user_ban_menuFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sys_user_ban_menu
     */
    select?: sys_user_ban_menuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sys_user_ban_menu
     */
    omit?: sys_user_ban_menuOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sys_user_ban_menuInclude<ExtArgs> | null
    /**
     * Filter, which sys_user_ban_menu to fetch.
     */
    where?: sys_user_ban_menuWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sys_user_ban_menus to fetch.
     */
    orderBy?: sys_user_ban_menuOrderByWithRelationInput | sys_user_ban_menuOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sys_user_ban_menus.
     */
    cursor?: sys_user_ban_menuWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sys_user_ban_menus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sys_user_ban_menus.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sys_user_ban_menus.
     */
    distinct?: Sys_user_ban_menuScalarFieldEnum | Sys_user_ban_menuScalarFieldEnum[]
  }

  /**
   * sys_user_ban_menu findFirstOrThrow
   */
  export type sys_user_ban_menuFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sys_user_ban_menu
     */
    select?: sys_user_ban_menuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sys_user_ban_menu
     */
    omit?: sys_user_ban_menuOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sys_user_ban_menuInclude<ExtArgs> | null
    /**
     * Filter, which sys_user_ban_menu to fetch.
     */
    where?: sys_user_ban_menuWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sys_user_ban_menus to fetch.
     */
    orderBy?: sys_user_ban_menuOrderByWithRelationInput | sys_user_ban_menuOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sys_user_ban_menus.
     */
    cursor?: sys_user_ban_menuWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sys_user_ban_menus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sys_user_ban_menus.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sys_user_ban_menus.
     */
    distinct?: Sys_user_ban_menuScalarFieldEnum | Sys_user_ban_menuScalarFieldEnum[]
  }

  /**
   * sys_user_ban_menu findMany
   */
  export type sys_user_ban_menuFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sys_user_ban_menu
     */
    select?: sys_user_ban_menuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sys_user_ban_menu
     */
    omit?: sys_user_ban_menuOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sys_user_ban_menuInclude<ExtArgs> | null
    /**
     * Filter, which sys_user_ban_menus to fetch.
     */
    where?: sys_user_ban_menuWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sys_user_ban_menus to fetch.
     */
    orderBy?: sys_user_ban_menuOrderByWithRelationInput | sys_user_ban_menuOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing sys_user_ban_menus.
     */
    cursor?: sys_user_ban_menuWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sys_user_ban_menus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sys_user_ban_menus.
     */
    skip?: number
    distinct?: Sys_user_ban_menuScalarFieldEnum | Sys_user_ban_menuScalarFieldEnum[]
  }

  /**
   * sys_user_ban_menu create
   */
  export type sys_user_ban_menuCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sys_user_ban_menu
     */
    select?: sys_user_ban_menuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sys_user_ban_menu
     */
    omit?: sys_user_ban_menuOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sys_user_ban_menuInclude<ExtArgs> | null
    /**
     * The data needed to create a sys_user_ban_menu.
     */
    data: XOR<sys_user_ban_menuCreateInput, sys_user_ban_menuUncheckedCreateInput>
  }

  /**
   * sys_user_ban_menu createMany
   */
  export type sys_user_ban_menuCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many sys_user_ban_menus.
     */
    data: sys_user_ban_menuCreateManyInput | sys_user_ban_menuCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * sys_user_ban_menu update
   */
  export type sys_user_ban_menuUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sys_user_ban_menu
     */
    select?: sys_user_ban_menuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sys_user_ban_menu
     */
    omit?: sys_user_ban_menuOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sys_user_ban_menuInclude<ExtArgs> | null
    /**
     * The data needed to update a sys_user_ban_menu.
     */
    data: XOR<sys_user_ban_menuUpdateInput, sys_user_ban_menuUncheckedUpdateInput>
    /**
     * Choose, which sys_user_ban_menu to update.
     */
    where: sys_user_ban_menuWhereUniqueInput
  }

  /**
   * sys_user_ban_menu updateMany
   */
  export type sys_user_ban_menuUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update sys_user_ban_menus.
     */
    data: XOR<sys_user_ban_menuUpdateManyMutationInput, sys_user_ban_menuUncheckedUpdateManyInput>
    /**
     * Filter which sys_user_ban_menus to update
     */
    where?: sys_user_ban_menuWhereInput
    /**
     * Limit how many sys_user_ban_menus to update.
     */
    limit?: number
  }

  /**
   * sys_user_ban_menu upsert
   */
  export type sys_user_ban_menuUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sys_user_ban_menu
     */
    select?: sys_user_ban_menuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sys_user_ban_menu
     */
    omit?: sys_user_ban_menuOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sys_user_ban_menuInclude<ExtArgs> | null
    /**
     * The filter to search for the sys_user_ban_menu to update in case it exists.
     */
    where: sys_user_ban_menuWhereUniqueInput
    /**
     * In case the sys_user_ban_menu found by the `where` argument doesn't exist, create a new sys_user_ban_menu with this data.
     */
    create: XOR<sys_user_ban_menuCreateInput, sys_user_ban_menuUncheckedCreateInput>
    /**
     * In case the sys_user_ban_menu was found with the provided `where` argument, update it with this data.
     */
    update: XOR<sys_user_ban_menuUpdateInput, sys_user_ban_menuUncheckedUpdateInput>
  }

  /**
   * sys_user_ban_menu delete
   */
  export type sys_user_ban_menuDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sys_user_ban_menu
     */
    select?: sys_user_ban_menuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sys_user_ban_menu
     */
    omit?: sys_user_ban_menuOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sys_user_ban_menuInclude<ExtArgs> | null
    /**
     * Filter which sys_user_ban_menu to delete.
     */
    where: sys_user_ban_menuWhereUniqueInput
  }

  /**
   * sys_user_ban_menu deleteMany
   */
  export type sys_user_ban_menuDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which sys_user_ban_menus to delete
     */
    where?: sys_user_ban_menuWhereInput
    /**
     * Limit how many sys_user_ban_menus to delete.
     */
    limit?: number
  }

  /**
   * sys_user_ban_menu without action
   */
  export type sys_user_ban_menuDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sys_user_ban_menu
     */
    select?: sys_user_ban_menuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sys_user_ban_menu
     */
    omit?: sys_user_ban_menuOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sys_user_ban_menuInclude<ExtArgs> | null
  }


  /**
   * Model sys_menu_on_role
   */

  export type AggregateSys_menu_on_role = {
    _count: Sys_menu_on_roleCountAggregateOutputType | null
    _avg: Sys_menu_on_roleAvgAggregateOutputType | null
    _sum: Sys_menu_on_roleSumAggregateOutputType | null
    _min: Sys_menu_on_roleMinAggregateOutputType | null
    _max: Sys_menu_on_roleMaxAggregateOutputType | null
  }

  export type Sys_menu_on_roleAvgAggregateOutputType = {
    power: number | null
  }

  export type Sys_menu_on_roleSumAggregateOutputType = {
    power: bigint | null
  }

  export type Sys_menu_on_roleMinAggregateOutputType = {
    roleId: string | null
    menuId: string | null
    power: bigint | null
  }

  export type Sys_menu_on_roleMaxAggregateOutputType = {
    roleId: string | null
    menuId: string | null
    power: bigint | null
  }

  export type Sys_menu_on_roleCountAggregateOutputType = {
    roleId: number
    menuId: number
    power: number
    _all: number
  }


  export type Sys_menu_on_roleAvgAggregateInputType = {
    power?: true
  }

  export type Sys_menu_on_roleSumAggregateInputType = {
    power?: true
  }

  export type Sys_menu_on_roleMinAggregateInputType = {
    roleId?: true
    menuId?: true
    power?: true
  }

  export type Sys_menu_on_roleMaxAggregateInputType = {
    roleId?: true
    menuId?: true
    power?: true
  }

  export type Sys_menu_on_roleCountAggregateInputType = {
    roleId?: true
    menuId?: true
    power?: true
    _all?: true
  }

  export type Sys_menu_on_roleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which sys_menu_on_role to aggregate.
     */
    where?: sys_menu_on_roleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sys_menu_on_roles to fetch.
     */
    orderBy?: sys_menu_on_roleOrderByWithRelationInput | sys_menu_on_roleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: sys_menu_on_roleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sys_menu_on_roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sys_menu_on_roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned sys_menu_on_roles
    **/
    _count?: true | Sys_menu_on_roleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Sys_menu_on_roleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Sys_menu_on_roleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Sys_menu_on_roleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Sys_menu_on_roleMaxAggregateInputType
  }

  export type GetSys_menu_on_roleAggregateType<T extends Sys_menu_on_roleAggregateArgs> = {
        [P in keyof T & keyof AggregateSys_menu_on_role]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSys_menu_on_role[P]>
      : GetScalarType<T[P], AggregateSys_menu_on_role[P]>
  }




  export type sys_menu_on_roleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: sys_menu_on_roleWhereInput
    orderBy?: sys_menu_on_roleOrderByWithAggregationInput | sys_menu_on_roleOrderByWithAggregationInput[]
    by: Sys_menu_on_roleScalarFieldEnum[] | Sys_menu_on_roleScalarFieldEnum
    having?: sys_menu_on_roleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Sys_menu_on_roleCountAggregateInputType | true
    _avg?: Sys_menu_on_roleAvgAggregateInputType
    _sum?: Sys_menu_on_roleSumAggregateInputType
    _min?: Sys_menu_on_roleMinAggregateInputType
    _max?: Sys_menu_on_roleMaxAggregateInputType
  }

  export type Sys_menu_on_roleGroupByOutputType = {
    roleId: string
    menuId: string
    power: bigint
    _count: Sys_menu_on_roleCountAggregateOutputType | null
    _avg: Sys_menu_on_roleAvgAggregateOutputType | null
    _sum: Sys_menu_on_roleSumAggregateOutputType | null
    _min: Sys_menu_on_roleMinAggregateOutputType | null
    _max: Sys_menu_on_roleMaxAggregateOutputType | null
  }

  type GetSys_menu_on_roleGroupByPayload<T extends sys_menu_on_roleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Sys_menu_on_roleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Sys_menu_on_roleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Sys_menu_on_roleGroupByOutputType[P]>
            : GetScalarType<T[P], Sys_menu_on_roleGroupByOutputType[P]>
        }
      >
    >


  export type sys_menu_on_roleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    roleId?: boolean
    menuId?: boolean
    power?: boolean
    menu?: boolean | sys_menuDefaultArgs<ExtArgs>
    role?: boolean | sys_roleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sys_menu_on_role"]>



  export type sys_menu_on_roleSelectScalar = {
    roleId?: boolean
    menuId?: boolean
    power?: boolean
  }

  export type sys_menu_on_roleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"roleId" | "menuId" | "power", ExtArgs["result"]["sys_menu_on_role"]>
  export type sys_menu_on_roleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    menu?: boolean | sys_menuDefaultArgs<ExtArgs>
    role?: boolean | sys_roleDefaultArgs<ExtArgs>
  }

  export type $sys_menu_on_rolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "sys_menu_on_role"
    objects: {
      menu: Prisma.$sys_menuPayload<ExtArgs>
      role: Prisma.$sys_rolePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      roleId: string
      menuId: string
      power: bigint
    }, ExtArgs["result"]["sys_menu_on_role"]>
    composites: {}
  }

  type sys_menu_on_roleGetPayload<S extends boolean | null | undefined | sys_menu_on_roleDefaultArgs> = $Result.GetResult<Prisma.$sys_menu_on_rolePayload, S>

  type sys_menu_on_roleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<sys_menu_on_roleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Sys_menu_on_roleCountAggregateInputType | true
    }

  export interface sys_menu_on_roleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['sys_menu_on_role'], meta: { name: 'sys_menu_on_role' } }
    /**
     * Find zero or one Sys_menu_on_role that matches the filter.
     * @param {sys_menu_on_roleFindUniqueArgs} args - Arguments to find a Sys_menu_on_role
     * @example
     * // Get one Sys_menu_on_role
     * const sys_menu_on_role = await prisma.sys_menu_on_role.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends sys_menu_on_roleFindUniqueArgs>(args: SelectSubset<T, sys_menu_on_roleFindUniqueArgs<ExtArgs>>): Prisma__sys_menu_on_roleClient<$Result.GetResult<Prisma.$sys_menu_on_rolePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Sys_menu_on_role that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {sys_menu_on_roleFindUniqueOrThrowArgs} args - Arguments to find a Sys_menu_on_role
     * @example
     * // Get one Sys_menu_on_role
     * const sys_menu_on_role = await prisma.sys_menu_on_role.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends sys_menu_on_roleFindUniqueOrThrowArgs>(args: SelectSubset<T, sys_menu_on_roleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__sys_menu_on_roleClient<$Result.GetResult<Prisma.$sys_menu_on_rolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sys_menu_on_role that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sys_menu_on_roleFindFirstArgs} args - Arguments to find a Sys_menu_on_role
     * @example
     * // Get one Sys_menu_on_role
     * const sys_menu_on_role = await prisma.sys_menu_on_role.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends sys_menu_on_roleFindFirstArgs>(args?: SelectSubset<T, sys_menu_on_roleFindFirstArgs<ExtArgs>>): Prisma__sys_menu_on_roleClient<$Result.GetResult<Prisma.$sys_menu_on_rolePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sys_menu_on_role that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sys_menu_on_roleFindFirstOrThrowArgs} args - Arguments to find a Sys_menu_on_role
     * @example
     * // Get one Sys_menu_on_role
     * const sys_menu_on_role = await prisma.sys_menu_on_role.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends sys_menu_on_roleFindFirstOrThrowArgs>(args?: SelectSubset<T, sys_menu_on_roleFindFirstOrThrowArgs<ExtArgs>>): Prisma__sys_menu_on_roleClient<$Result.GetResult<Prisma.$sys_menu_on_rolePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sys_menu_on_roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sys_menu_on_roleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sys_menu_on_roles
     * const sys_menu_on_roles = await prisma.sys_menu_on_role.findMany()
     * 
     * // Get first 10 Sys_menu_on_roles
     * const sys_menu_on_roles = await prisma.sys_menu_on_role.findMany({ take: 10 })
     * 
     * // Only select the `roleId`
     * const sys_menu_on_roleWithRoleIdOnly = await prisma.sys_menu_on_role.findMany({ select: { roleId: true } })
     * 
     */
    findMany<T extends sys_menu_on_roleFindManyArgs>(args?: SelectSubset<T, sys_menu_on_roleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sys_menu_on_rolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Sys_menu_on_role.
     * @param {sys_menu_on_roleCreateArgs} args - Arguments to create a Sys_menu_on_role.
     * @example
     * // Create one Sys_menu_on_role
     * const Sys_menu_on_role = await prisma.sys_menu_on_role.create({
     *   data: {
     *     // ... data to create a Sys_menu_on_role
     *   }
     * })
     * 
     */
    create<T extends sys_menu_on_roleCreateArgs>(args: SelectSubset<T, sys_menu_on_roleCreateArgs<ExtArgs>>): Prisma__sys_menu_on_roleClient<$Result.GetResult<Prisma.$sys_menu_on_rolePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sys_menu_on_roles.
     * @param {sys_menu_on_roleCreateManyArgs} args - Arguments to create many Sys_menu_on_roles.
     * @example
     * // Create many Sys_menu_on_roles
     * const sys_menu_on_role = await prisma.sys_menu_on_role.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends sys_menu_on_roleCreateManyArgs>(args?: SelectSubset<T, sys_menu_on_roleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Sys_menu_on_role.
     * @param {sys_menu_on_roleDeleteArgs} args - Arguments to delete one Sys_menu_on_role.
     * @example
     * // Delete one Sys_menu_on_role
     * const Sys_menu_on_role = await prisma.sys_menu_on_role.delete({
     *   where: {
     *     // ... filter to delete one Sys_menu_on_role
     *   }
     * })
     * 
     */
    delete<T extends sys_menu_on_roleDeleteArgs>(args: SelectSubset<T, sys_menu_on_roleDeleteArgs<ExtArgs>>): Prisma__sys_menu_on_roleClient<$Result.GetResult<Prisma.$sys_menu_on_rolePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Sys_menu_on_role.
     * @param {sys_menu_on_roleUpdateArgs} args - Arguments to update one Sys_menu_on_role.
     * @example
     * // Update one Sys_menu_on_role
     * const sys_menu_on_role = await prisma.sys_menu_on_role.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends sys_menu_on_roleUpdateArgs>(args: SelectSubset<T, sys_menu_on_roleUpdateArgs<ExtArgs>>): Prisma__sys_menu_on_roleClient<$Result.GetResult<Prisma.$sys_menu_on_rolePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sys_menu_on_roles.
     * @param {sys_menu_on_roleDeleteManyArgs} args - Arguments to filter Sys_menu_on_roles to delete.
     * @example
     * // Delete a few Sys_menu_on_roles
     * const { count } = await prisma.sys_menu_on_role.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends sys_menu_on_roleDeleteManyArgs>(args?: SelectSubset<T, sys_menu_on_roleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sys_menu_on_roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sys_menu_on_roleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sys_menu_on_roles
     * const sys_menu_on_role = await prisma.sys_menu_on_role.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends sys_menu_on_roleUpdateManyArgs>(args: SelectSubset<T, sys_menu_on_roleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Sys_menu_on_role.
     * @param {sys_menu_on_roleUpsertArgs} args - Arguments to update or create a Sys_menu_on_role.
     * @example
     * // Update or create a Sys_menu_on_role
     * const sys_menu_on_role = await prisma.sys_menu_on_role.upsert({
     *   create: {
     *     // ... data to create a Sys_menu_on_role
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Sys_menu_on_role we want to update
     *   }
     * })
     */
    upsert<T extends sys_menu_on_roleUpsertArgs>(args: SelectSubset<T, sys_menu_on_roleUpsertArgs<ExtArgs>>): Prisma__sys_menu_on_roleClient<$Result.GetResult<Prisma.$sys_menu_on_rolePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sys_menu_on_roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sys_menu_on_roleCountArgs} args - Arguments to filter Sys_menu_on_roles to count.
     * @example
     * // Count the number of Sys_menu_on_roles
     * const count = await prisma.sys_menu_on_role.count({
     *   where: {
     *     // ... the filter for the Sys_menu_on_roles we want to count
     *   }
     * })
    **/
    count<T extends sys_menu_on_roleCountArgs>(
      args?: Subset<T, sys_menu_on_roleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Sys_menu_on_roleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Sys_menu_on_role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Sys_menu_on_roleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Sys_menu_on_roleAggregateArgs>(args: Subset<T, Sys_menu_on_roleAggregateArgs>): Prisma.PrismaPromise<GetSys_menu_on_roleAggregateType<T>>

    /**
     * Group by Sys_menu_on_role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sys_menu_on_roleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends sys_menu_on_roleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: sys_menu_on_roleGroupByArgs['orderBy'] }
        : { orderBy?: sys_menu_on_roleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, sys_menu_on_roleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSys_menu_on_roleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the sys_menu_on_role model
   */
  readonly fields: sys_menu_on_roleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for sys_menu_on_role.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__sys_menu_on_roleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    menu<T extends sys_menuDefaultArgs<ExtArgs> = {}>(args?: Subset<T, sys_menuDefaultArgs<ExtArgs>>): Prisma__sys_menuClient<$Result.GetResult<Prisma.$sys_menuPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    role<T extends sys_roleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, sys_roleDefaultArgs<ExtArgs>>): Prisma__sys_roleClient<$Result.GetResult<Prisma.$sys_rolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the sys_menu_on_role model
   */
  interface sys_menu_on_roleFieldRefs {
    readonly roleId: FieldRef<"sys_menu_on_role", 'String'>
    readonly menuId: FieldRef<"sys_menu_on_role", 'String'>
    readonly power: FieldRef<"sys_menu_on_role", 'BigInt'>
  }
    

  // Custom InputTypes
  /**
   * sys_menu_on_role findUnique
   */
  export type sys_menu_on_roleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sys_menu_on_role
     */
    select?: sys_menu_on_roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sys_menu_on_role
     */
    omit?: sys_menu_on_roleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sys_menu_on_roleInclude<ExtArgs> | null
    /**
     * Filter, which sys_menu_on_role to fetch.
     */
    where: sys_menu_on_roleWhereUniqueInput
  }

  /**
   * sys_menu_on_role findUniqueOrThrow
   */
  export type sys_menu_on_roleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sys_menu_on_role
     */
    select?: sys_menu_on_roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sys_menu_on_role
     */
    omit?: sys_menu_on_roleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sys_menu_on_roleInclude<ExtArgs> | null
    /**
     * Filter, which sys_menu_on_role to fetch.
     */
    where: sys_menu_on_roleWhereUniqueInput
  }

  /**
   * sys_menu_on_role findFirst
   */
  export type sys_menu_on_roleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sys_menu_on_role
     */
    select?: sys_menu_on_roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sys_menu_on_role
     */
    omit?: sys_menu_on_roleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sys_menu_on_roleInclude<ExtArgs> | null
    /**
     * Filter, which sys_menu_on_role to fetch.
     */
    where?: sys_menu_on_roleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sys_menu_on_roles to fetch.
     */
    orderBy?: sys_menu_on_roleOrderByWithRelationInput | sys_menu_on_roleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sys_menu_on_roles.
     */
    cursor?: sys_menu_on_roleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sys_menu_on_roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sys_menu_on_roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sys_menu_on_roles.
     */
    distinct?: Sys_menu_on_roleScalarFieldEnum | Sys_menu_on_roleScalarFieldEnum[]
  }

  /**
   * sys_menu_on_role findFirstOrThrow
   */
  export type sys_menu_on_roleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sys_menu_on_role
     */
    select?: sys_menu_on_roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sys_menu_on_role
     */
    omit?: sys_menu_on_roleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sys_menu_on_roleInclude<ExtArgs> | null
    /**
     * Filter, which sys_menu_on_role to fetch.
     */
    where?: sys_menu_on_roleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sys_menu_on_roles to fetch.
     */
    orderBy?: sys_menu_on_roleOrderByWithRelationInput | sys_menu_on_roleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sys_menu_on_roles.
     */
    cursor?: sys_menu_on_roleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sys_menu_on_roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sys_menu_on_roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sys_menu_on_roles.
     */
    distinct?: Sys_menu_on_roleScalarFieldEnum | Sys_menu_on_roleScalarFieldEnum[]
  }

  /**
   * sys_menu_on_role findMany
   */
  export type sys_menu_on_roleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sys_menu_on_role
     */
    select?: sys_menu_on_roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sys_menu_on_role
     */
    omit?: sys_menu_on_roleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sys_menu_on_roleInclude<ExtArgs> | null
    /**
     * Filter, which sys_menu_on_roles to fetch.
     */
    where?: sys_menu_on_roleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sys_menu_on_roles to fetch.
     */
    orderBy?: sys_menu_on_roleOrderByWithRelationInput | sys_menu_on_roleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing sys_menu_on_roles.
     */
    cursor?: sys_menu_on_roleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sys_menu_on_roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sys_menu_on_roles.
     */
    skip?: number
    distinct?: Sys_menu_on_roleScalarFieldEnum | Sys_menu_on_roleScalarFieldEnum[]
  }

  /**
   * sys_menu_on_role create
   */
  export type sys_menu_on_roleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sys_menu_on_role
     */
    select?: sys_menu_on_roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sys_menu_on_role
     */
    omit?: sys_menu_on_roleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sys_menu_on_roleInclude<ExtArgs> | null
    /**
     * The data needed to create a sys_menu_on_role.
     */
    data: XOR<sys_menu_on_roleCreateInput, sys_menu_on_roleUncheckedCreateInput>
  }

  /**
   * sys_menu_on_role createMany
   */
  export type sys_menu_on_roleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many sys_menu_on_roles.
     */
    data: sys_menu_on_roleCreateManyInput | sys_menu_on_roleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * sys_menu_on_role update
   */
  export type sys_menu_on_roleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sys_menu_on_role
     */
    select?: sys_menu_on_roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sys_menu_on_role
     */
    omit?: sys_menu_on_roleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sys_menu_on_roleInclude<ExtArgs> | null
    /**
     * The data needed to update a sys_menu_on_role.
     */
    data: XOR<sys_menu_on_roleUpdateInput, sys_menu_on_roleUncheckedUpdateInput>
    /**
     * Choose, which sys_menu_on_role to update.
     */
    where: sys_menu_on_roleWhereUniqueInput
  }

  /**
   * sys_menu_on_role updateMany
   */
  export type sys_menu_on_roleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update sys_menu_on_roles.
     */
    data: XOR<sys_menu_on_roleUpdateManyMutationInput, sys_menu_on_roleUncheckedUpdateManyInput>
    /**
     * Filter which sys_menu_on_roles to update
     */
    where?: sys_menu_on_roleWhereInput
    /**
     * Limit how many sys_menu_on_roles to update.
     */
    limit?: number
  }

  /**
   * sys_menu_on_role upsert
   */
  export type sys_menu_on_roleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sys_menu_on_role
     */
    select?: sys_menu_on_roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sys_menu_on_role
     */
    omit?: sys_menu_on_roleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sys_menu_on_roleInclude<ExtArgs> | null
    /**
     * The filter to search for the sys_menu_on_role to update in case it exists.
     */
    where: sys_menu_on_roleWhereUniqueInput
    /**
     * In case the sys_menu_on_role found by the `where` argument doesn't exist, create a new sys_menu_on_role with this data.
     */
    create: XOR<sys_menu_on_roleCreateInput, sys_menu_on_roleUncheckedCreateInput>
    /**
     * In case the sys_menu_on_role was found with the provided `where` argument, update it with this data.
     */
    update: XOR<sys_menu_on_roleUpdateInput, sys_menu_on_roleUncheckedUpdateInput>
  }

  /**
   * sys_menu_on_role delete
   */
  export type sys_menu_on_roleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sys_menu_on_role
     */
    select?: sys_menu_on_roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sys_menu_on_role
     */
    omit?: sys_menu_on_roleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sys_menu_on_roleInclude<ExtArgs> | null
    /**
     * Filter which sys_menu_on_role to delete.
     */
    where: sys_menu_on_roleWhereUniqueInput
  }

  /**
   * sys_menu_on_role deleteMany
   */
  export type sys_menu_on_roleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which sys_menu_on_roles to delete
     */
    where?: sys_menu_on_roleWhereInput
    /**
     * Limit how many sys_menu_on_roles to delete.
     */
    limit?: number
  }

  /**
   * sys_menu_on_role without action
   */
  export type sys_menu_on_roleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sys_menu_on_role
     */
    select?: sys_menu_on_roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sys_menu_on_role
     */
    omit?: sys_menu_on_roleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sys_menu_on_roleInclude<ExtArgs> | null
  }


  /**
   * Model sys_role
   */

  export type AggregateSys_role = {
    _count: Sys_roleCountAggregateOutputType | null
    _min: Sys_roleMinAggregateOutputType | null
    _max: Sys_roleMaxAggregateOutputType | null
  }

  export type Sys_roleMinAggregateOutputType = {
    uid: string | null
    createAt: Date | null
    updateAt: Date | null
    name: string | null
    status: boolean | null
    comment: string | null
  }

  export type Sys_roleMaxAggregateOutputType = {
    uid: string | null
    createAt: Date | null
    updateAt: Date | null
    name: string | null
    status: boolean | null
    comment: string | null
  }

  export type Sys_roleCountAggregateOutputType = {
    uid: number
    createAt: number
    updateAt: number
    name: number
    status: number
    comment: number
    _all: number
  }


  export type Sys_roleMinAggregateInputType = {
    uid?: true
    createAt?: true
    updateAt?: true
    name?: true
    status?: true
    comment?: true
  }

  export type Sys_roleMaxAggregateInputType = {
    uid?: true
    createAt?: true
    updateAt?: true
    name?: true
    status?: true
    comment?: true
  }

  export type Sys_roleCountAggregateInputType = {
    uid?: true
    createAt?: true
    updateAt?: true
    name?: true
    status?: true
    comment?: true
    _all?: true
  }

  export type Sys_roleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which sys_role to aggregate.
     */
    where?: sys_roleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sys_roles to fetch.
     */
    orderBy?: sys_roleOrderByWithRelationInput | sys_roleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: sys_roleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sys_roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sys_roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned sys_roles
    **/
    _count?: true | Sys_roleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Sys_roleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Sys_roleMaxAggregateInputType
  }

  export type GetSys_roleAggregateType<T extends Sys_roleAggregateArgs> = {
        [P in keyof T & keyof AggregateSys_role]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSys_role[P]>
      : GetScalarType<T[P], AggregateSys_role[P]>
  }




  export type sys_roleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: sys_roleWhereInput
    orderBy?: sys_roleOrderByWithAggregationInput | sys_roleOrderByWithAggregationInput[]
    by: Sys_roleScalarFieldEnum[] | Sys_roleScalarFieldEnum
    having?: sys_roleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Sys_roleCountAggregateInputType | true
    _min?: Sys_roleMinAggregateInputType
    _max?: Sys_roleMaxAggregateInputType
  }

  export type Sys_roleGroupByOutputType = {
    uid: string
    createAt: Date
    updateAt: Date
    name: string
    status: boolean
    comment: string | null
    _count: Sys_roleCountAggregateOutputType | null
    _min: Sys_roleMinAggregateOutputType | null
    _max: Sys_roleMaxAggregateOutputType | null
  }

  type GetSys_roleGroupByPayload<T extends sys_roleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Sys_roleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Sys_roleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Sys_roleGroupByOutputType[P]>
            : GetScalarType<T[P], Sys_roleGroupByOutputType[P]>
        }
      >
    >


  export type sys_roleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    uid?: boolean
    createAt?: boolean
    updateAt?: boolean
    name?: boolean
    status?: boolean
    comment?: boolean
    menus?: boolean | sys_role$menusArgs<ExtArgs>
    users?: boolean | sys_role$usersArgs<ExtArgs>
    _count?: boolean | Sys_roleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sys_role"]>



  export type sys_roleSelectScalar = {
    uid?: boolean
    createAt?: boolean
    updateAt?: boolean
    name?: boolean
    status?: boolean
    comment?: boolean
  }

  export type sys_roleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"uid" | "createAt" | "updateAt" | "name" | "status" | "comment", ExtArgs["result"]["sys_role"]>
  export type sys_roleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    menus?: boolean | sys_role$menusArgs<ExtArgs>
    users?: boolean | sys_role$usersArgs<ExtArgs>
    _count?: boolean | Sys_roleCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $sys_rolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "sys_role"
    objects: {
      menus: Prisma.$sys_menu_on_rolePayload<ExtArgs>[]
      users: Prisma.$sys_userPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      uid: string
      createAt: Date
      updateAt: Date
      name: string
      status: boolean
      comment: string | null
    }, ExtArgs["result"]["sys_role"]>
    composites: {}
  }

  type sys_roleGetPayload<S extends boolean | null | undefined | sys_roleDefaultArgs> = $Result.GetResult<Prisma.$sys_rolePayload, S>

  type sys_roleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<sys_roleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Sys_roleCountAggregateInputType | true
    }

  export interface sys_roleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['sys_role'], meta: { name: 'sys_role' } }
    /**
     * Find zero or one Sys_role that matches the filter.
     * @param {sys_roleFindUniqueArgs} args - Arguments to find a Sys_role
     * @example
     * // Get one Sys_role
     * const sys_role = await prisma.sys_role.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends sys_roleFindUniqueArgs>(args: SelectSubset<T, sys_roleFindUniqueArgs<ExtArgs>>): Prisma__sys_roleClient<$Result.GetResult<Prisma.$sys_rolePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Sys_role that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {sys_roleFindUniqueOrThrowArgs} args - Arguments to find a Sys_role
     * @example
     * // Get one Sys_role
     * const sys_role = await prisma.sys_role.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends sys_roleFindUniqueOrThrowArgs>(args: SelectSubset<T, sys_roleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__sys_roleClient<$Result.GetResult<Prisma.$sys_rolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sys_role that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sys_roleFindFirstArgs} args - Arguments to find a Sys_role
     * @example
     * // Get one Sys_role
     * const sys_role = await prisma.sys_role.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends sys_roleFindFirstArgs>(args?: SelectSubset<T, sys_roleFindFirstArgs<ExtArgs>>): Prisma__sys_roleClient<$Result.GetResult<Prisma.$sys_rolePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sys_role that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sys_roleFindFirstOrThrowArgs} args - Arguments to find a Sys_role
     * @example
     * // Get one Sys_role
     * const sys_role = await prisma.sys_role.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends sys_roleFindFirstOrThrowArgs>(args?: SelectSubset<T, sys_roleFindFirstOrThrowArgs<ExtArgs>>): Prisma__sys_roleClient<$Result.GetResult<Prisma.$sys_rolePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sys_roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sys_roleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sys_roles
     * const sys_roles = await prisma.sys_role.findMany()
     * 
     * // Get first 10 Sys_roles
     * const sys_roles = await prisma.sys_role.findMany({ take: 10 })
     * 
     * // Only select the `uid`
     * const sys_roleWithUidOnly = await prisma.sys_role.findMany({ select: { uid: true } })
     * 
     */
    findMany<T extends sys_roleFindManyArgs>(args?: SelectSubset<T, sys_roleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sys_rolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Sys_role.
     * @param {sys_roleCreateArgs} args - Arguments to create a Sys_role.
     * @example
     * // Create one Sys_role
     * const Sys_role = await prisma.sys_role.create({
     *   data: {
     *     // ... data to create a Sys_role
     *   }
     * })
     * 
     */
    create<T extends sys_roleCreateArgs>(args: SelectSubset<T, sys_roleCreateArgs<ExtArgs>>): Prisma__sys_roleClient<$Result.GetResult<Prisma.$sys_rolePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sys_roles.
     * @param {sys_roleCreateManyArgs} args - Arguments to create many Sys_roles.
     * @example
     * // Create many Sys_roles
     * const sys_role = await prisma.sys_role.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends sys_roleCreateManyArgs>(args?: SelectSubset<T, sys_roleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Sys_role.
     * @param {sys_roleDeleteArgs} args - Arguments to delete one Sys_role.
     * @example
     * // Delete one Sys_role
     * const Sys_role = await prisma.sys_role.delete({
     *   where: {
     *     // ... filter to delete one Sys_role
     *   }
     * })
     * 
     */
    delete<T extends sys_roleDeleteArgs>(args: SelectSubset<T, sys_roleDeleteArgs<ExtArgs>>): Prisma__sys_roleClient<$Result.GetResult<Prisma.$sys_rolePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Sys_role.
     * @param {sys_roleUpdateArgs} args - Arguments to update one Sys_role.
     * @example
     * // Update one Sys_role
     * const sys_role = await prisma.sys_role.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends sys_roleUpdateArgs>(args: SelectSubset<T, sys_roleUpdateArgs<ExtArgs>>): Prisma__sys_roleClient<$Result.GetResult<Prisma.$sys_rolePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sys_roles.
     * @param {sys_roleDeleteManyArgs} args - Arguments to filter Sys_roles to delete.
     * @example
     * // Delete a few Sys_roles
     * const { count } = await prisma.sys_role.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends sys_roleDeleteManyArgs>(args?: SelectSubset<T, sys_roleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sys_roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sys_roleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sys_roles
     * const sys_role = await prisma.sys_role.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends sys_roleUpdateManyArgs>(args: SelectSubset<T, sys_roleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Sys_role.
     * @param {sys_roleUpsertArgs} args - Arguments to update or create a Sys_role.
     * @example
     * // Update or create a Sys_role
     * const sys_role = await prisma.sys_role.upsert({
     *   create: {
     *     // ... data to create a Sys_role
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Sys_role we want to update
     *   }
     * })
     */
    upsert<T extends sys_roleUpsertArgs>(args: SelectSubset<T, sys_roleUpsertArgs<ExtArgs>>): Prisma__sys_roleClient<$Result.GetResult<Prisma.$sys_rolePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sys_roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sys_roleCountArgs} args - Arguments to filter Sys_roles to count.
     * @example
     * // Count the number of Sys_roles
     * const count = await prisma.sys_role.count({
     *   where: {
     *     // ... the filter for the Sys_roles we want to count
     *   }
     * })
    **/
    count<T extends sys_roleCountArgs>(
      args?: Subset<T, sys_roleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Sys_roleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Sys_role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Sys_roleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Sys_roleAggregateArgs>(args: Subset<T, Sys_roleAggregateArgs>): Prisma.PrismaPromise<GetSys_roleAggregateType<T>>

    /**
     * Group by Sys_role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sys_roleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends sys_roleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: sys_roleGroupByArgs['orderBy'] }
        : { orderBy?: sys_roleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, sys_roleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSys_roleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the sys_role model
   */
  readonly fields: sys_roleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for sys_role.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__sys_roleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    menus<T extends sys_role$menusArgs<ExtArgs> = {}>(args?: Subset<T, sys_role$menusArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sys_menu_on_rolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    users<T extends sys_role$usersArgs<ExtArgs> = {}>(args?: Subset<T, sys_role$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sys_userPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the sys_role model
   */
  interface sys_roleFieldRefs {
    readonly uid: FieldRef<"sys_role", 'String'>
    readonly createAt: FieldRef<"sys_role", 'DateTime'>
    readonly updateAt: FieldRef<"sys_role", 'DateTime'>
    readonly name: FieldRef<"sys_role", 'String'>
    readonly status: FieldRef<"sys_role", 'Boolean'>
    readonly comment: FieldRef<"sys_role", 'String'>
  }
    

  // Custom InputTypes
  /**
   * sys_role findUnique
   */
  export type sys_roleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sys_role
     */
    select?: sys_roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sys_role
     */
    omit?: sys_roleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sys_roleInclude<ExtArgs> | null
    /**
     * Filter, which sys_role to fetch.
     */
    where: sys_roleWhereUniqueInput
  }

  /**
   * sys_role findUniqueOrThrow
   */
  export type sys_roleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sys_role
     */
    select?: sys_roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sys_role
     */
    omit?: sys_roleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sys_roleInclude<ExtArgs> | null
    /**
     * Filter, which sys_role to fetch.
     */
    where: sys_roleWhereUniqueInput
  }

  /**
   * sys_role findFirst
   */
  export type sys_roleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sys_role
     */
    select?: sys_roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sys_role
     */
    omit?: sys_roleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sys_roleInclude<ExtArgs> | null
    /**
     * Filter, which sys_role to fetch.
     */
    where?: sys_roleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sys_roles to fetch.
     */
    orderBy?: sys_roleOrderByWithRelationInput | sys_roleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sys_roles.
     */
    cursor?: sys_roleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sys_roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sys_roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sys_roles.
     */
    distinct?: Sys_roleScalarFieldEnum | Sys_roleScalarFieldEnum[]
  }

  /**
   * sys_role findFirstOrThrow
   */
  export type sys_roleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sys_role
     */
    select?: sys_roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sys_role
     */
    omit?: sys_roleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sys_roleInclude<ExtArgs> | null
    /**
     * Filter, which sys_role to fetch.
     */
    where?: sys_roleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sys_roles to fetch.
     */
    orderBy?: sys_roleOrderByWithRelationInput | sys_roleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sys_roles.
     */
    cursor?: sys_roleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sys_roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sys_roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sys_roles.
     */
    distinct?: Sys_roleScalarFieldEnum | Sys_roleScalarFieldEnum[]
  }

  /**
   * sys_role findMany
   */
  export type sys_roleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sys_role
     */
    select?: sys_roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sys_role
     */
    omit?: sys_roleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sys_roleInclude<ExtArgs> | null
    /**
     * Filter, which sys_roles to fetch.
     */
    where?: sys_roleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sys_roles to fetch.
     */
    orderBy?: sys_roleOrderByWithRelationInput | sys_roleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing sys_roles.
     */
    cursor?: sys_roleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sys_roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sys_roles.
     */
    skip?: number
    distinct?: Sys_roleScalarFieldEnum | Sys_roleScalarFieldEnum[]
  }

  /**
   * sys_role create
   */
  export type sys_roleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sys_role
     */
    select?: sys_roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sys_role
     */
    omit?: sys_roleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sys_roleInclude<ExtArgs> | null
    /**
     * The data needed to create a sys_role.
     */
    data: XOR<sys_roleCreateInput, sys_roleUncheckedCreateInput>
  }

  /**
   * sys_role createMany
   */
  export type sys_roleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many sys_roles.
     */
    data: sys_roleCreateManyInput | sys_roleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * sys_role update
   */
  export type sys_roleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sys_role
     */
    select?: sys_roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sys_role
     */
    omit?: sys_roleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sys_roleInclude<ExtArgs> | null
    /**
     * The data needed to update a sys_role.
     */
    data: XOR<sys_roleUpdateInput, sys_roleUncheckedUpdateInput>
    /**
     * Choose, which sys_role to update.
     */
    where: sys_roleWhereUniqueInput
  }

  /**
   * sys_role updateMany
   */
  export type sys_roleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update sys_roles.
     */
    data: XOR<sys_roleUpdateManyMutationInput, sys_roleUncheckedUpdateManyInput>
    /**
     * Filter which sys_roles to update
     */
    where?: sys_roleWhereInput
    /**
     * Limit how many sys_roles to update.
     */
    limit?: number
  }

  /**
   * sys_role upsert
   */
  export type sys_roleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sys_role
     */
    select?: sys_roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sys_role
     */
    omit?: sys_roleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sys_roleInclude<ExtArgs> | null
    /**
     * The filter to search for the sys_role to update in case it exists.
     */
    where: sys_roleWhereUniqueInput
    /**
     * In case the sys_role found by the `where` argument doesn't exist, create a new sys_role with this data.
     */
    create: XOR<sys_roleCreateInput, sys_roleUncheckedCreateInput>
    /**
     * In case the sys_role was found with the provided `where` argument, update it with this data.
     */
    update: XOR<sys_roleUpdateInput, sys_roleUncheckedUpdateInput>
  }

  /**
   * sys_role delete
   */
  export type sys_roleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sys_role
     */
    select?: sys_roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sys_role
     */
    omit?: sys_roleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sys_roleInclude<ExtArgs> | null
    /**
     * Filter which sys_role to delete.
     */
    where: sys_roleWhereUniqueInput
  }

  /**
   * sys_role deleteMany
   */
  export type sys_roleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which sys_roles to delete
     */
    where?: sys_roleWhereInput
    /**
     * Limit how many sys_roles to delete.
     */
    limit?: number
  }

  /**
   * sys_role.menus
   */
  export type sys_role$menusArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sys_menu_on_role
     */
    select?: sys_menu_on_roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sys_menu_on_role
     */
    omit?: sys_menu_on_roleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sys_menu_on_roleInclude<ExtArgs> | null
    where?: sys_menu_on_roleWhereInput
    orderBy?: sys_menu_on_roleOrderByWithRelationInput | sys_menu_on_roleOrderByWithRelationInput[]
    cursor?: sys_menu_on_roleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Sys_menu_on_roleScalarFieldEnum | Sys_menu_on_roleScalarFieldEnum[]
  }

  /**
   * sys_role.users
   */
  export type sys_role$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sys_user
     */
    select?: sys_userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sys_user
     */
    omit?: sys_userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sys_userInclude<ExtArgs> | null
    where?: sys_userWhereInput
    orderBy?: sys_userOrderByWithRelationInput | sys_userOrderByWithRelationInput[]
    cursor?: sys_userWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Sys_userScalarFieldEnum | Sys_userScalarFieldEnum[]
  }

  /**
   * sys_role without action
   */
  export type sys_roleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sys_role
     */
    select?: sys_roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sys_role
     */
    omit?: sys_roleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sys_roleInclude<ExtArgs> | null
  }


  /**
   * Model blog_user
   */

  export type AggregateBlog_user = {
    _count: Blog_userCountAggregateOutputType | null
    _min: Blog_userMinAggregateOutputType | null
    _max: Blog_userMaxAggregateOutputType | null
  }

  export type Blog_userMinAggregateOutputType = {
    uid: string | null
    createAt: Date | null
    updateAt: Date | null
    name: string | null
  }

  export type Blog_userMaxAggregateOutputType = {
    uid: string | null
    createAt: Date | null
    updateAt: Date | null
    name: string | null
  }

  export type Blog_userCountAggregateOutputType = {
    uid: number
    createAt: number
    updateAt: number
    name: number
    _all: number
  }


  export type Blog_userMinAggregateInputType = {
    uid?: true
    createAt?: true
    updateAt?: true
    name?: true
  }

  export type Blog_userMaxAggregateInputType = {
    uid?: true
    createAt?: true
    updateAt?: true
    name?: true
  }

  export type Blog_userCountAggregateInputType = {
    uid?: true
    createAt?: true
    updateAt?: true
    name?: true
    _all?: true
  }

  export type Blog_userAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which blog_user to aggregate.
     */
    where?: blog_userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of blog_users to fetch.
     */
    orderBy?: blog_userOrderByWithRelationInput | blog_userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: blog_userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` blog_users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` blog_users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned blog_users
    **/
    _count?: true | Blog_userCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Blog_userMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Blog_userMaxAggregateInputType
  }

  export type GetBlog_userAggregateType<T extends Blog_userAggregateArgs> = {
        [P in keyof T & keyof AggregateBlog_user]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBlog_user[P]>
      : GetScalarType<T[P], AggregateBlog_user[P]>
  }




  export type blog_userGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: blog_userWhereInput
    orderBy?: blog_userOrderByWithAggregationInput | blog_userOrderByWithAggregationInput[]
    by: Blog_userScalarFieldEnum[] | Blog_userScalarFieldEnum
    having?: blog_userScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Blog_userCountAggregateInputType | true
    _min?: Blog_userMinAggregateInputType
    _max?: Blog_userMaxAggregateInputType
  }

  export type Blog_userGroupByOutputType = {
    uid: string
    createAt: Date
    updateAt: Date
    name: string
    _count: Blog_userCountAggregateOutputType | null
    _min: Blog_userMinAggregateOutputType | null
    _max: Blog_userMaxAggregateOutputType | null
  }

  type GetBlog_userGroupByPayload<T extends blog_userGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Blog_userGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Blog_userGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Blog_userGroupByOutputType[P]>
            : GetScalarType<T[P], Blog_userGroupByOutputType[P]>
        }
      >
    >


  export type blog_userSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    uid?: boolean
    createAt?: boolean
    updateAt?: boolean
    name?: boolean
    posts?: boolean | blog_user$postsArgs<ExtArgs>
    _count?: boolean | Blog_userCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["blog_user"]>



  export type blog_userSelectScalar = {
    uid?: boolean
    createAt?: boolean
    updateAt?: boolean
    name?: boolean
  }

  export type blog_userOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"uid" | "createAt" | "updateAt" | "name", ExtArgs["result"]["blog_user"]>
  export type blog_userInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    posts?: boolean | blog_user$postsArgs<ExtArgs>
    _count?: boolean | Blog_userCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $blog_userPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "blog_user"
    objects: {
      posts: Prisma.$blog_postsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      uid: string
      createAt: Date
      updateAt: Date
      name: string
    }, ExtArgs["result"]["blog_user"]>
    composites: {}
  }

  type blog_userGetPayload<S extends boolean | null | undefined | blog_userDefaultArgs> = $Result.GetResult<Prisma.$blog_userPayload, S>

  type blog_userCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<blog_userFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Blog_userCountAggregateInputType | true
    }

  export interface blog_userDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['blog_user'], meta: { name: 'blog_user' } }
    /**
     * Find zero or one Blog_user that matches the filter.
     * @param {blog_userFindUniqueArgs} args - Arguments to find a Blog_user
     * @example
     * // Get one Blog_user
     * const blog_user = await prisma.blog_user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends blog_userFindUniqueArgs>(args: SelectSubset<T, blog_userFindUniqueArgs<ExtArgs>>): Prisma__blog_userClient<$Result.GetResult<Prisma.$blog_userPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Blog_user that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {blog_userFindUniqueOrThrowArgs} args - Arguments to find a Blog_user
     * @example
     * // Get one Blog_user
     * const blog_user = await prisma.blog_user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends blog_userFindUniqueOrThrowArgs>(args: SelectSubset<T, blog_userFindUniqueOrThrowArgs<ExtArgs>>): Prisma__blog_userClient<$Result.GetResult<Prisma.$blog_userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Blog_user that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {blog_userFindFirstArgs} args - Arguments to find a Blog_user
     * @example
     * // Get one Blog_user
     * const blog_user = await prisma.blog_user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends blog_userFindFirstArgs>(args?: SelectSubset<T, blog_userFindFirstArgs<ExtArgs>>): Prisma__blog_userClient<$Result.GetResult<Prisma.$blog_userPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Blog_user that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {blog_userFindFirstOrThrowArgs} args - Arguments to find a Blog_user
     * @example
     * // Get one Blog_user
     * const blog_user = await prisma.blog_user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends blog_userFindFirstOrThrowArgs>(args?: SelectSubset<T, blog_userFindFirstOrThrowArgs<ExtArgs>>): Prisma__blog_userClient<$Result.GetResult<Prisma.$blog_userPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Blog_users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {blog_userFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Blog_users
     * const blog_users = await prisma.blog_user.findMany()
     * 
     * // Get first 10 Blog_users
     * const blog_users = await prisma.blog_user.findMany({ take: 10 })
     * 
     * // Only select the `uid`
     * const blog_userWithUidOnly = await prisma.blog_user.findMany({ select: { uid: true } })
     * 
     */
    findMany<T extends blog_userFindManyArgs>(args?: SelectSubset<T, blog_userFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$blog_userPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Blog_user.
     * @param {blog_userCreateArgs} args - Arguments to create a Blog_user.
     * @example
     * // Create one Blog_user
     * const Blog_user = await prisma.blog_user.create({
     *   data: {
     *     // ... data to create a Blog_user
     *   }
     * })
     * 
     */
    create<T extends blog_userCreateArgs>(args: SelectSubset<T, blog_userCreateArgs<ExtArgs>>): Prisma__blog_userClient<$Result.GetResult<Prisma.$blog_userPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Blog_users.
     * @param {blog_userCreateManyArgs} args - Arguments to create many Blog_users.
     * @example
     * // Create many Blog_users
     * const blog_user = await prisma.blog_user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends blog_userCreateManyArgs>(args?: SelectSubset<T, blog_userCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Blog_user.
     * @param {blog_userDeleteArgs} args - Arguments to delete one Blog_user.
     * @example
     * // Delete one Blog_user
     * const Blog_user = await prisma.blog_user.delete({
     *   where: {
     *     // ... filter to delete one Blog_user
     *   }
     * })
     * 
     */
    delete<T extends blog_userDeleteArgs>(args: SelectSubset<T, blog_userDeleteArgs<ExtArgs>>): Prisma__blog_userClient<$Result.GetResult<Prisma.$blog_userPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Blog_user.
     * @param {blog_userUpdateArgs} args - Arguments to update one Blog_user.
     * @example
     * // Update one Blog_user
     * const blog_user = await prisma.blog_user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends blog_userUpdateArgs>(args: SelectSubset<T, blog_userUpdateArgs<ExtArgs>>): Prisma__blog_userClient<$Result.GetResult<Prisma.$blog_userPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Blog_users.
     * @param {blog_userDeleteManyArgs} args - Arguments to filter Blog_users to delete.
     * @example
     * // Delete a few Blog_users
     * const { count } = await prisma.blog_user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends blog_userDeleteManyArgs>(args?: SelectSubset<T, blog_userDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Blog_users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {blog_userUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Blog_users
     * const blog_user = await prisma.blog_user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends blog_userUpdateManyArgs>(args: SelectSubset<T, blog_userUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Blog_user.
     * @param {blog_userUpsertArgs} args - Arguments to update or create a Blog_user.
     * @example
     * // Update or create a Blog_user
     * const blog_user = await prisma.blog_user.upsert({
     *   create: {
     *     // ... data to create a Blog_user
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Blog_user we want to update
     *   }
     * })
     */
    upsert<T extends blog_userUpsertArgs>(args: SelectSubset<T, blog_userUpsertArgs<ExtArgs>>): Prisma__blog_userClient<$Result.GetResult<Prisma.$blog_userPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Blog_users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {blog_userCountArgs} args - Arguments to filter Blog_users to count.
     * @example
     * // Count the number of Blog_users
     * const count = await prisma.blog_user.count({
     *   where: {
     *     // ... the filter for the Blog_users we want to count
     *   }
     * })
    **/
    count<T extends blog_userCountArgs>(
      args?: Subset<T, blog_userCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Blog_userCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Blog_user.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Blog_userAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Blog_userAggregateArgs>(args: Subset<T, Blog_userAggregateArgs>): Prisma.PrismaPromise<GetBlog_userAggregateType<T>>

    /**
     * Group by Blog_user.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {blog_userGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends blog_userGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: blog_userGroupByArgs['orderBy'] }
        : { orderBy?: blog_userGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, blog_userGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBlog_userGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the blog_user model
   */
  readonly fields: blog_userFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for blog_user.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__blog_userClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    posts<T extends blog_user$postsArgs<ExtArgs> = {}>(args?: Subset<T, blog_user$postsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$blog_postsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the blog_user model
   */
  interface blog_userFieldRefs {
    readonly uid: FieldRef<"blog_user", 'String'>
    readonly createAt: FieldRef<"blog_user", 'DateTime'>
    readonly updateAt: FieldRef<"blog_user", 'DateTime'>
    readonly name: FieldRef<"blog_user", 'String'>
  }
    

  // Custom InputTypes
  /**
   * blog_user findUnique
   */
  export type blog_userFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blog_user
     */
    select?: blog_userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the blog_user
     */
    omit?: blog_userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: blog_userInclude<ExtArgs> | null
    /**
     * Filter, which blog_user to fetch.
     */
    where: blog_userWhereUniqueInput
  }

  /**
   * blog_user findUniqueOrThrow
   */
  export type blog_userFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blog_user
     */
    select?: blog_userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the blog_user
     */
    omit?: blog_userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: blog_userInclude<ExtArgs> | null
    /**
     * Filter, which blog_user to fetch.
     */
    where: blog_userWhereUniqueInput
  }

  /**
   * blog_user findFirst
   */
  export type blog_userFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blog_user
     */
    select?: blog_userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the blog_user
     */
    omit?: blog_userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: blog_userInclude<ExtArgs> | null
    /**
     * Filter, which blog_user to fetch.
     */
    where?: blog_userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of blog_users to fetch.
     */
    orderBy?: blog_userOrderByWithRelationInput | blog_userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for blog_users.
     */
    cursor?: blog_userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` blog_users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` blog_users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of blog_users.
     */
    distinct?: Blog_userScalarFieldEnum | Blog_userScalarFieldEnum[]
  }

  /**
   * blog_user findFirstOrThrow
   */
  export type blog_userFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blog_user
     */
    select?: blog_userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the blog_user
     */
    omit?: blog_userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: blog_userInclude<ExtArgs> | null
    /**
     * Filter, which blog_user to fetch.
     */
    where?: blog_userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of blog_users to fetch.
     */
    orderBy?: blog_userOrderByWithRelationInput | blog_userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for blog_users.
     */
    cursor?: blog_userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` blog_users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` blog_users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of blog_users.
     */
    distinct?: Blog_userScalarFieldEnum | Blog_userScalarFieldEnum[]
  }

  /**
   * blog_user findMany
   */
  export type blog_userFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blog_user
     */
    select?: blog_userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the blog_user
     */
    omit?: blog_userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: blog_userInclude<ExtArgs> | null
    /**
     * Filter, which blog_users to fetch.
     */
    where?: blog_userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of blog_users to fetch.
     */
    orderBy?: blog_userOrderByWithRelationInput | blog_userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing blog_users.
     */
    cursor?: blog_userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` blog_users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` blog_users.
     */
    skip?: number
    distinct?: Blog_userScalarFieldEnum | Blog_userScalarFieldEnum[]
  }

  /**
   * blog_user create
   */
  export type blog_userCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blog_user
     */
    select?: blog_userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the blog_user
     */
    omit?: blog_userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: blog_userInclude<ExtArgs> | null
    /**
     * The data needed to create a blog_user.
     */
    data: XOR<blog_userCreateInput, blog_userUncheckedCreateInput>
  }

  /**
   * blog_user createMany
   */
  export type blog_userCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many blog_users.
     */
    data: blog_userCreateManyInput | blog_userCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * blog_user update
   */
  export type blog_userUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blog_user
     */
    select?: blog_userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the blog_user
     */
    omit?: blog_userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: blog_userInclude<ExtArgs> | null
    /**
     * The data needed to update a blog_user.
     */
    data: XOR<blog_userUpdateInput, blog_userUncheckedUpdateInput>
    /**
     * Choose, which blog_user to update.
     */
    where: blog_userWhereUniqueInput
  }

  /**
   * blog_user updateMany
   */
  export type blog_userUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update blog_users.
     */
    data: XOR<blog_userUpdateManyMutationInput, blog_userUncheckedUpdateManyInput>
    /**
     * Filter which blog_users to update
     */
    where?: blog_userWhereInput
    /**
     * Limit how many blog_users to update.
     */
    limit?: number
  }

  /**
   * blog_user upsert
   */
  export type blog_userUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blog_user
     */
    select?: blog_userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the blog_user
     */
    omit?: blog_userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: blog_userInclude<ExtArgs> | null
    /**
     * The filter to search for the blog_user to update in case it exists.
     */
    where: blog_userWhereUniqueInput
    /**
     * In case the blog_user found by the `where` argument doesn't exist, create a new blog_user with this data.
     */
    create: XOR<blog_userCreateInput, blog_userUncheckedCreateInput>
    /**
     * In case the blog_user was found with the provided `where` argument, update it with this data.
     */
    update: XOR<blog_userUpdateInput, blog_userUncheckedUpdateInput>
  }

  /**
   * blog_user delete
   */
  export type blog_userDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blog_user
     */
    select?: blog_userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the blog_user
     */
    omit?: blog_userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: blog_userInclude<ExtArgs> | null
    /**
     * Filter which blog_user to delete.
     */
    where: blog_userWhereUniqueInput
  }

  /**
   * blog_user deleteMany
   */
  export type blog_userDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which blog_users to delete
     */
    where?: blog_userWhereInput
    /**
     * Limit how many blog_users to delete.
     */
    limit?: number
  }

  /**
   * blog_user.posts
   */
  export type blog_user$postsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blog_posts
     */
    select?: blog_postsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the blog_posts
     */
    omit?: blog_postsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: blog_postsInclude<ExtArgs> | null
    where?: blog_postsWhereInput
    orderBy?: blog_postsOrderByWithRelationInput | blog_postsOrderByWithRelationInput[]
    cursor?: blog_postsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Blog_postsScalarFieldEnum | Blog_postsScalarFieldEnum[]
  }

  /**
   * blog_user without action
   */
  export type blog_userDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blog_user
     */
    select?: blog_userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the blog_user
     */
    omit?: blog_userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: blog_userInclude<ExtArgs> | null
  }


  /**
   * Model blog_categories
   */

  export type AggregateBlog_categories = {
    _count: Blog_categoriesCountAggregateOutputType | null
    _min: Blog_categoriesMinAggregateOutputType | null
    _max: Blog_categoriesMaxAggregateOutputType | null
  }

  export type Blog_categoriesMinAggregateOutputType = {
    uid: string | null
    createAt: Date | null
    updateAt: Date | null
    name: string | null
  }

  export type Blog_categoriesMaxAggregateOutputType = {
    uid: string | null
    createAt: Date | null
    updateAt: Date | null
    name: string | null
  }

  export type Blog_categoriesCountAggregateOutputType = {
    uid: number
    createAt: number
    updateAt: number
    name: number
    _all: number
  }


  export type Blog_categoriesMinAggregateInputType = {
    uid?: true
    createAt?: true
    updateAt?: true
    name?: true
  }

  export type Blog_categoriesMaxAggregateInputType = {
    uid?: true
    createAt?: true
    updateAt?: true
    name?: true
  }

  export type Blog_categoriesCountAggregateInputType = {
    uid?: true
    createAt?: true
    updateAt?: true
    name?: true
    _all?: true
  }

  export type Blog_categoriesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which blog_categories to aggregate.
     */
    where?: blog_categoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of blog_categories to fetch.
     */
    orderBy?: blog_categoriesOrderByWithRelationInput | blog_categoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: blog_categoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` blog_categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` blog_categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned blog_categories
    **/
    _count?: true | Blog_categoriesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Blog_categoriesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Blog_categoriesMaxAggregateInputType
  }

  export type GetBlog_categoriesAggregateType<T extends Blog_categoriesAggregateArgs> = {
        [P in keyof T & keyof AggregateBlog_categories]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBlog_categories[P]>
      : GetScalarType<T[P], AggregateBlog_categories[P]>
  }




  export type blog_categoriesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: blog_categoriesWhereInput
    orderBy?: blog_categoriesOrderByWithAggregationInput | blog_categoriesOrderByWithAggregationInput[]
    by: Blog_categoriesScalarFieldEnum[] | Blog_categoriesScalarFieldEnum
    having?: blog_categoriesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Blog_categoriesCountAggregateInputType | true
    _min?: Blog_categoriesMinAggregateInputType
    _max?: Blog_categoriesMaxAggregateInputType
  }

  export type Blog_categoriesGroupByOutputType = {
    uid: string
    createAt: Date
    updateAt: Date
    name: string
    _count: Blog_categoriesCountAggregateOutputType | null
    _min: Blog_categoriesMinAggregateOutputType | null
    _max: Blog_categoriesMaxAggregateOutputType | null
  }

  type GetBlog_categoriesGroupByPayload<T extends blog_categoriesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Blog_categoriesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Blog_categoriesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Blog_categoriesGroupByOutputType[P]>
            : GetScalarType<T[P], Blog_categoriesGroupByOutputType[P]>
        }
      >
    >


  export type blog_categoriesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    uid?: boolean
    createAt?: boolean
    updateAt?: boolean
    name?: boolean
    posts?: boolean | blog_categories$postsArgs<ExtArgs>
    _count?: boolean | Blog_categoriesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["blog_categories"]>



  export type blog_categoriesSelectScalar = {
    uid?: boolean
    createAt?: boolean
    updateAt?: boolean
    name?: boolean
  }

  export type blog_categoriesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"uid" | "createAt" | "updateAt" | "name", ExtArgs["result"]["blog_categories"]>
  export type blog_categoriesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    posts?: boolean | blog_categories$postsArgs<ExtArgs>
    _count?: boolean | Blog_categoriesCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $blog_categoriesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "blog_categories"
    objects: {
      posts: Prisma.$blog_postsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      uid: string
      createAt: Date
      updateAt: Date
      name: string
    }, ExtArgs["result"]["blog_categories"]>
    composites: {}
  }

  type blog_categoriesGetPayload<S extends boolean | null | undefined | blog_categoriesDefaultArgs> = $Result.GetResult<Prisma.$blog_categoriesPayload, S>

  type blog_categoriesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<blog_categoriesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Blog_categoriesCountAggregateInputType | true
    }

  export interface blog_categoriesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['blog_categories'], meta: { name: 'blog_categories' } }
    /**
     * Find zero or one Blog_categories that matches the filter.
     * @param {blog_categoriesFindUniqueArgs} args - Arguments to find a Blog_categories
     * @example
     * // Get one Blog_categories
     * const blog_categories = await prisma.blog_categories.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends blog_categoriesFindUniqueArgs>(args: SelectSubset<T, blog_categoriesFindUniqueArgs<ExtArgs>>): Prisma__blog_categoriesClient<$Result.GetResult<Prisma.$blog_categoriesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Blog_categories that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {blog_categoriesFindUniqueOrThrowArgs} args - Arguments to find a Blog_categories
     * @example
     * // Get one Blog_categories
     * const blog_categories = await prisma.blog_categories.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends blog_categoriesFindUniqueOrThrowArgs>(args: SelectSubset<T, blog_categoriesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__blog_categoriesClient<$Result.GetResult<Prisma.$blog_categoriesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Blog_categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {blog_categoriesFindFirstArgs} args - Arguments to find a Blog_categories
     * @example
     * // Get one Blog_categories
     * const blog_categories = await prisma.blog_categories.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends blog_categoriesFindFirstArgs>(args?: SelectSubset<T, blog_categoriesFindFirstArgs<ExtArgs>>): Prisma__blog_categoriesClient<$Result.GetResult<Prisma.$blog_categoriesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Blog_categories that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {blog_categoriesFindFirstOrThrowArgs} args - Arguments to find a Blog_categories
     * @example
     * // Get one Blog_categories
     * const blog_categories = await prisma.blog_categories.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends blog_categoriesFindFirstOrThrowArgs>(args?: SelectSubset<T, blog_categoriesFindFirstOrThrowArgs<ExtArgs>>): Prisma__blog_categoriesClient<$Result.GetResult<Prisma.$blog_categoriesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Blog_categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {blog_categoriesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Blog_categories
     * const blog_categories = await prisma.blog_categories.findMany()
     * 
     * // Get first 10 Blog_categories
     * const blog_categories = await prisma.blog_categories.findMany({ take: 10 })
     * 
     * // Only select the `uid`
     * const blog_categoriesWithUidOnly = await prisma.blog_categories.findMany({ select: { uid: true } })
     * 
     */
    findMany<T extends blog_categoriesFindManyArgs>(args?: SelectSubset<T, blog_categoriesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$blog_categoriesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Blog_categories.
     * @param {blog_categoriesCreateArgs} args - Arguments to create a Blog_categories.
     * @example
     * // Create one Blog_categories
     * const Blog_categories = await prisma.blog_categories.create({
     *   data: {
     *     // ... data to create a Blog_categories
     *   }
     * })
     * 
     */
    create<T extends blog_categoriesCreateArgs>(args: SelectSubset<T, blog_categoriesCreateArgs<ExtArgs>>): Prisma__blog_categoriesClient<$Result.GetResult<Prisma.$blog_categoriesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Blog_categories.
     * @param {blog_categoriesCreateManyArgs} args - Arguments to create many Blog_categories.
     * @example
     * // Create many Blog_categories
     * const blog_categories = await prisma.blog_categories.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends blog_categoriesCreateManyArgs>(args?: SelectSubset<T, blog_categoriesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Blog_categories.
     * @param {blog_categoriesDeleteArgs} args - Arguments to delete one Blog_categories.
     * @example
     * // Delete one Blog_categories
     * const Blog_categories = await prisma.blog_categories.delete({
     *   where: {
     *     // ... filter to delete one Blog_categories
     *   }
     * })
     * 
     */
    delete<T extends blog_categoriesDeleteArgs>(args: SelectSubset<T, blog_categoriesDeleteArgs<ExtArgs>>): Prisma__blog_categoriesClient<$Result.GetResult<Prisma.$blog_categoriesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Blog_categories.
     * @param {blog_categoriesUpdateArgs} args - Arguments to update one Blog_categories.
     * @example
     * // Update one Blog_categories
     * const blog_categories = await prisma.blog_categories.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends blog_categoriesUpdateArgs>(args: SelectSubset<T, blog_categoriesUpdateArgs<ExtArgs>>): Prisma__blog_categoriesClient<$Result.GetResult<Prisma.$blog_categoriesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Blog_categories.
     * @param {blog_categoriesDeleteManyArgs} args - Arguments to filter Blog_categories to delete.
     * @example
     * // Delete a few Blog_categories
     * const { count } = await prisma.blog_categories.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends blog_categoriesDeleteManyArgs>(args?: SelectSubset<T, blog_categoriesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Blog_categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {blog_categoriesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Blog_categories
     * const blog_categories = await prisma.blog_categories.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends blog_categoriesUpdateManyArgs>(args: SelectSubset<T, blog_categoriesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Blog_categories.
     * @param {blog_categoriesUpsertArgs} args - Arguments to update or create a Blog_categories.
     * @example
     * // Update or create a Blog_categories
     * const blog_categories = await prisma.blog_categories.upsert({
     *   create: {
     *     // ... data to create a Blog_categories
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Blog_categories we want to update
     *   }
     * })
     */
    upsert<T extends blog_categoriesUpsertArgs>(args: SelectSubset<T, blog_categoriesUpsertArgs<ExtArgs>>): Prisma__blog_categoriesClient<$Result.GetResult<Prisma.$blog_categoriesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Blog_categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {blog_categoriesCountArgs} args - Arguments to filter Blog_categories to count.
     * @example
     * // Count the number of Blog_categories
     * const count = await prisma.blog_categories.count({
     *   where: {
     *     // ... the filter for the Blog_categories we want to count
     *   }
     * })
    **/
    count<T extends blog_categoriesCountArgs>(
      args?: Subset<T, blog_categoriesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Blog_categoriesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Blog_categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Blog_categoriesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Blog_categoriesAggregateArgs>(args: Subset<T, Blog_categoriesAggregateArgs>): Prisma.PrismaPromise<GetBlog_categoriesAggregateType<T>>

    /**
     * Group by Blog_categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {blog_categoriesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends blog_categoriesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: blog_categoriesGroupByArgs['orderBy'] }
        : { orderBy?: blog_categoriesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, blog_categoriesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBlog_categoriesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the blog_categories model
   */
  readonly fields: blog_categoriesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for blog_categories.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__blog_categoriesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    posts<T extends blog_categories$postsArgs<ExtArgs> = {}>(args?: Subset<T, blog_categories$postsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$blog_postsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the blog_categories model
   */
  interface blog_categoriesFieldRefs {
    readonly uid: FieldRef<"blog_categories", 'String'>
    readonly createAt: FieldRef<"blog_categories", 'DateTime'>
    readonly updateAt: FieldRef<"blog_categories", 'DateTime'>
    readonly name: FieldRef<"blog_categories", 'String'>
  }
    

  // Custom InputTypes
  /**
   * blog_categories findUnique
   */
  export type blog_categoriesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blog_categories
     */
    select?: blog_categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the blog_categories
     */
    omit?: blog_categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: blog_categoriesInclude<ExtArgs> | null
    /**
     * Filter, which blog_categories to fetch.
     */
    where: blog_categoriesWhereUniqueInput
  }

  /**
   * blog_categories findUniqueOrThrow
   */
  export type blog_categoriesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blog_categories
     */
    select?: blog_categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the blog_categories
     */
    omit?: blog_categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: blog_categoriesInclude<ExtArgs> | null
    /**
     * Filter, which blog_categories to fetch.
     */
    where: blog_categoriesWhereUniqueInput
  }

  /**
   * blog_categories findFirst
   */
  export type blog_categoriesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blog_categories
     */
    select?: blog_categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the blog_categories
     */
    omit?: blog_categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: blog_categoriesInclude<ExtArgs> | null
    /**
     * Filter, which blog_categories to fetch.
     */
    where?: blog_categoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of blog_categories to fetch.
     */
    orderBy?: blog_categoriesOrderByWithRelationInput | blog_categoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for blog_categories.
     */
    cursor?: blog_categoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` blog_categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` blog_categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of blog_categories.
     */
    distinct?: Blog_categoriesScalarFieldEnum | Blog_categoriesScalarFieldEnum[]
  }

  /**
   * blog_categories findFirstOrThrow
   */
  export type blog_categoriesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blog_categories
     */
    select?: blog_categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the blog_categories
     */
    omit?: blog_categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: blog_categoriesInclude<ExtArgs> | null
    /**
     * Filter, which blog_categories to fetch.
     */
    where?: blog_categoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of blog_categories to fetch.
     */
    orderBy?: blog_categoriesOrderByWithRelationInput | blog_categoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for blog_categories.
     */
    cursor?: blog_categoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` blog_categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` blog_categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of blog_categories.
     */
    distinct?: Blog_categoriesScalarFieldEnum | Blog_categoriesScalarFieldEnum[]
  }

  /**
   * blog_categories findMany
   */
  export type blog_categoriesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blog_categories
     */
    select?: blog_categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the blog_categories
     */
    omit?: blog_categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: blog_categoriesInclude<ExtArgs> | null
    /**
     * Filter, which blog_categories to fetch.
     */
    where?: blog_categoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of blog_categories to fetch.
     */
    orderBy?: blog_categoriesOrderByWithRelationInput | blog_categoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing blog_categories.
     */
    cursor?: blog_categoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` blog_categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` blog_categories.
     */
    skip?: number
    distinct?: Blog_categoriesScalarFieldEnum | Blog_categoriesScalarFieldEnum[]
  }

  /**
   * blog_categories create
   */
  export type blog_categoriesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blog_categories
     */
    select?: blog_categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the blog_categories
     */
    omit?: blog_categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: blog_categoriesInclude<ExtArgs> | null
    /**
     * The data needed to create a blog_categories.
     */
    data: XOR<blog_categoriesCreateInput, blog_categoriesUncheckedCreateInput>
  }

  /**
   * blog_categories createMany
   */
  export type blog_categoriesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many blog_categories.
     */
    data: blog_categoriesCreateManyInput | blog_categoriesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * blog_categories update
   */
  export type blog_categoriesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blog_categories
     */
    select?: blog_categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the blog_categories
     */
    omit?: blog_categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: blog_categoriesInclude<ExtArgs> | null
    /**
     * The data needed to update a blog_categories.
     */
    data: XOR<blog_categoriesUpdateInput, blog_categoriesUncheckedUpdateInput>
    /**
     * Choose, which blog_categories to update.
     */
    where: blog_categoriesWhereUniqueInput
  }

  /**
   * blog_categories updateMany
   */
  export type blog_categoriesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update blog_categories.
     */
    data: XOR<blog_categoriesUpdateManyMutationInput, blog_categoriesUncheckedUpdateManyInput>
    /**
     * Filter which blog_categories to update
     */
    where?: blog_categoriesWhereInput
    /**
     * Limit how many blog_categories to update.
     */
    limit?: number
  }

  /**
   * blog_categories upsert
   */
  export type blog_categoriesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blog_categories
     */
    select?: blog_categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the blog_categories
     */
    omit?: blog_categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: blog_categoriesInclude<ExtArgs> | null
    /**
     * The filter to search for the blog_categories to update in case it exists.
     */
    where: blog_categoriesWhereUniqueInput
    /**
     * In case the blog_categories found by the `where` argument doesn't exist, create a new blog_categories with this data.
     */
    create: XOR<blog_categoriesCreateInput, blog_categoriesUncheckedCreateInput>
    /**
     * In case the blog_categories was found with the provided `where` argument, update it with this data.
     */
    update: XOR<blog_categoriesUpdateInput, blog_categoriesUncheckedUpdateInput>
  }

  /**
   * blog_categories delete
   */
  export type blog_categoriesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blog_categories
     */
    select?: blog_categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the blog_categories
     */
    omit?: blog_categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: blog_categoriesInclude<ExtArgs> | null
    /**
     * Filter which blog_categories to delete.
     */
    where: blog_categoriesWhereUniqueInput
  }

  /**
   * blog_categories deleteMany
   */
  export type blog_categoriesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which blog_categories to delete
     */
    where?: blog_categoriesWhereInput
    /**
     * Limit how many blog_categories to delete.
     */
    limit?: number
  }

  /**
   * blog_categories.posts
   */
  export type blog_categories$postsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blog_posts
     */
    select?: blog_postsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the blog_posts
     */
    omit?: blog_postsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: blog_postsInclude<ExtArgs> | null
    where?: blog_postsWhereInput
    orderBy?: blog_postsOrderByWithRelationInput | blog_postsOrderByWithRelationInput[]
    cursor?: blog_postsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Blog_postsScalarFieldEnum | Blog_postsScalarFieldEnum[]
  }

  /**
   * blog_categories without action
   */
  export type blog_categoriesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blog_categories
     */
    select?: blog_categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the blog_categories
     */
    omit?: blog_categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: blog_categoriesInclude<ExtArgs> | null
  }


  /**
   * Model blog_posts
   */

  export type AggregateBlog_posts = {
    _count: Blog_postsCountAggregateOutputType | null
    _min: Blog_postsMinAggregateOutputType | null
    _max: Blog_postsMaxAggregateOutputType | null
  }

  export type Blog_postsMinAggregateOutputType = {
    uid: string | null
    createAt: Date | null
    updateAt: Date | null
    title: string | null
    content: string | null
    userId: string | null
    categoriesId: string | null
  }

  export type Blog_postsMaxAggregateOutputType = {
    uid: string | null
    createAt: Date | null
    updateAt: Date | null
    title: string | null
    content: string | null
    userId: string | null
    categoriesId: string | null
  }

  export type Blog_postsCountAggregateOutputType = {
    uid: number
    createAt: number
    updateAt: number
    title: number
    content: number
    userId: number
    categoriesId: number
    _all: number
  }


  export type Blog_postsMinAggregateInputType = {
    uid?: true
    createAt?: true
    updateAt?: true
    title?: true
    content?: true
    userId?: true
    categoriesId?: true
  }

  export type Blog_postsMaxAggregateInputType = {
    uid?: true
    createAt?: true
    updateAt?: true
    title?: true
    content?: true
    userId?: true
    categoriesId?: true
  }

  export type Blog_postsCountAggregateInputType = {
    uid?: true
    createAt?: true
    updateAt?: true
    title?: true
    content?: true
    userId?: true
    categoriesId?: true
    _all?: true
  }

  export type Blog_postsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which blog_posts to aggregate.
     */
    where?: blog_postsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of blog_posts to fetch.
     */
    orderBy?: blog_postsOrderByWithRelationInput | blog_postsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: blog_postsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` blog_posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` blog_posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned blog_posts
    **/
    _count?: true | Blog_postsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Blog_postsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Blog_postsMaxAggregateInputType
  }

  export type GetBlog_postsAggregateType<T extends Blog_postsAggregateArgs> = {
        [P in keyof T & keyof AggregateBlog_posts]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBlog_posts[P]>
      : GetScalarType<T[P], AggregateBlog_posts[P]>
  }




  export type blog_postsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: blog_postsWhereInput
    orderBy?: blog_postsOrderByWithAggregationInput | blog_postsOrderByWithAggregationInput[]
    by: Blog_postsScalarFieldEnum[] | Blog_postsScalarFieldEnum
    having?: blog_postsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Blog_postsCountAggregateInputType | true
    _min?: Blog_postsMinAggregateInputType
    _max?: Blog_postsMaxAggregateInputType
  }

  export type Blog_postsGroupByOutputType = {
    uid: string
    createAt: Date
    updateAt: Date
    title: string
    content: string
    userId: string
    categoriesId: string | null
    _count: Blog_postsCountAggregateOutputType | null
    _min: Blog_postsMinAggregateOutputType | null
    _max: Blog_postsMaxAggregateOutputType | null
  }

  type GetBlog_postsGroupByPayload<T extends blog_postsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Blog_postsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Blog_postsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Blog_postsGroupByOutputType[P]>
            : GetScalarType<T[P], Blog_postsGroupByOutputType[P]>
        }
      >
    >


  export type blog_postsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    uid?: boolean
    createAt?: boolean
    updateAt?: boolean
    title?: boolean
    content?: boolean
    userId?: boolean
    categoriesId?: boolean
    categories?: boolean | blog_posts$categoriesArgs<ExtArgs>
    user?: boolean | blog_userDefaultArgs<ExtArgs>
    tags?: boolean | blog_posts$tagsArgs<ExtArgs>
    _count?: boolean | Blog_postsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["blog_posts"]>



  export type blog_postsSelectScalar = {
    uid?: boolean
    createAt?: boolean
    updateAt?: boolean
    title?: boolean
    content?: boolean
    userId?: boolean
    categoriesId?: boolean
  }

  export type blog_postsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"uid" | "createAt" | "updateAt" | "title" | "content" | "userId" | "categoriesId", ExtArgs["result"]["blog_posts"]>
  export type blog_postsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    categories?: boolean | blog_posts$categoriesArgs<ExtArgs>
    user?: boolean | blog_userDefaultArgs<ExtArgs>
    tags?: boolean | blog_posts$tagsArgs<ExtArgs>
    _count?: boolean | Blog_postsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $blog_postsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "blog_posts"
    objects: {
      categories: Prisma.$blog_categoriesPayload<ExtArgs> | null
      user: Prisma.$blog_userPayload<ExtArgs>
      tags: Prisma.$blog_posts_on_tagsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      uid: string
      createAt: Date
      updateAt: Date
      title: string
      content: string
      userId: string
      categoriesId: string | null
    }, ExtArgs["result"]["blog_posts"]>
    composites: {}
  }

  type blog_postsGetPayload<S extends boolean | null | undefined | blog_postsDefaultArgs> = $Result.GetResult<Prisma.$blog_postsPayload, S>

  type blog_postsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<blog_postsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Blog_postsCountAggregateInputType | true
    }

  export interface blog_postsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['blog_posts'], meta: { name: 'blog_posts' } }
    /**
     * Find zero or one Blog_posts that matches the filter.
     * @param {blog_postsFindUniqueArgs} args - Arguments to find a Blog_posts
     * @example
     * // Get one Blog_posts
     * const blog_posts = await prisma.blog_posts.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends blog_postsFindUniqueArgs>(args: SelectSubset<T, blog_postsFindUniqueArgs<ExtArgs>>): Prisma__blog_postsClient<$Result.GetResult<Prisma.$blog_postsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Blog_posts that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {blog_postsFindUniqueOrThrowArgs} args - Arguments to find a Blog_posts
     * @example
     * // Get one Blog_posts
     * const blog_posts = await prisma.blog_posts.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends blog_postsFindUniqueOrThrowArgs>(args: SelectSubset<T, blog_postsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__blog_postsClient<$Result.GetResult<Prisma.$blog_postsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Blog_posts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {blog_postsFindFirstArgs} args - Arguments to find a Blog_posts
     * @example
     * // Get one Blog_posts
     * const blog_posts = await prisma.blog_posts.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends blog_postsFindFirstArgs>(args?: SelectSubset<T, blog_postsFindFirstArgs<ExtArgs>>): Prisma__blog_postsClient<$Result.GetResult<Prisma.$blog_postsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Blog_posts that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {blog_postsFindFirstOrThrowArgs} args - Arguments to find a Blog_posts
     * @example
     * // Get one Blog_posts
     * const blog_posts = await prisma.blog_posts.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends blog_postsFindFirstOrThrowArgs>(args?: SelectSubset<T, blog_postsFindFirstOrThrowArgs<ExtArgs>>): Prisma__blog_postsClient<$Result.GetResult<Prisma.$blog_postsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Blog_posts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {blog_postsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Blog_posts
     * const blog_posts = await prisma.blog_posts.findMany()
     * 
     * // Get first 10 Blog_posts
     * const blog_posts = await prisma.blog_posts.findMany({ take: 10 })
     * 
     * // Only select the `uid`
     * const blog_postsWithUidOnly = await prisma.blog_posts.findMany({ select: { uid: true } })
     * 
     */
    findMany<T extends blog_postsFindManyArgs>(args?: SelectSubset<T, blog_postsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$blog_postsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Blog_posts.
     * @param {blog_postsCreateArgs} args - Arguments to create a Blog_posts.
     * @example
     * // Create one Blog_posts
     * const Blog_posts = await prisma.blog_posts.create({
     *   data: {
     *     // ... data to create a Blog_posts
     *   }
     * })
     * 
     */
    create<T extends blog_postsCreateArgs>(args: SelectSubset<T, blog_postsCreateArgs<ExtArgs>>): Prisma__blog_postsClient<$Result.GetResult<Prisma.$blog_postsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Blog_posts.
     * @param {blog_postsCreateManyArgs} args - Arguments to create many Blog_posts.
     * @example
     * // Create many Blog_posts
     * const blog_posts = await prisma.blog_posts.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends blog_postsCreateManyArgs>(args?: SelectSubset<T, blog_postsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Blog_posts.
     * @param {blog_postsDeleteArgs} args - Arguments to delete one Blog_posts.
     * @example
     * // Delete one Blog_posts
     * const Blog_posts = await prisma.blog_posts.delete({
     *   where: {
     *     // ... filter to delete one Blog_posts
     *   }
     * })
     * 
     */
    delete<T extends blog_postsDeleteArgs>(args: SelectSubset<T, blog_postsDeleteArgs<ExtArgs>>): Prisma__blog_postsClient<$Result.GetResult<Prisma.$blog_postsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Blog_posts.
     * @param {blog_postsUpdateArgs} args - Arguments to update one Blog_posts.
     * @example
     * // Update one Blog_posts
     * const blog_posts = await prisma.blog_posts.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends blog_postsUpdateArgs>(args: SelectSubset<T, blog_postsUpdateArgs<ExtArgs>>): Prisma__blog_postsClient<$Result.GetResult<Prisma.$blog_postsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Blog_posts.
     * @param {blog_postsDeleteManyArgs} args - Arguments to filter Blog_posts to delete.
     * @example
     * // Delete a few Blog_posts
     * const { count } = await prisma.blog_posts.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends blog_postsDeleteManyArgs>(args?: SelectSubset<T, blog_postsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Blog_posts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {blog_postsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Blog_posts
     * const blog_posts = await prisma.blog_posts.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends blog_postsUpdateManyArgs>(args: SelectSubset<T, blog_postsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Blog_posts.
     * @param {blog_postsUpsertArgs} args - Arguments to update or create a Blog_posts.
     * @example
     * // Update or create a Blog_posts
     * const blog_posts = await prisma.blog_posts.upsert({
     *   create: {
     *     // ... data to create a Blog_posts
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Blog_posts we want to update
     *   }
     * })
     */
    upsert<T extends blog_postsUpsertArgs>(args: SelectSubset<T, blog_postsUpsertArgs<ExtArgs>>): Prisma__blog_postsClient<$Result.GetResult<Prisma.$blog_postsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Blog_posts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {blog_postsCountArgs} args - Arguments to filter Blog_posts to count.
     * @example
     * // Count the number of Blog_posts
     * const count = await prisma.blog_posts.count({
     *   where: {
     *     // ... the filter for the Blog_posts we want to count
     *   }
     * })
    **/
    count<T extends blog_postsCountArgs>(
      args?: Subset<T, blog_postsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Blog_postsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Blog_posts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Blog_postsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Blog_postsAggregateArgs>(args: Subset<T, Blog_postsAggregateArgs>): Prisma.PrismaPromise<GetBlog_postsAggregateType<T>>

    /**
     * Group by Blog_posts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {blog_postsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends blog_postsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: blog_postsGroupByArgs['orderBy'] }
        : { orderBy?: blog_postsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, blog_postsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBlog_postsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the blog_posts model
   */
  readonly fields: blog_postsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for blog_posts.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__blog_postsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    categories<T extends blog_posts$categoriesArgs<ExtArgs> = {}>(args?: Subset<T, blog_posts$categoriesArgs<ExtArgs>>): Prisma__blog_categoriesClient<$Result.GetResult<Prisma.$blog_categoriesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    user<T extends blog_userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, blog_userDefaultArgs<ExtArgs>>): Prisma__blog_userClient<$Result.GetResult<Prisma.$blog_userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tags<T extends blog_posts$tagsArgs<ExtArgs> = {}>(args?: Subset<T, blog_posts$tagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$blog_posts_on_tagsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the blog_posts model
   */
  interface blog_postsFieldRefs {
    readonly uid: FieldRef<"blog_posts", 'String'>
    readonly createAt: FieldRef<"blog_posts", 'DateTime'>
    readonly updateAt: FieldRef<"blog_posts", 'DateTime'>
    readonly title: FieldRef<"blog_posts", 'String'>
    readonly content: FieldRef<"blog_posts", 'String'>
    readonly userId: FieldRef<"blog_posts", 'String'>
    readonly categoriesId: FieldRef<"blog_posts", 'String'>
  }
    

  // Custom InputTypes
  /**
   * blog_posts findUnique
   */
  export type blog_postsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blog_posts
     */
    select?: blog_postsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the blog_posts
     */
    omit?: blog_postsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: blog_postsInclude<ExtArgs> | null
    /**
     * Filter, which blog_posts to fetch.
     */
    where: blog_postsWhereUniqueInput
  }

  /**
   * blog_posts findUniqueOrThrow
   */
  export type blog_postsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blog_posts
     */
    select?: blog_postsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the blog_posts
     */
    omit?: blog_postsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: blog_postsInclude<ExtArgs> | null
    /**
     * Filter, which blog_posts to fetch.
     */
    where: blog_postsWhereUniqueInput
  }

  /**
   * blog_posts findFirst
   */
  export type blog_postsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blog_posts
     */
    select?: blog_postsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the blog_posts
     */
    omit?: blog_postsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: blog_postsInclude<ExtArgs> | null
    /**
     * Filter, which blog_posts to fetch.
     */
    where?: blog_postsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of blog_posts to fetch.
     */
    orderBy?: blog_postsOrderByWithRelationInput | blog_postsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for blog_posts.
     */
    cursor?: blog_postsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` blog_posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` blog_posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of blog_posts.
     */
    distinct?: Blog_postsScalarFieldEnum | Blog_postsScalarFieldEnum[]
  }

  /**
   * blog_posts findFirstOrThrow
   */
  export type blog_postsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blog_posts
     */
    select?: blog_postsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the blog_posts
     */
    omit?: blog_postsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: blog_postsInclude<ExtArgs> | null
    /**
     * Filter, which blog_posts to fetch.
     */
    where?: blog_postsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of blog_posts to fetch.
     */
    orderBy?: blog_postsOrderByWithRelationInput | blog_postsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for blog_posts.
     */
    cursor?: blog_postsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` blog_posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` blog_posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of blog_posts.
     */
    distinct?: Blog_postsScalarFieldEnum | Blog_postsScalarFieldEnum[]
  }

  /**
   * blog_posts findMany
   */
  export type blog_postsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blog_posts
     */
    select?: blog_postsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the blog_posts
     */
    omit?: blog_postsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: blog_postsInclude<ExtArgs> | null
    /**
     * Filter, which blog_posts to fetch.
     */
    where?: blog_postsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of blog_posts to fetch.
     */
    orderBy?: blog_postsOrderByWithRelationInput | blog_postsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing blog_posts.
     */
    cursor?: blog_postsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` blog_posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` blog_posts.
     */
    skip?: number
    distinct?: Blog_postsScalarFieldEnum | Blog_postsScalarFieldEnum[]
  }

  /**
   * blog_posts create
   */
  export type blog_postsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blog_posts
     */
    select?: blog_postsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the blog_posts
     */
    omit?: blog_postsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: blog_postsInclude<ExtArgs> | null
    /**
     * The data needed to create a blog_posts.
     */
    data: XOR<blog_postsCreateInput, blog_postsUncheckedCreateInput>
  }

  /**
   * blog_posts createMany
   */
  export type blog_postsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many blog_posts.
     */
    data: blog_postsCreateManyInput | blog_postsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * blog_posts update
   */
  export type blog_postsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blog_posts
     */
    select?: blog_postsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the blog_posts
     */
    omit?: blog_postsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: blog_postsInclude<ExtArgs> | null
    /**
     * The data needed to update a blog_posts.
     */
    data: XOR<blog_postsUpdateInput, blog_postsUncheckedUpdateInput>
    /**
     * Choose, which blog_posts to update.
     */
    where: blog_postsWhereUniqueInput
  }

  /**
   * blog_posts updateMany
   */
  export type blog_postsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update blog_posts.
     */
    data: XOR<blog_postsUpdateManyMutationInput, blog_postsUncheckedUpdateManyInput>
    /**
     * Filter which blog_posts to update
     */
    where?: blog_postsWhereInput
    /**
     * Limit how many blog_posts to update.
     */
    limit?: number
  }

  /**
   * blog_posts upsert
   */
  export type blog_postsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blog_posts
     */
    select?: blog_postsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the blog_posts
     */
    omit?: blog_postsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: blog_postsInclude<ExtArgs> | null
    /**
     * The filter to search for the blog_posts to update in case it exists.
     */
    where: blog_postsWhereUniqueInput
    /**
     * In case the blog_posts found by the `where` argument doesn't exist, create a new blog_posts with this data.
     */
    create: XOR<blog_postsCreateInput, blog_postsUncheckedCreateInput>
    /**
     * In case the blog_posts was found with the provided `where` argument, update it with this data.
     */
    update: XOR<blog_postsUpdateInput, blog_postsUncheckedUpdateInput>
  }

  /**
   * blog_posts delete
   */
  export type blog_postsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blog_posts
     */
    select?: blog_postsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the blog_posts
     */
    omit?: blog_postsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: blog_postsInclude<ExtArgs> | null
    /**
     * Filter which blog_posts to delete.
     */
    where: blog_postsWhereUniqueInput
  }

  /**
   * blog_posts deleteMany
   */
  export type blog_postsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which blog_posts to delete
     */
    where?: blog_postsWhereInput
    /**
     * Limit how many blog_posts to delete.
     */
    limit?: number
  }

  /**
   * blog_posts.categories
   */
  export type blog_posts$categoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blog_categories
     */
    select?: blog_categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the blog_categories
     */
    omit?: blog_categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: blog_categoriesInclude<ExtArgs> | null
    where?: blog_categoriesWhereInput
  }

  /**
   * blog_posts.tags
   */
  export type blog_posts$tagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blog_posts_on_tags
     */
    select?: blog_posts_on_tagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the blog_posts_on_tags
     */
    omit?: blog_posts_on_tagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: blog_posts_on_tagsInclude<ExtArgs> | null
    where?: blog_posts_on_tagsWhereInput
    orderBy?: blog_posts_on_tagsOrderByWithRelationInput | blog_posts_on_tagsOrderByWithRelationInput[]
    cursor?: blog_posts_on_tagsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Blog_posts_on_tagsScalarFieldEnum | Blog_posts_on_tagsScalarFieldEnum[]
  }

  /**
   * blog_posts without action
   */
  export type blog_postsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blog_posts
     */
    select?: blog_postsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the blog_posts
     */
    omit?: blog_postsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: blog_postsInclude<ExtArgs> | null
  }


  /**
   * Model blog_notice
   */

  export type AggregateBlog_notice = {
    _count: Blog_noticeCountAggregateOutputType | null
    _min: Blog_noticeMinAggregateOutputType | null
    _max: Blog_noticeMaxAggregateOutputType | null
  }

  export type Blog_noticeMinAggregateOutputType = {
    uid: string | null
    createAt: Date | null
    updateAt: Date | null
  }

  export type Blog_noticeMaxAggregateOutputType = {
    uid: string | null
    createAt: Date | null
    updateAt: Date | null
  }

  export type Blog_noticeCountAggregateOutputType = {
    uid: number
    createAt: number
    updateAt: number
    _all: number
  }


  export type Blog_noticeMinAggregateInputType = {
    uid?: true
    createAt?: true
    updateAt?: true
  }

  export type Blog_noticeMaxAggregateInputType = {
    uid?: true
    createAt?: true
    updateAt?: true
  }

  export type Blog_noticeCountAggregateInputType = {
    uid?: true
    createAt?: true
    updateAt?: true
    _all?: true
  }

  export type Blog_noticeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which blog_notice to aggregate.
     */
    where?: blog_noticeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of blog_notices to fetch.
     */
    orderBy?: blog_noticeOrderByWithRelationInput | blog_noticeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: blog_noticeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` blog_notices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` blog_notices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned blog_notices
    **/
    _count?: true | Blog_noticeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Blog_noticeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Blog_noticeMaxAggregateInputType
  }

  export type GetBlog_noticeAggregateType<T extends Blog_noticeAggregateArgs> = {
        [P in keyof T & keyof AggregateBlog_notice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBlog_notice[P]>
      : GetScalarType<T[P], AggregateBlog_notice[P]>
  }




  export type blog_noticeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: blog_noticeWhereInput
    orderBy?: blog_noticeOrderByWithAggregationInput | blog_noticeOrderByWithAggregationInput[]
    by: Blog_noticeScalarFieldEnum[] | Blog_noticeScalarFieldEnum
    having?: blog_noticeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Blog_noticeCountAggregateInputType | true
    _min?: Blog_noticeMinAggregateInputType
    _max?: Blog_noticeMaxAggregateInputType
  }

  export type Blog_noticeGroupByOutputType = {
    uid: string
    createAt: Date
    updateAt: Date
    _count: Blog_noticeCountAggregateOutputType | null
    _min: Blog_noticeMinAggregateOutputType | null
    _max: Blog_noticeMaxAggregateOutputType | null
  }

  type GetBlog_noticeGroupByPayload<T extends blog_noticeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Blog_noticeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Blog_noticeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Blog_noticeGroupByOutputType[P]>
            : GetScalarType<T[P], Blog_noticeGroupByOutputType[P]>
        }
      >
    >


  export type blog_noticeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    uid?: boolean
    createAt?: boolean
    updateAt?: boolean
  }, ExtArgs["result"]["blog_notice"]>



  export type blog_noticeSelectScalar = {
    uid?: boolean
    createAt?: boolean
    updateAt?: boolean
  }

  export type blog_noticeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"uid" | "createAt" | "updateAt", ExtArgs["result"]["blog_notice"]>

  export type $blog_noticePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "blog_notice"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      uid: string
      createAt: Date
      updateAt: Date
    }, ExtArgs["result"]["blog_notice"]>
    composites: {}
  }

  type blog_noticeGetPayload<S extends boolean | null | undefined | blog_noticeDefaultArgs> = $Result.GetResult<Prisma.$blog_noticePayload, S>

  type blog_noticeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<blog_noticeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Blog_noticeCountAggregateInputType | true
    }

  export interface blog_noticeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['blog_notice'], meta: { name: 'blog_notice' } }
    /**
     * Find zero or one Blog_notice that matches the filter.
     * @param {blog_noticeFindUniqueArgs} args - Arguments to find a Blog_notice
     * @example
     * // Get one Blog_notice
     * const blog_notice = await prisma.blog_notice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends blog_noticeFindUniqueArgs>(args: SelectSubset<T, blog_noticeFindUniqueArgs<ExtArgs>>): Prisma__blog_noticeClient<$Result.GetResult<Prisma.$blog_noticePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Blog_notice that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {blog_noticeFindUniqueOrThrowArgs} args - Arguments to find a Blog_notice
     * @example
     * // Get one Blog_notice
     * const blog_notice = await prisma.blog_notice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends blog_noticeFindUniqueOrThrowArgs>(args: SelectSubset<T, blog_noticeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__blog_noticeClient<$Result.GetResult<Prisma.$blog_noticePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Blog_notice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {blog_noticeFindFirstArgs} args - Arguments to find a Blog_notice
     * @example
     * // Get one Blog_notice
     * const blog_notice = await prisma.blog_notice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends blog_noticeFindFirstArgs>(args?: SelectSubset<T, blog_noticeFindFirstArgs<ExtArgs>>): Prisma__blog_noticeClient<$Result.GetResult<Prisma.$blog_noticePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Blog_notice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {blog_noticeFindFirstOrThrowArgs} args - Arguments to find a Blog_notice
     * @example
     * // Get one Blog_notice
     * const blog_notice = await prisma.blog_notice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends blog_noticeFindFirstOrThrowArgs>(args?: SelectSubset<T, blog_noticeFindFirstOrThrowArgs<ExtArgs>>): Prisma__blog_noticeClient<$Result.GetResult<Prisma.$blog_noticePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Blog_notices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {blog_noticeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Blog_notices
     * const blog_notices = await prisma.blog_notice.findMany()
     * 
     * // Get first 10 Blog_notices
     * const blog_notices = await prisma.blog_notice.findMany({ take: 10 })
     * 
     * // Only select the `uid`
     * const blog_noticeWithUidOnly = await prisma.blog_notice.findMany({ select: { uid: true } })
     * 
     */
    findMany<T extends blog_noticeFindManyArgs>(args?: SelectSubset<T, blog_noticeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$blog_noticePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Blog_notice.
     * @param {blog_noticeCreateArgs} args - Arguments to create a Blog_notice.
     * @example
     * // Create one Blog_notice
     * const Blog_notice = await prisma.blog_notice.create({
     *   data: {
     *     // ... data to create a Blog_notice
     *   }
     * })
     * 
     */
    create<T extends blog_noticeCreateArgs>(args: SelectSubset<T, blog_noticeCreateArgs<ExtArgs>>): Prisma__blog_noticeClient<$Result.GetResult<Prisma.$blog_noticePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Blog_notices.
     * @param {blog_noticeCreateManyArgs} args - Arguments to create many Blog_notices.
     * @example
     * // Create many Blog_notices
     * const blog_notice = await prisma.blog_notice.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends blog_noticeCreateManyArgs>(args?: SelectSubset<T, blog_noticeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Blog_notice.
     * @param {blog_noticeDeleteArgs} args - Arguments to delete one Blog_notice.
     * @example
     * // Delete one Blog_notice
     * const Blog_notice = await prisma.blog_notice.delete({
     *   where: {
     *     // ... filter to delete one Blog_notice
     *   }
     * })
     * 
     */
    delete<T extends blog_noticeDeleteArgs>(args: SelectSubset<T, blog_noticeDeleteArgs<ExtArgs>>): Prisma__blog_noticeClient<$Result.GetResult<Prisma.$blog_noticePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Blog_notice.
     * @param {blog_noticeUpdateArgs} args - Arguments to update one Blog_notice.
     * @example
     * // Update one Blog_notice
     * const blog_notice = await prisma.blog_notice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends blog_noticeUpdateArgs>(args: SelectSubset<T, blog_noticeUpdateArgs<ExtArgs>>): Prisma__blog_noticeClient<$Result.GetResult<Prisma.$blog_noticePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Blog_notices.
     * @param {blog_noticeDeleteManyArgs} args - Arguments to filter Blog_notices to delete.
     * @example
     * // Delete a few Blog_notices
     * const { count } = await prisma.blog_notice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends blog_noticeDeleteManyArgs>(args?: SelectSubset<T, blog_noticeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Blog_notices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {blog_noticeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Blog_notices
     * const blog_notice = await prisma.blog_notice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends blog_noticeUpdateManyArgs>(args: SelectSubset<T, blog_noticeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Blog_notice.
     * @param {blog_noticeUpsertArgs} args - Arguments to update or create a Blog_notice.
     * @example
     * // Update or create a Blog_notice
     * const blog_notice = await prisma.blog_notice.upsert({
     *   create: {
     *     // ... data to create a Blog_notice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Blog_notice we want to update
     *   }
     * })
     */
    upsert<T extends blog_noticeUpsertArgs>(args: SelectSubset<T, blog_noticeUpsertArgs<ExtArgs>>): Prisma__blog_noticeClient<$Result.GetResult<Prisma.$blog_noticePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Blog_notices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {blog_noticeCountArgs} args - Arguments to filter Blog_notices to count.
     * @example
     * // Count the number of Blog_notices
     * const count = await prisma.blog_notice.count({
     *   where: {
     *     // ... the filter for the Blog_notices we want to count
     *   }
     * })
    **/
    count<T extends blog_noticeCountArgs>(
      args?: Subset<T, blog_noticeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Blog_noticeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Blog_notice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Blog_noticeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Blog_noticeAggregateArgs>(args: Subset<T, Blog_noticeAggregateArgs>): Prisma.PrismaPromise<GetBlog_noticeAggregateType<T>>

    /**
     * Group by Blog_notice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {blog_noticeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends blog_noticeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: blog_noticeGroupByArgs['orderBy'] }
        : { orderBy?: blog_noticeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, blog_noticeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBlog_noticeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the blog_notice model
   */
  readonly fields: blog_noticeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for blog_notice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__blog_noticeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the blog_notice model
   */
  interface blog_noticeFieldRefs {
    readonly uid: FieldRef<"blog_notice", 'String'>
    readonly createAt: FieldRef<"blog_notice", 'DateTime'>
    readonly updateAt: FieldRef<"blog_notice", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * blog_notice findUnique
   */
  export type blog_noticeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blog_notice
     */
    select?: blog_noticeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the blog_notice
     */
    omit?: blog_noticeOmit<ExtArgs> | null
    /**
     * Filter, which blog_notice to fetch.
     */
    where: blog_noticeWhereUniqueInput
  }

  /**
   * blog_notice findUniqueOrThrow
   */
  export type blog_noticeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blog_notice
     */
    select?: blog_noticeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the blog_notice
     */
    omit?: blog_noticeOmit<ExtArgs> | null
    /**
     * Filter, which blog_notice to fetch.
     */
    where: blog_noticeWhereUniqueInput
  }

  /**
   * blog_notice findFirst
   */
  export type blog_noticeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blog_notice
     */
    select?: blog_noticeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the blog_notice
     */
    omit?: blog_noticeOmit<ExtArgs> | null
    /**
     * Filter, which blog_notice to fetch.
     */
    where?: blog_noticeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of blog_notices to fetch.
     */
    orderBy?: blog_noticeOrderByWithRelationInput | blog_noticeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for blog_notices.
     */
    cursor?: blog_noticeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` blog_notices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` blog_notices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of blog_notices.
     */
    distinct?: Blog_noticeScalarFieldEnum | Blog_noticeScalarFieldEnum[]
  }

  /**
   * blog_notice findFirstOrThrow
   */
  export type blog_noticeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blog_notice
     */
    select?: blog_noticeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the blog_notice
     */
    omit?: blog_noticeOmit<ExtArgs> | null
    /**
     * Filter, which blog_notice to fetch.
     */
    where?: blog_noticeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of blog_notices to fetch.
     */
    orderBy?: blog_noticeOrderByWithRelationInput | blog_noticeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for blog_notices.
     */
    cursor?: blog_noticeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` blog_notices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` blog_notices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of blog_notices.
     */
    distinct?: Blog_noticeScalarFieldEnum | Blog_noticeScalarFieldEnum[]
  }

  /**
   * blog_notice findMany
   */
  export type blog_noticeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blog_notice
     */
    select?: blog_noticeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the blog_notice
     */
    omit?: blog_noticeOmit<ExtArgs> | null
    /**
     * Filter, which blog_notices to fetch.
     */
    where?: blog_noticeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of blog_notices to fetch.
     */
    orderBy?: blog_noticeOrderByWithRelationInput | blog_noticeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing blog_notices.
     */
    cursor?: blog_noticeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` blog_notices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` blog_notices.
     */
    skip?: number
    distinct?: Blog_noticeScalarFieldEnum | Blog_noticeScalarFieldEnum[]
  }

  /**
   * blog_notice create
   */
  export type blog_noticeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blog_notice
     */
    select?: blog_noticeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the blog_notice
     */
    omit?: blog_noticeOmit<ExtArgs> | null
    /**
     * The data needed to create a blog_notice.
     */
    data?: XOR<blog_noticeCreateInput, blog_noticeUncheckedCreateInput>
  }

  /**
   * blog_notice createMany
   */
  export type blog_noticeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many blog_notices.
     */
    data: blog_noticeCreateManyInput | blog_noticeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * blog_notice update
   */
  export type blog_noticeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blog_notice
     */
    select?: blog_noticeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the blog_notice
     */
    omit?: blog_noticeOmit<ExtArgs> | null
    /**
     * The data needed to update a blog_notice.
     */
    data: XOR<blog_noticeUpdateInput, blog_noticeUncheckedUpdateInput>
    /**
     * Choose, which blog_notice to update.
     */
    where: blog_noticeWhereUniqueInput
  }

  /**
   * blog_notice updateMany
   */
  export type blog_noticeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update blog_notices.
     */
    data: XOR<blog_noticeUpdateManyMutationInput, blog_noticeUncheckedUpdateManyInput>
    /**
     * Filter which blog_notices to update
     */
    where?: blog_noticeWhereInput
    /**
     * Limit how many blog_notices to update.
     */
    limit?: number
  }

  /**
   * blog_notice upsert
   */
  export type blog_noticeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blog_notice
     */
    select?: blog_noticeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the blog_notice
     */
    omit?: blog_noticeOmit<ExtArgs> | null
    /**
     * The filter to search for the blog_notice to update in case it exists.
     */
    where: blog_noticeWhereUniqueInput
    /**
     * In case the blog_notice found by the `where` argument doesn't exist, create a new blog_notice with this data.
     */
    create: XOR<blog_noticeCreateInput, blog_noticeUncheckedCreateInput>
    /**
     * In case the blog_notice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<blog_noticeUpdateInput, blog_noticeUncheckedUpdateInput>
  }

  /**
   * blog_notice delete
   */
  export type blog_noticeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blog_notice
     */
    select?: blog_noticeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the blog_notice
     */
    omit?: blog_noticeOmit<ExtArgs> | null
    /**
     * Filter which blog_notice to delete.
     */
    where: blog_noticeWhereUniqueInput
  }

  /**
   * blog_notice deleteMany
   */
  export type blog_noticeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which blog_notices to delete
     */
    where?: blog_noticeWhereInput
    /**
     * Limit how many blog_notices to delete.
     */
    limit?: number
  }

  /**
   * blog_notice without action
   */
  export type blog_noticeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blog_notice
     */
    select?: blog_noticeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the blog_notice
     */
    omit?: blog_noticeOmit<ExtArgs> | null
  }


  /**
   * Model blog_posts_on_tags
   */

  export type AggregateBlog_posts_on_tags = {
    _count: Blog_posts_on_tagsCountAggregateOutputType | null
    _min: Blog_posts_on_tagsMinAggregateOutputType | null
    _max: Blog_posts_on_tagsMaxAggregateOutputType | null
  }

  export type Blog_posts_on_tagsMinAggregateOutputType = {
    postsId: string | null
    tagId: string | null
  }

  export type Blog_posts_on_tagsMaxAggregateOutputType = {
    postsId: string | null
    tagId: string | null
  }

  export type Blog_posts_on_tagsCountAggregateOutputType = {
    postsId: number
    tagId: number
    _all: number
  }


  export type Blog_posts_on_tagsMinAggregateInputType = {
    postsId?: true
    tagId?: true
  }

  export type Blog_posts_on_tagsMaxAggregateInputType = {
    postsId?: true
    tagId?: true
  }

  export type Blog_posts_on_tagsCountAggregateInputType = {
    postsId?: true
    tagId?: true
    _all?: true
  }

  export type Blog_posts_on_tagsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which blog_posts_on_tags to aggregate.
     */
    where?: blog_posts_on_tagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of blog_posts_on_tags to fetch.
     */
    orderBy?: blog_posts_on_tagsOrderByWithRelationInput | blog_posts_on_tagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: blog_posts_on_tagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` blog_posts_on_tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` blog_posts_on_tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned blog_posts_on_tags
    **/
    _count?: true | Blog_posts_on_tagsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Blog_posts_on_tagsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Blog_posts_on_tagsMaxAggregateInputType
  }

  export type GetBlog_posts_on_tagsAggregateType<T extends Blog_posts_on_tagsAggregateArgs> = {
        [P in keyof T & keyof AggregateBlog_posts_on_tags]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBlog_posts_on_tags[P]>
      : GetScalarType<T[P], AggregateBlog_posts_on_tags[P]>
  }




  export type blog_posts_on_tagsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: blog_posts_on_tagsWhereInput
    orderBy?: blog_posts_on_tagsOrderByWithAggregationInput | blog_posts_on_tagsOrderByWithAggregationInput[]
    by: Blog_posts_on_tagsScalarFieldEnum[] | Blog_posts_on_tagsScalarFieldEnum
    having?: blog_posts_on_tagsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Blog_posts_on_tagsCountAggregateInputType | true
    _min?: Blog_posts_on_tagsMinAggregateInputType
    _max?: Blog_posts_on_tagsMaxAggregateInputType
  }

  export type Blog_posts_on_tagsGroupByOutputType = {
    postsId: string
    tagId: string
    _count: Blog_posts_on_tagsCountAggregateOutputType | null
    _min: Blog_posts_on_tagsMinAggregateOutputType | null
    _max: Blog_posts_on_tagsMaxAggregateOutputType | null
  }

  type GetBlog_posts_on_tagsGroupByPayload<T extends blog_posts_on_tagsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Blog_posts_on_tagsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Blog_posts_on_tagsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Blog_posts_on_tagsGroupByOutputType[P]>
            : GetScalarType<T[P], Blog_posts_on_tagsGroupByOutputType[P]>
        }
      >
    >


  export type blog_posts_on_tagsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    postsId?: boolean
    tagId?: boolean
    posts?: boolean | blog_postsDefaultArgs<ExtArgs>
    tag?: boolean | blog_tagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["blog_posts_on_tags"]>



  export type blog_posts_on_tagsSelectScalar = {
    postsId?: boolean
    tagId?: boolean
  }

  export type blog_posts_on_tagsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"postsId" | "tagId", ExtArgs["result"]["blog_posts_on_tags"]>
  export type blog_posts_on_tagsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    posts?: boolean | blog_postsDefaultArgs<ExtArgs>
    tag?: boolean | blog_tagDefaultArgs<ExtArgs>
  }

  export type $blog_posts_on_tagsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "blog_posts_on_tags"
    objects: {
      posts: Prisma.$blog_postsPayload<ExtArgs>
      tag: Prisma.$blog_tagPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      postsId: string
      tagId: string
    }, ExtArgs["result"]["blog_posts_on_tags"]>
    composites: {}
  }

  type blog_posts_on_tagsGetPayload<S extends boolean | null | undefined | blog_posts_on_tagsDefaultArgs> = $Result.GetResult<Prisma.$blog_posts_on_tagsPayload, S>

  type blog_posts_on_tagsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<blog_posts_on_tagsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Blog_posts_on_tagsCountAggregateInputType | true
    }

  export interface blog_posts_on_tagsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['blog_posts_on_tags'], meta: { name: 'blog_posts_on_tags' } }
    /**
     * Find zero or one Blog_posts_on_tags that matches the filter.
     * @param {blog_posts_on_tagsFindUniqueArgs} args - Arguments to find a Blog_posts_on_tags
     * @example
     * // Get one Blog_posts_on_tags
     * const blog_posts_on_tags = await prisma.blog_posts_on_tags.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends blog_posts_on_tagsFindUniqueArgs>(args: SelectSubset<T, blog_posts_on_tagsFindUniqueArgs<ExtArgs>>): Prisma__blog_posts_on_tagsClient<$Result.GetResult<Prisma.$blog_posts_on_tagsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Blog_posts_on_tags that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {blog_posts_on_tagsFindUniqueOrThrowArgs} args - Arguments to find a Blog_posts_on_tags
     * @example
     * // Get one Blog_posts_on_tags
     * const blog_posts_on_tags = await prisma.blog_posts_on_tags.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends blog_posts_on_tagsFindUniqueOrThrowArgs>(args: SelectSubset<T, blog_posts_on_tagsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__blog_posts_on_tagsClient<$Result.GetResult<Prisma.$blog_posts_on_tagsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Blog_posts_on_tags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {blog_posts_on_tagsFindFirstArgs} args - Arguments to find a Blog_posts_on_tags
     * @example
     * // Get one Blog_posts_on_tags
     * const blog_posts_on_tags = await prisma.blog_posts_on_tags.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends blog_posts_on_tagsFindFirstArgs>(args?: SelectSubset<T, blog_posts_on_tagsFindFirstArgs<ExtArgs>>): Prisma__blog_posts_on_tagsClient<$Result.GetResult<Prisma.$blog_posts_on_tagsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Blog_posts_on_tags that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {blog_posts_on_tagsFindFirstOrThrowArgs} args - Arguments to find a Blog_posts_on_tags
     * @example
     * // Get one Blog_posts_on_tags
     * const blog_posts_on_tags = await prisma.blog_posts_on_tags.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends blog_posts_on_tagsFindFirstOrThrowArgs>(args?: SelectSubset<T, blog_posts_on_tagsFindFirstOrThrowArgs<ExtArgs>>): Prisma__blog_posts_on_tagsClient<$Result.GetResult<Prisma.$blog_posts_on_tagsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Blog_posts_on_tags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {blog_posts_on_tagsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Blog_posts_on_tags
     * const blog_posts_on_tags = await prisma.blog_posts_on_tags.findMany()
     * 
     * // Get first 10 Blog_posts_on_tags
     * const blog_posts_on_tags = await prisma.blog_posts_on_tags.findMany({ take: 10 })
     * 
     * // Only select the `postsId`
     * const blog_posts_on_tagsWithPostsIdOnly = await prisma.blog_posts_on_tags.findMany({ select: { postsId: true } })
     * 
     */
    findMany<T extends blog_posts_on_tagsFindManyArgs>(args?: SelectSubset<T, blog_posts_on_tagsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$blog_posts_on_tagsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Blog_posts_on_tags.
     * @param {blog_posts_on_tagsCreateArgs} args - Arguments to create a Blog_posts_on_tags.
     * @example
     * // Create one Blog_posts_on_tags
     * const Blog_posts_on_tags = await prisma.blog_posts_on_tags.create({
     *   data: {
     *     // ... data to create a Blog_posts_on_tags
     *   }
     * })
     * 
     */
    create<T extends blog_posts_on_tagsCreateArgs>(args: SelectSubset<T, blog_posts_on_tagsCreateArgs<ExtArgs>>): Prisma__blog_posts_on_tagsClient<$Result.GetResult<Prisma.$blog_posts_on_tagsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Blog_posts_on_tags.
     * @param {blog_posts_on_tagsCreateManyArgs} args - Arguments to create many Blog_posts_on_tags.
     * @example
     * // Create many Blog_posts_on_tags
     * const blog_posts_on_tags = await prisma.blog_posts_on_tags.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends blog_posts_on_tagsCreateManyArgs>(args?: SelectSubset<T, blog_posts_on_tagsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Blog_posts_on_tags.
     * @param {blog_posts_on_tagsDeleteArgs} args - Arguments to delete one Blog_posts_on_tags.
     * @example
     * // Delete one Blog_posts_on_tags
     * const Blog_posts_on_tags = await prisma.blog_posts_on_tags.delete({
     *   where: {
     *     // ... filter to delete one Blog_posts_on_tags
     *   }
     * })
     * 
     */
    delete<T extends blog_posts_on_tagsDeleteArgs>(args: SelectSubset<T, blog_posts_on_tagsDeleteArgs<ExtArgs>>): Prisma__blog_posts_on_tagsClient<$Result.GetResult<Prisma.$blog_posts_on_tagsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Blog_posts_on_tags.
     * @param {blog_posts_on_tagsUpdateArgs} args - Arguments to update one Blog_posts_on_tags.
     * @example
     * // Update one Blog_posts_on_tags
     * const blog_posts_on_tags = await prisma.blog_posts_on_tags.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends blog_posts_on_tagsUpdateArgs>(args: SelectSubset<T, blog_posts_on_tagsUpdateArgs<ExtArgs>>): Prisma__blog_posts_on_tagsClient<$Result.GetResult<Prisma.$blog_posts_on_tagsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Blog_posts_on_tags.
     * @param {blog_posts_on_tagsDeleteManyArgs} args - Arguments to filter Blog_posts_on_tags to delete.
     * @example
     * // Delete a few Blog_posts_on_tags
     * const { count } = await prisma.blog_posts_on_tags.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends blog_posts_on_tagsDeleteManyArgs>(args?: SelectSubset<T, blog_posts_on_tagsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Blog_posts_on_tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {blog_posts_on_tagsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Blog_posts_on_tags
     * const blog_posts_on_tags = await prisma.blog_posts_on_tags.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends blog_posts_on_tagsUpdateManyArgs>(args: SelectSubset<T, blog_posts_on_tagsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Blog_posts_on_tags.
     * @param {blog_posts_on_tagsUpsertArgs} args - Arguments to update or create a Blog_posts_on_tags.
     * @example
     * // Update or create a Blog_posts_on_tags
     * const blog_posts_on_tags = await prisma.blog_posts_on_tags.upsert({
     *   create: {
     *     // ... data to create a Blog_posts_on_tags
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Blog_posts_on_tags we want to update
     *   }
     * })
     */
    upsert<T extends blog_posts_on_tagsUpsertArgs>(args: SelectSubset<T, blog_posts_on_tagsUpsertArgs<ExtArgs>>): Prisma__blog_posts_on_tagsClient<$Result.GetResult<Prisma.$blog_posts_on_tagsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Blog_posts_on_tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {blog_posts_on_tagsCountArgs} args - Arguments to filter Blog_posts_on_tags to count.
     * @example
     * // Count the number of Blog_posts_on_tags
     * const count = await prisma.blog_posts_on_tags.count({
     *   where: {
     *     // ... the filter for the Blog_posts_on_tags we want to count
     *   }
     * })
    **/
    count<T extends blog_posts_on_tagsCountArgs>(
      args?: Subset<T, blog_posts_on_tagsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Blog_posts_on_tagsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Blog_posts_on_tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Blog_posts_on_tagsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Blog_posts_on_tagsAggregateArgs>(args: Subset<T, Blog_posts_on_tagsAggregateArgs>): Prisma.PrismaPromise<GetBlog_posts_on_tagsAggregateType<T>>

    /**
     * Group by Blog_posts_on_tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {blog_posts_on_tagsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends blog_posts_on_tagsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: blog_posts_on_tagsGroupByArgs['orderBy'] }
        : { orderBy?: blog_posts_on_tagsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, blog_posts_on_tagsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBlog_posts_on_tagsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the blog_posts_on_tags model
   */
  readonly fields: blog_posts_on_tagsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for blog_posts_on_tags.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__blog_posts_on_tagsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    posts<T extends blog_postsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, blog_postsDefaultArgs<ExtArgs>>): Prisma__blog_postsClient<$Result.GetResult<Prisma.$blog_postsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tag<T extends blog_tagDefaultArgs<ExtArgs> = {}>(args?: Subset<T, blog_tagDefaultArgs<ExtArgs>>): Prisma__blog_tagClient<$Result.GetResult<Prisma.$blog_tagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the blog_posts_on_tags model
   */
  interface blog_posts_on_tagsFieldRefs {
    readonly postsId: FieldRef<"blog_posts_on_tags", 'String'>
    readonly tagId: FieldRef<"blog_posts_on_tags", 'String'>
  }
    

  // Custom InputTypes
  /**
   * blog_posts_on_tags findUnique
   */
  export type blog_posts_on_tagsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blog_posts_on_tags
     */
    select?: blog_posts_on_tagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the blog_posts_on_tags
     */
    omit?: blog_posts_on_tagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: blog_posts_on_tagsInclude<ExtArgs> | null
    /**
     * Filter, which blog_posts_on_tags to fetch.
     */
    where: blog_posts_on_tagsWhereUniqueInput
  }

  /**
   * blog_posts_on_tags findUniqueOrThrow
   */
  export type blog_posts_on_tagsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blog_posts_on_tags
     */
    select?: blog_posts_on_tagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the blog_posts_on_tags
     */
    omit?: blog_posts_on_tagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: blog_posts_on_tagsInclude<ExtArgs> | null
    /**
     * Filter, which blog_posts_on_tags to fetch.
     */
    where: blog_posts_on_tagsWhereUniqueInput
  }

  /**
   * blog_posts_on_tags findFirst
   */
  export type blog_posts_on_tagsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blog_posts_on_tags
     */
    select?: blog_posts_on_tagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the blog_posts_on_tags
     */
    omit?: blog_posts_on_tagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: blog_posts_on_tagsInclude<ExtArgs> | null
    /**
     * Filter, which blog_posts_on_tags to fetch.
     */
    where?: blog_posts_on_tagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of blog_posts_on_tags to fetch.
     */
    orderBy?: blog_posts_on_tagsOrderByWithRelationInput | blog_posts_on_tagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for blog_posts_on_tags.
     */
    cursor?: blog_posts_on_tagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` blog_posts_on_tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` blog_posts_on_tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of blog_posts_on_tags.
     */
    distinct?: Blog_posts_on_tagsScalarFieldEnum | Blog_posts_on_tagsScalarFieldEnum[]
  }

  /**
   * blog_posts_on_tags findFirstOrThrow
   */
  export type blog_posts_on_tagsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blog_posts_on_tags
     */
    select?: blog_posts_on_tagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the blog_posts_on_tags
     */
    omit?: blog_posts_on_tagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: blog_posts_on_tagsInclude<ExtArgs> | null
    /**
     * Filter, which blog_posts_on_tags to fetch.
     */
    where?: blog_posts_on_tagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of blog_posts_on_tags to fetch.
     */
    orderBy?: blog_posts_on_tagsOrderByWithRelationInput | blog_posts_on_tagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for blog_posts_on_tags.
     */
    cursor?: blog_posts_on_tagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` blog_posts_on_tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` blog_posts_on_tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of blog_posts_on_tags.
     */
    distinct?: Blog_posts_on_tagsScalarFieldEnum | Blog_posts_on_tagsScalarFieldEnum[]
  }

  /**
   * blog_posts_on_tags findMany
   */
  export type blog_posts_on_tagsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blog_posts_on_tags
     */
    select?: blog_posts_on_tagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the blog_posts_on_tags
     */
    omit?: blog_posts_on_tagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: blog_posts_on_tagsInclude<ExtArgs> | null
    /**
     * Filter, which blog_posts_on_tags to fetch.
     */
    where?: blog_posts_on_tagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of blog_posts_on_tags to fetch.
     */
    orderBy?: blog_posts_on_tagsOrderByWithRelationInput | blog_posts_on_tagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing blog_posts_on_tags.
     */
    cursor?: blog_posts_on_tagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` blog_posts_on_tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` blog_posts_on_tags.
     */
    skip?: number
    distinct?: Blog_posts_on_tagsScalarFieldEnum | Blog_posts_on_tagsScalarFieldEnum[]
  }

  /**
   * blog_posts_on_tags create
   */
  export type blog_posts_on_tagsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blog_posts_on_tags
     */
    select?: blog_posts_on_tagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the blog_posts_on_tags
     */
    omit?: blog_posts_on_tagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: blog_posts_on_tagsInclude<ExtArgs> | null
    /**
     * The data needed to create a blog_posts_on_tags.
     */
    data: XOR<blog_posts_on_tagsCreateInput, blog_posts_on_tagsUncheckedCreateInput>
  }

  /**
   * blog_posts_on_tags createMany
   */
  export type blog_posts_on_tagsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many blog_posts_on_tags.
     */
    data: blog_posts_on_tagsCreateManyInput | blog_posts_on_tagsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * blog_posts_on_tags update
   */
  export type blog_posts_on_tagsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blog_posts_on_tags
     */
    select?: blog_posts_on_tagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the blog_posts_on_tags
     */
    omit?: blog_posts_on_tagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: blog_posts_on_tagsInclude<ExtArgs> | null
    /**
     * The data needed to update a blog_posts_on_tags.
     */
    data: XOR<blog_posts_on_tagsUpdateInput, blog_posts_on_tagsUncheckedUpdateInput>
    /**
     * Choose, which blog_posts_on_tags to update.
     */
    where: blog_posts_on_tagsWhereUniqueInput
  }

  /**
   * blog_posts_on_tags updateMany
   */
  export type blog_posts_on_tagsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update blog_posts_on_tags.
     */
    data: XOR<blog_posts_on_tagsUpdateManyMutationInput, blog_posts_on_tagsUncheckedUpdateManyInput>
    /**
     * Filter which blog_posts_on_tags to update
     */
    where?: blog_posts_on_tagsWhereInput
    /**
     * Limit how many blog_posts_on_tags to update.
     */
    limit?: number
  }

  /**
   * blog_posts_on_tags upsert
   */
  export type blog_posts_on_tagsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blog_posts_on_tags
     */
    select?: blog_posts_on_tagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the blog_posts_on_tags
     */
    omit?: blog_posts_on_tagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: blog_posts_on_tagsInclude<ExtArgs> | null
    /**
     * The filter to search for the blog_posts_on_tags to update in case it exists.
     */
    where: blog_posts_on_tagsWhereUniqueInput
    /**
     * In case the blog_posts_on_tags found by the `where` argument doesn't exist, create a new blog_posts_on_tags with this data.
     */
    create: XOR<blog_posts_on_tagsCreateInput, blog_posts_on_tagsUncheckedCreateInput>
    /**
     * In case the blog_posts_on_tags was found with the provided `where` argument, update it with this data.
     */
    update: XOR<blog_posts_on_tagsUpdateInput, blog_posts_on_tagsUncheckedUpdateInput>
  }

  /**
   * blog_posts_on_tags delete
   */
  export type blog_posts_on_tagsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blog_posts_on_tags
     */
    select?: blog_posts_on_tagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the blog_posts_on_tags
     */
    omit?: blog_posts_on_tagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: blog_posts_on_tagsInclude<ExtArgs> | null
    /**
     * Filter which blog_posts_on_tags to delete.
     */
    where: blog_posts_on_tagsWhereUniqueInput
  }

  /**
   * blog_posts_on_tags deleteMany
   */
  export type blog_posts_on_tagsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which blog_posts_on_tags to delete
     */
    where?: blog_posts_on_tagsWhereInput
    /**
     * Limit how many blog_posts_on_tags to delete.
     */
    limit?: number
  }

  /**
   * blog_posts_on_tags without action
   */
  export type blog_posts_on_tagsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blog_posts_on_tags
     */
    select?: blog_posts_on_tagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the blog_posts_on_tags
     */
    omit?: blog_posts_on_tagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: blog_posts_on_tagsInclude<ExtArgs> | null
  }


  /**
   * Model blog_tag
   */

  export type AggregateBlog_tag = {
    _count: Blog_tagCountAggregateOutputType | null
    _min: Blog_tagMinAggregateOutputType | null
    _max: Blog_tagMaxAggregateOutputType | null
  }

  export type Blog_tagMinAggregateOutputType = {
    uid: string | null
    createAt: Date | null
    updateAt: Date | null
    name: string | null
  }

  export type Blog_tagMaxAggregateOutputType = {
    uid: string | null
    createAt: Date | null
    updateAt: Date | null
    name: string | null
  }

  export type Blog_tagCountAggregateOutputType = {
    uid: number
    createAt: number
    updateAt: number
    name: number
    _all: number
  }


  export type Blog_tagMinAggregateInputType = {
    uid?: true
    createAt?: true
    updateAt?: true
    name?: true
  }

  export type Blog_tagMaxAggregateInputType = {
    uid?: true
    createAt?: true
    updateAt?: true
    name?: true
  }

  export type Blog_tagCountAggregateInputType = {
    uid?: true
    createAt?: true
    updateAt?: true
    name?: true
    _all?: true
  }

  export type Blog_tagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which blog_tag to aggregate.
     */
    where?: blog_tagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of blog_tags to fetch.
     */
    orderBy?: blog_tagOrderByWithRelationInput | blog_tagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: blog_tagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` blog_tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` blog_tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned blog_tags
    **/
    _count?: true | Blog_tagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Blog_tagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Blog_tagMaxAggregateInputType
  }

  export type GetBlog_tagAggregateType<T extends Blog_tagAggregateArgs> = {
        [P in keyof T & keyof AggregateBlog_tag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBlog_tag[P]>
      : GetScalarType<T[P], AggregateBlog_tag[P]>
  }




  export type blog_tagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: blog_tagWhereInput
    orderBy?: blog_tagOrderByWithAggregationInput | blog_tagOrderByWithAggregationInput[]
    by: Blog_tagScalarFieldEnum[] | Blog_tagScalarFieldEnum
    having?: blog_tagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Blog_tagCountAggregateInputType | true
    _min?: Blog_tagMinAggregateInputType
    _max?: Blog_tagMaxAggregateInputType
  }

  export type Blog_tagGroupByOutputType = {
    uid: string
    createAt: Date
    updateAt: Date
    name: string
    _count: Blog_tagCountAggregateOutputType | null
    _min: Blog_tagMinAggregateOutputType | null
    _max: Blog_tagMaxAggregateOutputType | null
  }

  type GetBlog_tagGroupByPayload<T extends blog_tagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Blog_tagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Blog_tagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Blog_tagGroupByOutputType[P]>
            : GetScalarType<T[P], Blog_tagGroupByOutputType[P]>
        }
      >
    >


  export type blog_tagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    uid?: boolean
    createAt?: boolean
    updateAt?: boolean
    name?: boolean
    blog_posts_on_tags?: boolean | blog_tag$blog_posts_on_tagsArgs<ExtArgs>
    _count?: boolean | Blog_tagCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["blog_tag"]>



  export type blog_tagSelectScalar = {
    uid?: boolean
    createAt?: boolean
    updateAt?: boolean
    name?: boolean
  }

  export type blog_tagOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"uid" | "createAt" | "updateAt" | "name", ExtArgs["result"]["blog_tag"]>
  export type blog_tagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    blog_posts_on_tags?: boolean | blog_tag$blog_posts_on_tagsArgs<ExtArgs>
    _count?: boolean | Blog_tagCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $blog_tagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "blog_tag"
    objects: {
      blog_posts_on_tags: Prisma.$blog_posts_on_tagsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      uid: string
      createAt: Date
      updateAt: Date
      name: string
    }, ExtArgs["result"]["blog_tag"]>
    composites: {}
  }

  type blog_tagGetPayload<S extends boolean | null | undefined | blog_tagDefaultArgs> = $Result.GetResult<Prisma.$blog_tagPayload, S>

  type blog_tagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<blog_tagFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Blog_tagCountAggregateInputType | true
    }

  export interface blog_tagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['blog_tag'], meta: { name: 'blog_tag' } }
    /**
     * Find zero or one Blog_tag that matches the filter.
     * @param {blog_tagFindUniqueArgs} args - Arguments to find a Blog_tag
     * @example
     * // Get one Blog_tag
     * const blog_tag = await prisma.blog_tag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends blog_tagFindUniqueArgs>(args: SelectSubset<T, blog_tagFindUniqueArgs<ExtArgs>>): Prisma__blog_tagClient<$Result.GetResult<Prisma.$blog_tagPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Blog_tag that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {blog_tagFindUniqueOrThrowArgs} args - Arguments to find a Blog_tag
     * @example
     * // Get one Blog_tag
     * const blog_tag = await prisma.blog_tag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends blog_tagFindUniqueOrThrowArgs>(args: SelectSubset<T, blog_tagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__blog_tagClient<$Result.GetResult<Prisma.$blog_tagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Blog_tag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {blog_tagFindFirstArgs} args - Arguments to find a Blog_tag
     * @example
     * // Get one Blog_tag
     * const blog_tag = await prisma.blog_tag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends blog_tagFindFirstArgs>(args?: SelectSubset<T, blog_tagFindFirstArgs<ExtArgs>>): Prisma__blog_tagClient<$Result.GetResult<Prisma.$blog_tagPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Blog_tag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {blog_tagFindFirstOrThrowArgs} args - Arguments to find a Blog_tag
     * @example
     * // Get one Blog_tag
     * const blog_tag = await prisma.blog_tag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends blog_tagFindFirstOrThrowArgs>(args?: SelectSubset<T, blog_tagFindFirstOrThrowArgs<ExtArgs>>): Prisma__blog_tagClient<$Result.GetResult<Prisma.$blog_tagPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Blog_tags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {blog_tagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Blog_tags
     * const blog_tags = await prisma.blog_tag.findMany()
     * 
     * // Get first 10 Blog_tags
     * const blog_tags = await prisma.blog_tag.findMany({ take: 10 })
     * 
     * // Only select the `uid`
     * const blog_tagWithUidOnly = await prisma.blog_tag.findMany({ select: { uid: true } })
     * 
     */
    findMany<T extends blog_tagFindManyArgs>(args?: SelectSubset<T, blog_tagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$blog_tagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Blog_tag.
     * @param {blog_tagCreateArgs} args - Arguments to create a Blog_tag.
     * @example
     * // Create one Blog_tag
     * const Blog_tag = await prisma.blog_tag.create({
     *   data: {
     *     // ... data to create a Blog_tag
     *   }
     * })
     * 
     */
    create<T extends blog_tagCreateArgs>(args: SelectSubset<T, blog_tagCreateArgs<ExtArgs>>): Prisma__blog_tagClient<$Result.GetResult<Prisma.$blog_tagPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Blog_tags.
     * @param {blog_tagCreateManyArgs} args - Arguments to create many Blog_tags.
     * @example
     * // Create many Blog_tags
     * const blog_tag = await prisma.blog_tag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends blog_tagCreateManyArgs>(args?: SelectSubset<T, blog_tagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Blog_tag.
     * @param {blog_tagDeleteArgs} args - Arguments to delete one Blog_tag.
     * @example
     * // Delete one Blog_tag
     * const Blog_tag = await prisma.blog_tag.delete({
     *   where: {
     *     // ... filter to delete one Blog_tag
     *   }
     * })
     * 
     */
    delete<T extends blog_tagDeleteArgs>(args: SelectSubset<T, blog_tagDeleteArgs<ExtArgs>>): Prisma__blog_tagClient<$Result.GetResult<Prisma.$blog_tagPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Blog_tag.
     * @param {blog_tagUpdateArgs} args - Arguments to update one Blog_tag.
     * @example
     * // Update one Blog_tag
     * const blog_tag = await prisma.blog_tag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends blog_tagUpdateArgs>(args: SelectSubset<T, blog_tagUpdateArgs<ExtArgs>>): Prisma__blog_tagClient<$Result.GetResult<Prisma.$blog_tagPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Blog_tags.
     * @param {blog_tagDeleteManyArgs} args - Arguments to filter Blog_tags to delete.
     * @example
     * // Delete a few Blog_tags
     * const { count } = await prisma.blog_tag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends blog_tagDeleteManyArgs>(args?: SelectSubset<T, blog_tagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Blog_tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {blog_tagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Blog_tags
     * const blog_tag = await prisma.blog_tag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends blog_tagUpdateManyArgs>(args: SelectSubset<T, blog_tagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Blog_tag.
     * @param {blog_tagUpsertArgs} args - Arguments to update or create a Blog_tag.
     * @example
     * // Update or create a Blog_tag
     * const blog_tag = await prisma.blog_tag.upsert({
     *   create: {
     *     // ... data to create a Blog_tag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Blog_tag we want to update
     *   }
     * })
     */
    upsert<T extends blog_tagUpsertArgs>(args: SelectSubset<T, blog_tagUpsertArgs<ExtArgs>>): Prisma__blog_tagClient<$Result.GetResult<Prisma.$blog_tagPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Blog_tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {blog_tagCountArgs} args - Arguments to filter Blog_tags to count.
     * @example
     * // Count the number of Blog_tags
     * const count = await prisma.blog_tag.count({
     *   where: {
     *     // ... the filter for the Blog_tags we want to count
     *   }
     * })
    **/
    count<T extends blog_tagCountArgs>(
      args?: Subset<T, blog_tagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Blog_tagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Blog_tag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Blog_tagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Blog_tagAggregateArgs>(args: Subset<T, Blog_tagAggregateArgs>): Prisma.PrismaPromise<GetBlog_tagAggregateType<T>>

    /**
     * Group by Blog_tag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {blog_tagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends blog_tagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: blog_tagGroupByArgs['orderBy'] }
        : { orderBy?: blog_tagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, blog_tagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBlog_tagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the blog_tag model
   */
  readonly fields: blog_tagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for blog_tag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__blog_tagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    blog_posts_on_tags<T extends blog_tag$blog_posts_on_tagsArgs<ExtArgs> = {}>(args?: Subset<T, blog_tag$blog_posts_on_tagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$blog_posts_on_tagsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the blog_tag model
   */
  interface blog_tagFieldRefs {
    readonly uid: FieldRef<"blog_tag", 'String'>
    readonly createAt: FieldRef<"blog_tag", 'DateTime'>
    readonly updateAt: FieldRef<"blog_tag", 'DateTime'>
    readonly name: FieldRef<"blog_tag", 'String'>
  }
    

  // Custom InputTypes
  /**
   * blog_tag findUnique
   */
  export type blog_tagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blog_tag
     */
    select?: blog_tagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the blog_tag
     */
    omit?: blog_tagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: blog_tagInclude<ExtArgs> | null
    /**
     * Filter, which blog_tag to fetch.
     */
    where: blog_tagWhereUniqueInput
  }

  /**
   * blog_tag findUniqueOrThrow
   */
  export type blog_tagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blog_tag
     */
    select?: blog_tagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the blog_tag
     */
    omit?: blog_tagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: blog_tagInclude<ExtArgs> | null
    /**
     * Filter, which blog_tag to fetch.
     */
    where: blog_tagWhereUniqueInput
  }

  /**
   * blog_tag findFirst
   */
  export type blog_tagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blog_tag
     */
    select?: blog_tagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the blog_tag
     */
    omit?: blog_tagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: blog_tagInclude<ExtArgs> | null
    /**
     * Filter, which blog_tag to fetch.
     */
    where?: blog_tagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of blog_tags to fetch.
     */
    orderBy?: blog_tagOrderByWithRelationInput | blog_tagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for blog_tags.
     */
    cursor?: blog_tagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` blog_tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` blog_tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of blog_tags.
     */
    distinct?: Blog_tagScalarFieldEnum | Blog_tagScalarFieldEnum[]
  }

  /**
   * blog_tag findFirstOrThrow
   */
  export type blog_tagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blog_tag
     */
    select?: blog_tagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the blog_tag
     */
    omit?: blog_tagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: blog_tagInclude<ExtArgs> | null
    /**
     * Filter, which blog_tag to fetch.
     */
    where?: blog_tagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of blog_tags to fetch.
     */
    orderBy?: blog_tagOrderByWithRelationInput | blog_tagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for blog_tags.
     */
    cursor?: blog_tagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` blog_tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` blog_tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of blog_tags.
     */
    distinct?: Blog_tagScalarFieldEnum | Blog_tagScalarFieldEnum[]
  }

  /**
   * blog_tag findMany
   */
  export type blog_tagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blog_tag
     */
    select?: blog_tagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the blog_tag
     */
    omit?: blog_tagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: blog_tagInclude<ExtArgs> | null
    /**
     * Filter, which blog_tags to fetch.
     */
    where?: blog_tagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of blog_tags to fetch.
     */
    orderBy?: blog_tagOrderByWithRelationInput | blog_tagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing blog_tags.
     */
    cursor?: blog_tagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` blog_tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` blog_tags.
     */
    skip?: number
    distinct?: Blog_tagScalarFieldEnum | Blog_tagScalarFieldEnum[]
  }

  /**
   * blog_tag create
   */
  export type blog_tagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blog_tag
     */
    select?: blog_tagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the blog_tag
     */
    omit?: blog_tagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: blog_tagInclude<ExtArgs> | null
    /**
     * The data needed to create a blog_tag.
     */
    data: XOR<blog_tagCreateInput, blog_tagUncheckedCreateInput>
  }

  /**
   * blog_tag createMany
   */
  export type blog_tagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many blog_tags.
     */
    data: blog_tagCreateManyInput | blog_tagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * blog_tag update
   */
  export type blog_tagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blog_tag
     */
    select?: blog_tagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the blog_tag
     */
    omit?: blog_tagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: blog_tagInclude<ExtArgs> | null
    /**
     * The data needed to update a blog_tag.
     */
    data: XOR<blog_tagUpdateInput, blog_tagUncheckedUpdateInput>
    /**
     * Choose, which blog_tag to update.
     */
    where: blog_tagWhereUniqueInput
  }

  /**
   * blog_tag updateMany
   */
  export type blog_tagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update blog_tags.
     */
    data: XOR<blog_tagUpdateManyMutationInput, blog_tagUncheckedUpdateManyInput>
    /**
     * Filter which blog_tags to update
     */
    where?: blog_tagWhereInput
    /**
     * Limit how many blog_tags to update.
     */
    limit?: number
  }

  /**
   * blog_tag upsert
   */
  export type blog_tagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blog_tag
     */
    select?: blog_tagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the blog_tag
     */
    omit?: blog_tagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: blog_tagInclude<ExtArgs> | null
    /**
     * The filter to search for the blog_tag to update in case it exists.
     */
    where: blog_tagWhereUniqueInput
    /**
     * In case the blog_tag found by the `where` argument doesn't exist, create a new blog_tag with this data.
     */
    create: XOR<blog_tagCreateInput, blog_tagUncheckedCreateInput>
    /**
     * In case the blog_tag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<blog_tagUpdateInput, blog_tagUncheckedUpdateInput>
  }

  /**
   * blog_tag delete
   */
  export type blog_tagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blog_tag
     */
    select?: blog_tagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the blog_tag
     */
    omit?: blog_tagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: blog_tagInclude<ExtArgs> | null
    /**
     * Filter which blog_tag to delete.
     */
    where: blog_tagWhereUniqueInput
  }

  /**
   * blog_tag deleteMany
   */
  export type blog_tagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which blog_tags to delete
     */
    where?: blog_tagWhereInput
    /**
     * Limit how many blog_tags to delete.
     */
    limit?: number
  }

  /**
   * blog_tag.blog_posts_on_tags
   */
  export type blog_tag$blog_posts_on_tagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blog_posts_on_tags
     */
    select?: blog_posts_on_tagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the blog_posts_on_tags
     */
    omit?: blog_posts_on_tagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: blog_posts_on_tagsInclude<ExtArgs> | null
    where?: blog_posts_on_tagsWhereInput
    orderBy?: blog_posts_on_tagsOrderByWithRelationInput | blog_posts_on_tagsOrderByWithRelationInput[]
    cursor?: blog_posts_on_tagsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Blog_posts_on_tagsScalarFieldEnum | Blog_posts_on_tagsScalarFieldEnum[]
  }

  /**
   * blog_tag without action
   */
  export type blog_tagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blog_tag
     */
    select?: blog_tagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the blog_tag
     */
    omit?: blog_tagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: blog_tagInclude<ExtArgs> | null
  }


  /**
   * Model file_user
   */

  export type AggregateFile_user = {
    _count: File_userCountAggregateOutputType | null
    _min: File_userMinAggregateOutputType | null
    _max: File_userMaxAggregateOutputType | null
  }

  export type File_userMinAggregateOutputType = {
    uid: string | null
    createAt: Date | null
    updateAt: Date | null
    name: string | null
    is_admin: boolean | null
  }

  export type File_userMaxAggregateOutputType = {
    uid: string | null
    createAt: Date | null
    updateAt: Date | null
    name: string | null
    is_admin: boolean | null
  }

  export type File_userCountAggregateOutputType = {
    uid: number
    createAt: number
    updateAt: number
    name: number
    is_admin: number
    _all: number
  }


  export type File_userMinAggregateInputType = {
    uid?: true
    createAt?: true
    updateAt?: true
    name?: true
    is_admin?: true
  }

  export type File_userMaxAggregateInputType = {
    uid?: true
    createAt?: true
    updateAt?: true
    name?: true
    is_admin?: true
  }

  export type File_userCountAggregateInputType = {
    uid?: true
    createAt?: true
    updateAt?: true
    name?: true
    is_admin?: true
    _all?: true
  }

  export type File_userAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which file_user to aggregate.
     */
    where?: file_userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of file_users to fetch.
     */
    orderBy?: file_userOrderByWithRelationInput | file_userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: file_userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` file_users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` file_users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned file_users
    **/
    _count?: true | File_userCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: File_userMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: File_userMaxAggregateInputType
  }

  export type GetFile_userAggregateType<T extends File_userAggregateArgs> = {
        [P in keyof T & keyof AggregateFile_user]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFile_user[P]>
      : GetScalarType<T[P], AggregateFile_user[P]>
  }




  export type file_userGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: file_userWhereInput
    orderBy?: file_userOrderByWithAggregationInput | file_userOrderByWithAggregationInput[]
    by: File_userScalarFieldEnum[] | File_userScalarFieldEnum
    having?: file_userScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: File_userCountAggregateInputType | true
    _min?: File_userMinAggregateInputType
    _max?: File_userMaxAggregateInputType
  }

  export type File_userGroupByOutputType = {
    uid: string
    createAt: Date
    updateAt: Date
    name: string
    is_admin: boolean
    _count: File_userCountAggregateOutputType | null
    _min: File_userMinAggregateOutputType | null
    _max: File_userMaxAggregateOutputType | null
  }

  type GetFile_userGroupByPayload<T extends file_userGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<File_userGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof File_userGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], File_userGroupByOutputType[P]>
            : GetScalarType<T[P], File_userGroupByOutputType[P]>
        }
      >
    >


  export type file_userSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    uid?: boolean
    createAt?: boolean
    updateAt?: boolean
    name?: boolean
    is_admin?: boolean
    medias?: boolean | file_user$mediasArgs<ExtArgs>
    folders?: boolean | file_user$foldersArgs<ExtArgs>
    file_config?: boolean | file_user$file_configArgs<ExtArgs>
    keys?: boolean | file_user$keysArgs<ExtArgs>
    _count?: boolean | File_userCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["file_user"]>



  export type file_userSelectScalar = {
    uid?: boolean
    createAt?: boolean
    updateAt?: boolean
    name?: boolean
    is_admin?: boolean
  }

  export type file_userOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"uid" | "createAt" | "updateAt" | "name" | "is_admin", ExtArgs["result"]["file_user"]>
  export type file_userInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    medias?: boolean | file_user$mediasArgs<ExtArgs>
    folders?: boolean | file_user$foldersArgs<ExtArgs>
    file_config?: boolean | file_user$file_configArgs<ExtArgs>
    keys?: boolean | file_user$keysArgs<ExtArgs>
    _count?: boolean | File_userCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $file_userPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "file_user"
    objects: {
      medias: Prisma.$file_user_on_mediaPayload<ExtArgs>[]
      folders: Prisma.$file_folderPayload<ExtArgs>[]
      file_config: Prisma.$file_configPayload<ExtArgs> | null
      keys: Prisma.$file_keysPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      uid: string
      createAt: Date
      updateAt: Date
      name: string
      is_admin: boolean
    }, ExtArgs["result"]["file_user"]>
    composites: {}
  }

  type file_userGetPayload<S extends boolean | null | undefined | file_userDefaultArgs> = $Result.GetResult<Prisma.$file_userPayload, S>

  type file_userCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<file_userFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: File_userCountAggregateInputType | true
    }

  export interface file_userDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['file_user'], meta: { name: 'file_user' } }
    /**
     * Find zero or one File_user that matches the filter.
     * @param {file_userFindUniqueArgs} args - Arguments to find a File_user
     * @example
     * // Get one File_user
     * const file_user = await prisma.file_user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends file_userFindUniqueArgs>(args: SelectSubset<T, file_userFindUniqueArgs<ExtArgs>>): Prisma__file_userClient<$Result.GetResult<Prisma.$file_userPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one File_user that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {file_userFindUniqueOrThrowArgs} args - Arguments to find a File_user
     * @example
     * // Get one File_user
     * const file_user = await prisma.file_user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends file_userFindUniqueOrThrowArgs>(args: SelectSubset<T, file_userFindUniqueOrThrowArgs<ExtArgs>>): Prisma__file_userClient<$Result.GetResult<Prisma.$file_userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first File_user that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {file_userFindFirstArgs} args - Arguments to find a File_user
     * @example
     * // Get one File_user
     * const file_user = await prisma.file_user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends file_userFindFirstArgs>(args?: SelectSubset<T, file_userFindFirstArgs<ExtArgs>>): Prisma__file_userClient<$Result.GetResult<Prisma.$file_userPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first File_user that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {file_userFindFirstOrThrowArgs} args - Arguments to find a File_user
     * @example
     * // Get one File_user
     * const file_user = await prisma.file_user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends file_userFindFirstOrThrowArgs>(args?: SelectSubset<T, file_userFindFirstOrThrowArgs<ExtArgs>>): Prisma__file_userClient<$Result.GetResult<Prisma.$file_userPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more File_users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {file_userFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all File_users
     * const file_users = await prisma.file_user.findMany()
     * 
     * // Get first 10 File_users
     * const file_users = await prisma.file_user.findMany({ take: 10 })
     * 
     * // Only select the `uid`
     * const file_userWithUidOnly = await prisma.file_user.findMany({ select: { uid: true } })
     * 
     */
    findMany<T extends file_userFindManyArgs>(args?: SelectSubset<T, file_userFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$file_userPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a File_user.
     * @param {file_userCreateArgs} args - Arguments to create a File_user.
     * @example
     * // Create one File_user
     * const File_user = await prisma.file_user.create({
     *   data: {
     *     // ... data to create a File_user
     *   }
     * })
     * 
     */
    create<T extends file_userCreateArgs>(args: SelectSubset<T, file_userCreateArgs<ExtArgs>>): Prisma__file_userClient<$Result.GetResult<Prisma.$file_userPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many File_users.
     * @param {file_userCreateManyArgs} args - Arguments to create many File_users.
     * @example
     * // Create many File_users
     * const file_user = await prisma.file_user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends file_userCreateManyArgs>(args?: SelectSubset<T, file_userCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a File_user.
     * @param {file_userDeleteArgs} args - Arguments to delete one File_user.
     * @example
     * // Delete one File_user
     * const File_user = await prisma.file_user.delete({
     *   where: {
     *     // ... filter to delete one File_user
     *   }
     * })
     * 
     */
    delete<T extends file_userDeleteArgs>(args: SelectSubset<T, file_userDeleteArgs<ExtArgs>>): Prisma__file_userClient<$Result.GetResult<Prisma.$file_userPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one File_user.
     * @param {file_userUpdateArgs} args - Arguments to update one File_user.
     * @example
     * // Update one File_user
     * const file_user = await prisma.file_user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends file_userUpdateArgs>(args: SelectSubset<T, file_userUpdateArgs<ExtArgs>>): Prisma__file_userClient<$Result.GetResult<Prisma.$file_userPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more File_users.
     * @param {file_userDeleteManyArgs} args - Arguments to filter File_users to delete.
     * @example
     * // Delete a few File_users
     * const { count } = await prisma.file_user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends file_userDeleteManyArgs>(args?: SelectSubset<T, file_userDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more File_users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {file_userUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many File_users
     * const file_user = await prisma.file_user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends file_userUpdateManyArgs>(args: SelectSubset<T, file_userUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one File_user.
     * @param {file_userUpsertArgs} args - Arguments to update or create a File_user.
     * @example
     * // Update or create a File_user
     * const file_user = await prisma.file_user.upsert({
     *   create: {
     *     // ... data to create a File_user
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the File_user we want to update
     *   }
     * })
     */
    upsert<T extends file_userUpsertArgs>(args: SelectSubset<T, file_userUpsertArgs<ExtArgs>>): Prisma__file_userClient<$Result.GetResult<Prisma.$file_userPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of File_users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {file_userCountArgs} args - Arguments to filter File_users to count.
     * @example
     * // Count the number of File_users
     * const count = await prisma.file_user.count({
     *   where: {
     *     // ... the filter for the File_users we want to count
     *   }
     * })
    **/
    count<T extends file_userCountArgs>(
      args?: Subset<T, file_userCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], File_userCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a File_user.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {File_userAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends File_userAggregateArgs>(args: Subset<T, File_userAggregateArgs>): Prisma.PrismaPromise<GetFile_userAggregateType<T>>

    /**
     * Group by File_user.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {file_userGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends file_userGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: file_userGroupByArgs['orderBy'] }
        : { orderBy?: file_userGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, file_userGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFile_userGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the file_user model
   */
  readonly fields: file_userFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for file_user.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__file_userClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    medias<T extends file_user$mediasArgs<ExtArgs> = {}>(args?: Subset<T, file_user$mediasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$file_user_on_mediaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    folders<T extends file_user$foldersArgs<ExtArgs> = {}>(args?: Subset<T, file_user$foldersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$file_folderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    file_config<T extends file_user$file_configArgs<ExtArgs> = {}>(args?: Subset<T, file_user$file_configArgs<ExtArgs>>): Prisma__file_configClient<$Result.GetResult<Prisma.$file_configPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    keys<T extends file_user$keysArgs<ExtArgs> = {}>(args?: Subset<T, file_user$keysArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$file_keysPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the file_user model
   */
  interface file_userFieldRefs {
    readonly uid: FieldRef<"file_user", 'String'>
    readonly createAt: FieldRef<"file_user", 'DateTime'>
    readonly updateAt: FieldRef<"file_user", 'DateTime'>
    readonly name: FieldRef<"file_user", 'String'>
    readonly is_admin: FieldRef<"file_user", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * file_user findUnique
   */
  export type file_userFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the file_user
     */
    select?: file_userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the file_user
     */
    omit?: file_userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: file_userInclude<ExtArgs> | null
    /**
     * Filter, which file_user to fetch.
     */
    where: file_userWhereUniqueInput
  }

  /**
   * file_user findUniqueOrThrow
   */
  export type file_userFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the file_user
     */
    select?: file_userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the file_user
     */
    omit?: file_userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: file_userInclude<ExtArgs> | null
    /**
     * Filter, which file_user to fetch.
     */
    where: file_userWhereUniqueInput
  }

  /**
   * file_user findFirst
   */
  export type file_userFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the file_user
     */
    select?: file_userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the file_user
     */
    omit?: file_userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: file_userInclude<ExtArgs> | null
    /**
     * Filter, which file_user to fetch.
     */
    where?: file_userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of file_users to fetch.
     */
    orderBy?: file_userOrderByWithRelationInput | file_userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for file_users.
     */
    cursor?: file_userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` file_users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` file_users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of file_users.
     */
    distinct?: File_userScalarFieldEnum | File_userScalarFieldEnum[]
  }

  /**
   * file_user findFirstOrThrow
   */
  export type file_userFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the file_user
     */
    select?: file_userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the file_user
     */
    omit?: file_userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: file_userInclude<ExtArgs> | null
    /**
     * Filter, which file_user to fetch.
     */
    where?: file_userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of file_users to fetch.
     */
    orderBy?: file_userOrderByWithRelationInput | file_userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for file_users.
     */
    cursor?: file_userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` file_users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` file_users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of file_users.
     */
    distinct?: File_userScalarFieldEnum | File_userScalarFieldEnum[]
  }

  /**
   * file_user findMany
   */
  export type file_userFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the file_user
     */
    select?: file_userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the file_user
     */
    omit?: file_userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: file_userInclude<ExtArgs> | null
    /**
     * Filter, which file_users to fetch.
     */
    where?: file_userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of file_users to fetch.
     */
    orderBy?: file_userOrderByWithRelationInput | file_userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing file_users.
     */
    cursor?: file_userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` file_users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` file_users.
     */
    skip?: number
    distinct?: File_userScalarFieldEnum | File_userScalarFieldEnum[]
  }

  /**
   * file_user create
   */
  export type file_userCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the file_user
     */
    select?: file_userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the file_user
     */
    omit?: file_userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: file_userInclude<ExtArgs> | null
    /**
     * The data needed to create a file_user.
     */
    data: XOR<file_userCreateInput, file_userUncheckedCreateInput>
  }

  /**
   * file_user createMany
   */
  export type file_userCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many file_users.
     */
    data: file_userCreateManyInput | file_userCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * file_user update
   */
  export type file_userUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the file_user
     */
    select?: file_userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the file_user
     */
    omit?: file_userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: file_userInclude<ExtArgs> | null
    /**
     * The data needed to update a file_user.
     */
    data: XOR<file_userUpdateInput, file_userUncheckedUpdateInput>
    /**
     * Choose, which file_user to update.
     */
    where: file_userWhereUniqueInput
  }

  /**
   * file_user updateMany
   */
  export type file_userUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update file_users.
     */
    data: XOR<file_userUpdateManyMutationInput, file_userUncheckedUpdateManyInput>
    /**
     * Filter which file_users to update
     */
    where?: file_userWhereInput
    /**
     * Limit how many file_users to update.
     */
    limit?: number
  }

  /**
   * file_user upsert
   */
  export type file_userUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the file_user
     */
    select?: file_userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the file_user
     */
    omit?: file_userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: file_userInclude<ExtArgs> | null
    /**
     * The filter to search for the file_user to update in case it exists.
     */
    where: file_userWhereUniqueInput
    /**
     * In case the file_user found by the `where` argument doesn't exist, create a new file_user with this data.
     */
    create: XOR<file_userCreateInput, file_userUncheckedCreateInput>
    /**
     * In case the file_user was found with the provided `where` argument, update it with this data.
     */
    update: XOR<file_userUpdateInput, file_userUncheckedUpdateInput>
  }

  /**
   * file_user delete
   */
  export type file_userDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the file_user
     */
    select?: file_userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the file_user
     */
    omit?: file_userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: file_userInclude<ExtArgs> | null
    /**
     * Filter which file_user to delete.
     */
    where: file_userWhereUniqueInput
  }

  /**
   * file_user deleteMany
   */
  export type file_userDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which file_users to delete
     */
    where?: file_userWhereInput
    /**
     * Limit how many file_users to delete.
     */
    limit?: number
  }

  /**
   * file_user.medias
   */
  export type file_user$mediasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the file_user_on_media
     */
    select?: file_user_on_mediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the file_user_on_media
     */
    omit?: file_user_on_mediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: file_user_on_mediaInclude<ExtArgs> | null
    where?: file_user_on_mediaWhereInput
    orderBy?: file_user_on_mediaOrderByWithRelationInput | file_user_on_mediaOrderByWithRelationInput[]
    cursor?: file_user_on_mediaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: File_user_on_mediaScalarFieldEnum | File_user_on_mediaScalarFieldEnum[]
  }

  /**
   * file_user.folders
   */
  export type file_user$foldersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the file_folder
     */
    select?: file_folderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the file_folder
     */
    omit?: file_folderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: file_folderInclude<ExtArgs> | null
    where?: file_folderWhereInput
    orderBy?: file_folderOrderByWithRelationInput | file_folderOrderByWithRelationInput[]
    cursor?: file_folderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: File_folderScalarFieldEnum | File_folderScalarFieldEnum[]
  }

  /**
   * file_user.file_config
   */
  export type file_user$file_configArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the file_config
     */
    select?: file_configSelect<ExtArgs> | null
    /**
     * Omit specific fields from the file_config
     */
    omit?: file_configOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: file_configInclude<ExtArgs> | null
    where?: file_configWhereInput
  }

  /**
   * file_user.keys
   */
  export type file_user$keysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the file_keys
     */
    select?: file_keysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the file_keys
     */
    omit?: file_keysOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: file_keysInclude<ExtArgs> | null
    where?: file_keysWhereInput
    orderBy?: file_keysOrderByWithRelationInput | file_keysOrderByWithRelationInput[]
    cursor?: file_keysWhereUniqueInput
    take?: number
    skip?: number
    distinct?: File_keysScalarFieldEnum | File_keysScalarFieldEnum[]
  }

  /**
   * file_user without action
   */
  export type file_userDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the file_user
     */
    select?: file_userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the file_user
     */
    omit?: file_userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: file_userInclude<ExtArgs> | null
  }


  /**
   * Model file_keys
   */

  export type AggregateFile_keys = {
    _count: File_keysCountAggregateOutputType | null
    _min: File_keysMinAggregateOutputType | null
    _max: File_keysMaxAggregateOutputType | null
  }

  export type File_keysMinAggregateOutputType = {
    api_key: string | null
    api_secret: string | null
    userId: string | null
  }

  export type File_keysMaxAggregateOutputType = {
    api_key: string | null
    api_secret: string | null
    userId: string | null
  }

  export type File_keysCountAggregateOutputType = {
    api_key: number
    api_secret: number
    userId: number
    _all: number
  }


  export type File_keysMinAggregateInputType = {
    api_key?: true
    api_secret?: true
    userId?: true
  }

  export type File_keysMaxAggregateInputType = {
    api_key?: true
    api_secret?: true
    userId?: true
  }

  export type File_keysCountAggregateInputType = {
    api_key?: true
    api_secret?: true
    userId?: true
    _all?: true
  }

  export type File_keysAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which file_keys to aggregate.
     */
    where?: file_keysWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of file_keys to fetch.
     */
    orderBy?: file_keysOrderByWithRelationInput | file_keysOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: file_keysWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` file_keys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` file_keys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned file_keys
    **/
    _count?: true | File_keysCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: File_keysMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: File_keysMaxAggregateInputType
  }

  export type GetFile_keysAggregateType<T extends File_keysAggregateArgs> = {
        [P in keyof T & keyof AggregateFile_keys]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFile_keys[P]>
      : GetScalarType<T[P], AggregateFile_keys[P]>
  }




  export type file_keysGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: file_keysWhereInput
    orderBy?: file_keysOrderByWithAggregationInput | file_keysOrderByWithAggregationInput[]
    by: File_keysScalarFieldEnum[] | File_keysScalarFieldEnum
    having?: file_keysScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: File_keysCountAggregateInputType | true
    _min?: File_keysMinAggregateInputType
    _max?: File_keysMaxAggregateInputType
  }

  export type File_keysGroupByOutputType = {
    api_key: string
    api_secret: string
    userId: string
    _count: File_keysCountAggregateOutputType | null
    _min: File_keysMinAggregateOutputType | null
    _max: File_keysMaxAggregateOutputType | null
  }

  type GetFile_keysGroupByPayload<T extends file_keysGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<File_keysGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof File_keysGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], File_keysGroupByOutputType[P]>
            : GetScalarType<T[P], File_keysGroupByOutputType[P]>
        }
      >
    >


  export type file_keysSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    api_key?: boolean
    api_secret?: boolean
    userId?: boolean
    user?: boolean | file_userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["file_keys"]>



  export type file_keysSelectScalar = {
    api_key?: boolean
    api_secret?: boolean
    userId?: boolean
  }

  export type file_keysOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"api_key" | "api_secret" | "userId", ExtArgs["result"]["file_keys"]>
  export type file_keysInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | file_userDefaultArgs<ExtArgs>
  }

  export type $file_keysPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "file_keys"
    objects: {
      user: Prisma.$file_userPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      api_key: string
      api_secret: string
      userId: string
    }, ExtArgs["result"]["file_keys"]>
    composites: {}
  }

  type file_keysGetPayload<S extends boolean | null | undefined | file_keysDefaultArgs> = $Result.GetResult<Prisma.$file_keysPayload, S>

  type file_keysCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<file_keysFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: File_keysCountAggregateInputType | true
    }

  export interface file_keysDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['file_keys'], meta: { name: 'file_keys' } }
    /**
     * Find zero or one File_keys that matches the filter.
     * @param {file_keysFindUniqueArgs} args - Arguments to find a File_keys
     * @example
     * // Get one File_keys
     * const file_keys = await prisma.file_keys.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends file_keysFindUniqueArgs>(args: SelectSubset<T, file_keysFindUniqueArgs<ExtArgs>>): Prisma__file_keysClient<$Result.GetResult<Prisma.$file_keysPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one File_keys that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {file_keysFindUniqueOrThrowArgs} args - Arguments to find a File_keys
     * @example
     * // Get one File_keys
     * const file_keys = await prisma.file_keys.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends file_keysFindUniqueOrThrowArgs>(args: SelectSubset<T, file_keysFindUniqueOrThrowArgs<ExtArgs>>): Prisma__file_keysClient<$Result.GetResult<Prisma.$file_keysPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first File_keys that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {file_keysFindFirstArgs} args - Arguments to find a File_keys
     * @example
     * // Get one File_keys
     * const file_keys = await prisma.file_keys.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends file_keysFindFirstArgs>(args?: SelectSubset<T, file_keysFindFirstArgs<ExtArgs>>): Prisma__file_keysClient<$Result.GetResult<Prisma.$file_keysPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first File_keys that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {file_keysFindFirstOrThrowArgs} args - Arguments to find a File_keys
     * @example
     * // Get one File_keys
     * const file_keys = await prisma.file_keys.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends file_keysFindFirstOrThrowArgs>(args?: SelectSubset<T, file_keysFindFirstOrThrowArgs<ExtArgs>>): Prisma__file_keysClient<$Result.GetResult<Prisma.$file_keysPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more File_keys that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {file_keysFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all File_keys
     * const file_keys = await prisma.file_keys.findMany()
     * 
     * // Get first 10 File_keys
     * const file_keys = await prisma.file_keys.findMany({ take: 10 })
     * 
     * // Only select the `api_key`
     * const file_keysWithApi_keyOnly = await prisma.file_keys.findMany({ select: { api_key: true } })
     * 
     */
    findMany<T extends file_keysFindManyArgs>(args?: SelectSubset<T, file_keysFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$file_keysPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a File_keys.
     * @param {file_keysCreateArgs} args - Arguments to create a File_keys.
     * @example
     * // Create one File_keys
     * const File_keys = await prisma.file_keys.create({
     *   data: {
     *     // ... data to create a File_keys
     *   }
     * })
     * 
     */
    create<T extends file_keysCreateArgs>(args: SelectSubset<T, file_keysCreateArgs<ExtArgs>>): Prisma__file_keysClient<$Result.GetResult<Prisma.$file_keysPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many File_keys.
     * @param {file_keysCreateManyArgs} args - Arguments to create many File_keys.
     * @example
     * // Create many File_keys
     * const file_keys = await prisma.file_keys.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends file_keysCreateManyArgs>(args?: SelectSubset<T, file_keysCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a File_keys.
     * @param {file_keysDeleteArgs} args - Arguments to delete one File_keys.
     * @example
     * // Delete one File_keys
     * const File_keys = await prisma.file_keys.delete({
     *   where: {
     *     // ... filter to delete one File_keys
     *   }
     * })
     * 
     */
    delete<T extends file_keysDeleteArgs>(args: SelectSubset<T, file_keysDeleteArgs<ExtArgs>>): Prisma__file_keysClient<$Result.GetResult<Prisma.$file_keysPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one File_keys.
     * @param {file_keysUpdateArgs} args - Arguments to update one File_keys.
     * @example
     * // Update one File_keys
     * const file_keys = await prisma.file_keys.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends file_keysUpdateArgs>(args: SelectSubset<T, file_keysUpdateArgs<ExtArgs>>): Prisma__file_keysClient<$Result.GetResult<Prisma.$file_keysPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more File_keys.
     * @param {file_keysDeleteManyArgs} args - Arguments to filter File_keys to delete.
     * @example
     * // Delete a few File_keys
     * const { count } = await prisma.file_keys.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends file_keysDeleteManyArgs>(args?: SelectSubset<T, file_keysDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more File_keys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {file_keysUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many File_keys
     * const file_keys = await prisma.file_keys.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends file_keysUpdateManyArgs>(args: SelectSubset<T, file_keysUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one File_keys.
     * @param {file_keysUpsertArgs} args - Arguments to update or create a File_keys.
     * @example
     * // Update or create a File_keys
     * const file_keys = await prisma.file_keys.upsert({
     *   create: {
     *     // ... data to create a File_keys
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the File_keys we want to update
     *   }
     * })
     */
    upsert<T extends file_keysUpsertArgs>(args: SelectSubset<T, file_keysUpsertArgs<ExtArgs>>): Prisma__file_keysClient<$Result.GetResult<Prisma.$file_keysPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of File_keys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {file_keysCountArgs} args - Arguments to filter File_keys to count.
     * @example
     * // Count the number of File_keys
     * const count = await prisma.file_keys.count({
     *   where: {
     *     // ... the filter for the File_keys we want to count
     *   }
     * })
    **/
    count<T extends file_keysCountArgs>(
      args?: Subset<T, file_keysCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], File_keysCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a File_keys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {File_keysAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends File_keysAggregateArgs>(args: Subset<T, File_keysAggregateArgs>): Prisma.PrismaPromise<GetFile_keysAggregateType<T>>

    /**
     * Group by File_keys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {file_keysGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends file_keysGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: file_keysGroupByArgs['orderBy'] }
        : { orderBy?: file_keysGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, file_keysGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFile_keysGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the file_keys model
   */
  readonly fields: file_keysFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for file_keys.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__file_keysClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends file_userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, file_userDefaultArgs<ExtArgs>>): Prisma__file_userClient<$Result.GetResult<Prisma.$file_userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the file_keys model
   */
  interface file_keysFieldRefs {
    readonly api_key: FieldRef<"file_keys", 'String'>
    readonly api_secret: FieldRef<"file_keys", 'String'>
    readonly userId: FieldRef<"file_keys", 'String'>
  }
    

  // Custom InputTypes
  /**
   * file_keys findUnique
   */
  export type file_keysFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the file_keys
     */
    select?: file_keysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the file_keys
     */
    omit?: file_keysOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: file_keysInclude<ExtArgs> | null
    /**
     * Filter, which file_keys to fetch.
     */
    where: file_keysWhereUniqueInput
  }

  /**
   * file_keys findUniqueOrThrow
   */
  export type file_keysFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the file_keys
     */
    select?: file_keysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the file_keys
     */
    omit?: file_keysOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: file_keysInclude<ExtArgs> | null
    /**
     * Filter, which file_keys to fetch.
     */
    where: file_keysWhereUniqueInput
  }

  /**
   * file_keys findFirst
   */
  export type file_keysFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the file_keys
     */
    select?: file_keysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the file_keys
     */
    omit?: file_keysOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: file_keysInclude<ExtArgs> | null
    /**
     * Filter, which file_keys to fetch.
     */
    where?: file_keysWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of file_keys to fetch.
     */
    orderBy?: file_keysOrderByWithRelationInput | file_keysOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for file_keys.
     */
    cursor?: file_keysWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` file_keys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` file_keys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of file_keys.
     */
    distinct?: File_keysScalarFieldEnum | File_keysScalarFieldEnum[]
  }

  /**
   * file_keys findFirstOrThrow
   */
  export type file_keysFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the file_keys
     */
    select?: file_keysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the file_keys
     */
    omit?: file_keysOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: file_keysInclude<ExtArgs> | null
    /**
     * Filter, which file_keys to fetch.
     */
    where?: file_keysWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of file_keys to fetch.
     */
    orderBy?: file_keysOrderByWithRelationInput | file_keysOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for file_keys.
     */
    cursor?: file_keysWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` file_keys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` file_keys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of file_keys.
     */
    distinct?: File_keysScalarFieldEnum | File_keysScalarFieldEnum[]
  }

  /**
   * file_keys findMany
   */
  export type file_keysFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the file_keys
     */
    select?: file_keysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the file_keys
     */
    omit?: file_keysOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: file_keysInclude<ExtArgs> | null
    /**
     * Filter, which file_keys to fetch.
     */
    where?: file_keysWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of file_keys to fetch.
     */
    orderBy?: file_keysOrderByWithRelationInput | file_keysOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing file_keys.
     */
    cursor?: file_keysWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` file_keys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` file_keys.
     */
    skip?: number
    distinct?: File_keysScalarFieldEnum | File_keysScalarFieldEnum[]
  }

  /**
   * file_keys create
   */
  export type file_keysCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the file_keys
     */
    select?: file_keysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the file_keys
     */
    omit?: file_keysOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: file_keysInclude<ExtArgs> | null
    /**
     * The data needed to create a file_keys.
     */
    data: XOR<file_keysCreateInput, file_keysUncheckedCreateInput>
  }

  /**
   * file_keys createMany
   */
  export type file_keysCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many file_keys.
     */
    data: file_keysCreateManyInput | file_keysCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * file_keys update
   */
  export type file_keysUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the file_keys
     */
    select?: file_keysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the file_keys
     */
    omit?: file_keysOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: file_keysInclude<ExtArgs> | null
    /**
     * The data needed to update a file_keys.
     */
    data: XOR<file_keysUpdateInput, file_keysUncheckedUpdateInput>
    /**
     * Choose, which file_keys to update.
     */
    where: file_keysWhereUniqueInput
  }

  /**
   * file_keys updateMany
   */
  export type file_keysUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update file_keys.
     */
    data: XOR<file_keysUpdateManyMutationInput, file_keysUncheckedUpdateManyInput>
    /**
     * Filter which file_keys to update
     */
    where?: file_keysWhereInput
    /**
     * Limit how many file_keys to update.
     */
    limit?: number
  }

  /**
   * file_keys upsert
   */
  export type file_keysUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the file_keys
     */
    select?: file_keysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the file_keys
     */
    omit?: file_keysOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: file_keysInclude<ExtArgs> | null
    /**
     * The filter to search for the file_keys to update in case it exists.
     */
    where: file_keysWhereUniqueInput
    /**
     * In case the file_keys found by the `where` argument doesn't exist, create a new file_keys with this data.
     */
    create: XOR<file_keysCreateInput, file_keysUncheckedCreateInput>
    /**
     * In case the file_keys was found with the provided `where` argument, update it with this data.
     */
    update: XOR<file_keysUpdateInput, file_keysUncheckedUpdateInput>
  }

  /**
   * file_keys delete
   */
  export type file_keysDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the file_keys
     */
    select?: file_keysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the file_keys
     */
    omit?: file_keysOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: file_keysInclude<ExtArgs> | null
    /**
     * Filter which file_keys to delete.
     */
    where: file_keysWhereUniqueInput
  }

  /**
   * file_keys deleteMany
   */
  export type file_keysDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which file_keys to delete
     */
    where?: file_keysWhereInput
    /**
     * Limit how many file_keys to delete.
     */
    limit?: number
  }

  /**
   * file_keys without action
   */
  export type file_keysDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the file_keys
     */
    select?: file_keysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the file_keys
     */
    omit?: file_keysOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: file_keysInclude<ExtArgs> | null
  }


  /**
   * Model file_config
   */

  export type AggregateFile_config = {
    _count: File_configCountAggregateOutputType | null
    _min: File_configMinAggregateOutputType | null
    _max: File_configMaxAggregateOutputType | null
  }

  export type File_configMinAggregateOutputType = {
    uid: string | null
    userId: string | null
  }

  export type File_configMaxAggregateOutputType = {
    uid: string | null
    userId: string | null
  }

  export type File_configCountAggregateOutputType = {
    uid: number
    userId: number
    _all: number
  }


  export type File_configMinAggregateInputType = {
    uid?: true
    userId?: true
  }

  export type File_configMaxAggregateInputType = {
    uid?: true
    userId?: true
  }

  export type File_configCountAggregateInputType = {
    uid?: true
    userId?: true
    _all?: true
  }

  export type File_configAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which file_config to aggregate.
     */
    where?: file_configWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of file_configs to fetch.
     */
    orderBy?: file_configOrderByWithRelationInput | file_configOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: file_configWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` file_configs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` file_configs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned file_configs
    **/
    _count?: true | File_configCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: File_configMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: File_configMaxAggregateInputType
  }

  export type GetFile_configAggregateType<T extends File_configAggregateArgs> = {
        [P in keyof T & keyof AggregateFile_config]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFile_config[P]>
      : GetScalarType<T[P], AggregateFile_config[P]>
  }




  export type file_configGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: file_configWhereInput
    orderBy?: file_configOrderByWithAggregationInput | file_configOrderByWithAggregationInput[]
    by: File_configScalarFieldEnum[] | File_configScalarFieldEnum
    having?: file_configScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: File_configCountAggregateInputType | true
    _min?: File_configMinAggregateInputType
    _max?: File_configMaxAggregateInputType
  }

  export type File_configGroupByOutputType = {
    uid: string
    userId: string
    _count: File_configCountAggregateOutputType | null
    _min: File_configMinAggregateOutputType | null
    _max: File_configMaxAggregateOutputType | null
  }

  type GetFile_configGroupByPayload<T extends file_configGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<File_configGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof File_configGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], File_configGroupByOutputType[P]>
            : GetScalarType<T[P], File_configGroupByOutputType[P]>
        }
      >
    >


  export type file_configSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    uid?: boolean
    userId?: boolean
    user?: boolean | file_userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["file_config"]>



  export type file_configSelectScalar = {
    uid?: boolean
    userId?: boolean
  }

  export type file_configOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"uid" | "userId", ExtArgs["result"]["file_config"]>
  export type file_configInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | file_userDefaultArgs<ExtArgs>
  }

  export type $file_configPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "file_config"
    objects: {
      user: Prisma.$file_userPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      uid: string
      userId: string
    }, ExtArgs["result"]["file_config"]>
    composites: {}
  }

  type file_configGetPayload<S extends boolean | null | undefined | file_configDefaultArgs> = $Result.GetResult<Prisma.$file_configPayload, S>

  type file_configCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<file_configFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: File_configCountAggregateInputType | true
    }

  export interface file_configDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['file_config'], meta: { name: 'file_config' } }
    /**
     * Find zero or one File_config that matches the filter.
     * @param {file_configFindUniqueArgs} args - Arguments to find a File_config
     * @example
     * // Get one File_config
     * const file_config = await prisma.file_config.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends file_configFindUniqueArgs>(args: SelectSubset<T, file_configFindUniqueArgs<ExtArgs>>): Prisma__file_configClient<$Result.GetResult<Prisma.$file_configPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one File_config that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {file_configFindUniqueOrThrowArgs} args - Arguments to find a File_config
     * @example
     * // Get one File_config
     * const file_config = await prisma.file_config.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends file_configFindUniqueOrThrowArgs>(args: SelectSubset<T, file_configFindUniqueOrThrowArgs<ExtArgs>>): Prisma__file_configClient<$Result.GetResult<Prisma.$file_configPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first File_config that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {file_configFindFirstArgs} args - Arguments to find a File_config
     * @example
     * // Get one File_config
     * const file_config = await prisma.file_config.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends file_configFindFirstArgs>(args?: SelectSubset<T, file_configFindFirstArgs<ExtArgs>>): Prisma__file_configClient<$Result.GetResult<Prisma.$file_configPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first File_config that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {file_configFindFirstOrThrowArgs} args - Arguments to find a File_config
     * @example
     * // Get one File_config
     * const file_config = await prisma.file_config.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends file_configFindFirstOrThrowArgs>(args?: SelectSubset<T, file_configFindFirstOrThrowArgs<ExtArgs>>): Prisma__file_configClient<$Result.GetResult<Prisma.$file_configPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more File_configs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {file_configFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all File_configs
     * const file_configs = await prisma.file_config.findMany()
     * 
     * // Get first 10 File_configs
     * const file_configs = await prisma.file_config.findMany({ take: 10 })
     * 
     * // Only select the `uid`
     * const file_configWithUidOnly = await prisma.file_config.findMany({ select: { uid: true } })
     * 
     */
    findMany<T extends file_configFindManyArgs>(args?: SelectSubset<T, file_configFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$file_configPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a File_config.
     * @param {file_configCreateArgs} args - Arguments to create a File_config.
     * @example
     * // Create one File_config
     * const File_config = await prisma.file_config.create({
     *   data: {
     *     // ... data to create a File_config
     *   }
     * })
     * 
     */
    create<T extends file_configCreateArgs>(args: SelectSubset<T, file_configCreateArgs<ExtArgs>>): Prisma__file_configClient<$Result.GetResult<Prisma.$file_configPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many File_configs.
     * @param {file_configCreateManyArgs} args - Arguments to create many File_configs.
     * @example
     * // Create many File_configs
     * const file_config = await prisma.file_config.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends file_configCreateManyArgs>(args?: SelectSubset<T, file_configCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a File_config.
     * @param {file_configDeleteArgs} args - Arguments to delete one File_config.
     * @example
     * // Delete one File_config
     * const File_config = await prisma.file_config.delete({
     *   where: {
     *     // ... filter to delete one File_config
     *   }
     * })
     * 
     */
    delete<T extends file_configDeleteArgs>(args: SelectSubset<T, file_configDeleteArgs<ExtArgs>>): Prisma__file_configClient<$Result.GetResult<Prisma.$file_configPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one File_config.
     * @param {file_configUpdateArgs} args - Arguments to update one File_config.
     * @example
     * // Update one File_config
     * const file_config = await prisma.file_config.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends file_configUpdateArgs>(args: SelectSubset<T, file_configUpdateArgs<ExtArgs>>): Prisma__file_configClient<$Result.GetResult<Prisma.$file_configPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more File_configs.
     * @param {file_configDeleteManyArgs} args - Arguments to filter File_configs to delete.
     * @example
     * // Delete a few File_configs
     * const { count } = await prisma.file_config.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends file_configDeleteManyArgs>(args?: SelectSubset<T, file_configDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more File_configs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {file_configUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many File_configs
     * const file_config = await prisma.file_config.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends file_configUpdateManyArgs>(args: SelectSubset<T, file_configUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one File_config.
     * @param {file_configUpsertArgs} args - Arguments to update or create a File_config.
     * @example
     * // Update or create a File_config
     * const file_config = await prisma.file_config.upsert({
     *   create: {
     *     // ... data to create a File_config
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the File_config we want to update
     *   }
     * })
     */
    upsert<T extends file_configUpsertArgs>(args: SelectSubset<T, file_configUpsertArgs<ExtArgs>>): Prisma__file_configClient<$Result.GetResult<Prisma.$file_configPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of File_configs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {file_configCountArgs} args - Arguments to filter File_configs to count.
     * @example
     * // Count the number of File_configs
     * const count = await prisma.file_config.count({
     *   where: {
     *     // ... the filter for the File_configs we want to count
     *   }
     * })
    **/
    count<T extends file_configCountArgs>(
      args?: Subset<T, file_configCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], File_configCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a File_config.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {File_configAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends File_configAggregateArgs>(args: Subset<T, File_configAggregateArgs>): Prisma.PrismaPromise<GetFile_configAggregateType<T>>

    /**
     * Group by File_config.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {file_configGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends file_configGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: file_configGroupByArgs['orderBy'] }
        : { orderBy?: file_configGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, file_configGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFile_configGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the file_config model
   */
  readonly fields: file_configFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for file_config.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__file_configClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends file_userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, file_userDefaultArgs<ExtArgs>>): Prisma__file_userClient<$Result.GetResult<Prisma.$file_userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the file_config model
   */
  interface file_configFieldRefs {
    readonly uid: FieldRef<"file_config", 'String'>
    readonly userId: FieldRef<"file_config", 'String'>
  }
    

  // Custom InputTypes
  /**
   * file_config findUnique
   */
  export type file_configFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the file_config
     */
    select?: file_configSelect<ExtArgs> | null
    /**
     * Omit specific fields from the file_config
     */
    omit?: file_configOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: file_configInclude<ExtArgs> | null
    /**
     * Filter, which file_config to fetch.
     */
    where: file_configWhereUniqueInput
  }

  /**
   * file_config findUniqueOrThrow
   */
  export type file_configFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the file_config
     */
    select?: file_configSelect<ExtArgs> | null
    /**
     * Omit specific fields from the file_config
     */
    omit?: file_configOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: file_configInclude<ExtArgs> | null
    /**
     * Filter, which file_config to fetch.
     */
    where: file_configWhereUniqueInput
  }

  /**
   * file_config findFirst
   */
  export type file_configFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the file_config
     */
    select?: file_configSelect<ExtArgs> | null
    /**
     * Omit specific fields from the file_config
     */
    omit?: file_configOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: file_configInclude<ExtArgs> | null
    /**
     * Filter, which file_config to fetch.
     */
    where?: file_configWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of file_configs to fetch.
     */
    orderBy?: file_configOrderByWithRelationInput | file_configOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for file_configs.
     */
    cursor?: file_configWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` file_configs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` file_configs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of file_configs.
     */
    distinct?: File_configScalarFieldEnum | File_configScalarFieldEnum[]
  }

  /**
   * file_config findFirstOrThrow
   */
  export type file_configFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the file_config
     */
    select?: file_configSelect<ExtArgs> | null
    /**
     * Omit specific fields from the file_config
     */
    omit?: file_configOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: file_configInclude<ExtArgs> | null
    /**
     * Filter, which file_config to fetch.
     */
    where?: file_configWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of file_configs to fetch.
     */
    orderBy?: file_configOrderByWithRelationInput | file_configOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for file_configs.
     */
    cursor?: file_configWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` file_configs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` file_configs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of file_configs.
     */
    distinct?: File_configScalarFieldEnum | File_configScalarFieldEnum[]
  }

  /**
   * file_config findMany
   */
  export type file_configFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the file_config
     */
    select?: file_configSelect<ExtArgs> | null
    /**
     * Omit specific fields from the file_config
     */
    omit?: file_configOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: file_configInclude<ExtArgs> | null
    /**
     * Filter, which file_configs to fetch.
     */
    where?: file_configWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of file_configs to fetch.
     */
    orderBy?: file_configOrderByWithRelationInput | file_configOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing file_configs.
     */
    cursor?: file_configWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` file_configs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` file_configs.
     */
    skip?: number
    distinct?: File_configScalarFieldEnum | File_configScalarFieldEnum[]
  }

  /**
   * file_config create
   */
  export type file_configCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the file_config
     */
    select?: file_configSelect<ExtArgs> | null
    /**
     * Omit specific fields from the file_config
     */
    omit?: file_configOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: file_configInclude<ExtArgs> | null
    /**
     * The data needed to create a file_config.
     */
    data: XOR<file_configCreateInput, file_configUncheckedCreateInput>
  }

  /**
   * file_config createMany
   */
  export type file_configCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many file_configs.
     */
    data: file_configCreateManyInput | file_configCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * file_config update
   */
  export type file_configUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the file_config
     */
    select?: file_configSelect<ExtArgs> | null
    /**
     * Omit specific fields from the file_config
     */
    omit?: file_configOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: file_configInclude<ExtArgs> | null
    /**
     * The data needed to update a file_config.
     */
    data: XOR<file_configUpdateInput, file_configUncheckedUpdateInput>
    /**
     * Choose, which file_config to update.
     */
    where: file_configWhereUniqueInput
  }

  /**
   * file_config updateMany
   */
  export type file_configUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update file_configs.
     */
    data: XOR<file_configUpdateManyMutationInput, file_configUncheckedUpdateManyInput>
    /**
     * Filter which file_configs to update
     */
    where?: file_configWhereInput
    /**
     * Limit how many file_configs to update.
     */
    limit?: number
  }

  /**
   * file_config upsert
   */
  export type file_configUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the file_config
     */
    select?: file_configSelect<ExtArgs> | null
    /**
     * Omit specific fields from the file_config
     */
    omit?: file_configOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: file_configInclude<ExtArgs> | null
    /**
     * The filter to search for the file_config to update in case it exists.
     */
    where: file_configWhereUniqueInput
    /**
     * In case the file_config found by the `where` argument doesn't exist, create a new file_config with this data.
     */
    create: XOR<file_configCreateInput, file_configUncheckedCreateInput>
    /**
     * In case the file_config was found with the provided `where` argument, update it with this data.
     */
    update: XOR<file_configUpdateInput, file_configUncheckedUpdateInput>
  }

  /**
   * file_config delete
   */
  export type file_configDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the file_config
     */
    select?: file_configSelect<ExtArgs> | null
    /**
     * Omit specific fields from the file_config
     */
    omit?: file_configOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: file_configInclude<ExtArgs> | null
    /**
     * Filter which file_config to delete.
     */
    where: file_configWhereUniqueInput
  }

  /**
   * file_config deleteMany
   */
  export type file_configDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which file_configs to delete
     */
    where?: file_configWhereInput
    /**
     * Limit how many file_configs to delete.
     */
    limit?: number
  }

  /**
   * file_config without action
   */
  export type file_configDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the file_config
     */
    select?: file_configSelect<ExtArgs> | null
    /**
     * Omit specific fields from the file_config
     */
    omit?: file_configOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: file_configInclude<ExtArgs> | null
  }


  /**
   * Model file_user_on_media
   */

  export type AggregateFile_user_on_media = {
    _count: File_user_on_mediaCountAggregateOutputType | null
    _min: File_user_on_mediaMinAggregateOutputType | null
    _max: File_user_on_mediaMaxAggregateOutputType | null
  }

  export type File_user_on_mediaMinAggregateOutputType = {
    userId: string | null
    mediaId: string | null
    comment: string | null
  }

  export type File_user_on_mediaMaxAggregateOutputType = {
    userId: string | null
    mediaId: string | null
    comment: string | null
  }

  export type File_user_on_mediaCountAggregateOutputType = {
    userId: number
    mediaId: number
    comment: number
    _all: number
  }


  export type File_user_on_mediaMinAggregateInputType = {
    userId?: true
    mediaId?: true
    comment?: true
  }

  export type File_user_on_mediaMaxAggregateInputType = {
    userId?: true
    mediaId?: true
    comment?: true
  }

  export type File_user_on_mediaCountAggregateInputType = {
    userId?: true
    mediaId?: true
    comment?: true
    _all?: true
  }

  export type File_user_on_mediaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which file_user_on_media to aggregate.
     */
    where?: file_user_on_mediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of file_user_on_medias to fetch.
     */
    orderBy?: file_user_on_mediaOrderByWithRelationInput | file_user_on_mediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: file_user_on_mediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` file_user_on_medias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` file_user_on_medias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned file_user_on_medias
    **/
    _count?: true | File_user_on_mediaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: File_user_on_mediaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: File_user_on_mediaMaxAggregateInputType
  }

  export type GetFile_user_on_mediaAggregateType<T extends File_user_on_mediaAggregateArgs> = {
        [P in keyof T & keyof AggregateFile_user_on_media]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFile_user_on_media[P]>
      : GetScalarType<T[P], AggregateFile_user_on_media[P]>
  }




  export type file_user_on_mediaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: file_user_on_mediaWhereInput
    orderBy?: file_user_on_mediaOrderByWithAggregationInput | file_user_on_mediaOrderByWithAggregationInput[]
    by: File_user_on_mediaScalarFieldEnum[] | File_user_on_mediaScalarFieldEnum
    having?: file_user_on_mediaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: File_user_on_mediaCountAggregateInputType | true
    _min?: File_user_on_mediaMinAggregateInputType
    _max?: File_user_on_mediaMaxAggregateInputType
  }

  export type File_user_on_mediaGroupByOutputType = {
    userId: string
    mediaId: string
    comment: string | null
    _count: File_user_on_mediaCountAggregateOutputType | null
    _min: File_user_on_mediaMinAggregateOutputType | null
    _max: File_user_on_mediaMaxAggregateOutputType | null
  }

  type GetFile_user_on_mediaGroupByPayload<T extends file_user_on_mediaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<File_user_on_mediaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof File_user_on_mediaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], File_user_on_mediaGroupByOutputType[P]>
            : GetScalarType<T[P], File_user_on_mediaGroupByOutputType[P]>
        }
      >
    >


  export type file_user_on_mediaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    mediaId?: boolean
    comment?: boolean
    user?: boolean | file_userDefaultArgs<ExtArgs>
    media?: boolean | file_mediaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["file_user_on_media"]>



  export type file_user_on_mediaSelectScalar = {
    userId?: boolean
    mediaId?: boolean
    comment?: boolean
  }

  export type file_user_on_mediaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"userId" | "mediaId" | "comment", ExtArgs["result"]["file_user_on_media"]>
  export type file_user_on_mediaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | file_userDefaultArgs<ExtArgs>
    media?: boolean | file_mediaDefaultArgs<ExtArgs>
  }

  export type $file_user_on_mediaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "file_user_on_media"
    objects: {
      user: Prisma.$file_userPayload<ExtArgs>
      media: Prisma.$file_mediaPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: string
      mediaId: string
      comment: string | null
    }, ExtArgs["result"]["file_user_on_media"]>
    composites: {}
  }

  type file_user_on_mediaGetPayload<S extends boolean | null | undefined | file_user_on_mediaDefaultArgs> = $Result.GetResult<Prisma.$file_user_on_mediaPayload, S>

  type file_user_on_mediaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<file_user_on_mediaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: File_user_on_mediaCountAggregateInputType | true
    }

  export interface file_user_on_mediaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['file_user_on_media'], meta: { name: 'file_user_on_media' } }
    /**
     * Find zero or one File_user_on_media that matches the filter.
     * @param {file_user_on_mediaFindUniqueArgs} args - Arguments to find a File_user_on_media
     * @example
     * // Get one File_user_on_media
     * const file_user_on_media = await prisma.file_user_on_media.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends file_user_on_mediaFindUniqueArgs>(args: SelectSubset<T, file_user_on_mediaFindUniqueArgs<ExtArgs>>): Prisma__file_user_on_mediaClient<$Result.GetResult<Prisma.$file_user_on_mediaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one File_user_on_media that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {file_user_on_mediaFindUniqueOrThrowArgs} args - Arguments to find a File_user_on_media
     * @example
     * // Get one File_user_on_media
     * const file_user_on_media = await prisma.file_user_on_media.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends file_user_on_mediaFindUniqueOrThrowArgs>(args: SelectSubset<T, file_user_on_mediaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__file_user_on_mediaClient<$Result.GetResult<Prisma.$file_user_on_mediaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first File_user_on_media that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {file_user_on_mediaFindFirstArgs} args - Arguments to find a File_user_on_media
     * @example
     * // Get one File_user_on_media
     * const file_user_on_media = await prisma.file_user_on_media.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends file_user_on_mediaFindFirstArgs>(args?: SelectSubset<T, file_user_on_mediaFindFirstArgs<ExtArgs>>): Prisma__file_user_on_mediaClient<$Result.GetResult<Prisma.$file_user_on_mediaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first File_user_on_media that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {file_user_on_mediaFindFirstOrThrowArgs} args - Arguments to find a File_user_on_media
     * @example
     * // Get one File_user_on_media
     * const file_user_on_media = await prisma.file_user_on_media.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends file_user_on_mediaFindFirstOrThrowArgs>(args?: SelectSubset<T, file_user_on_mediaFindFirstOrThrowArgs<ExtArgs>>): Prisma__file_user_on_mediaClient<$Result.GetResult<Prisma.$file_user_on_mediaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more File_user_on_medias that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {file_user_on_mediaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all File_user_on_medias
     * const file_user_on_medias = await prisma.file_user_on_media.findMany()
     * 
     * // Get first 10 File_user_on_medias
     * const file_user_on_medias = await prisma.file_user_on_media.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const file_user_on_mediaWithUserIdOnly = await prisma.file_user_on_media.findMany({ select: { userId: true } })
     * 
     */
    findMany<T extends file_user_on_mediaFindManyArgs>(args?: SelectSubset<T, file_user_on_mediaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$file_user_on_mediaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a File_user_on_media.
     * @param {file_user_on_mediaCreateArgs} args - Arguments to create a File_user_on_media.
     * @example
     * // Create one File_user_on_media
     * const File_user_on_media = await prisma.file_user_on_media.create({
     *   data: {
     *     // ... data to create a File_user_on_media
     *   }
     * })
     * 
     */
    create<T extends file_user_on_mediaCreateArgs>(args: SelectSubset<T, file_user_on_mediaCreateArgs<ExtArgs>>): Prisma__file_user_on_mediaClient<$Result.GetResult<Prisma.$file_user_on_mediaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many File_user_on_medias.
     * @param {file_user_on_mediaCreateManyArgs} args - Arguments to create many File_user_on_medias.
     * @example
     * // Create many File_user_on_medias
     * const file_user_on_media = await prisma.file_user_on_media.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends file_user_on_mediaCreateManyArgs>(args?: SelectSubset<T, file_user_on_mediaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a File_user_on_media.
     * @param {file_user_on_mediaDeleteArgs} args - Arguments to delete one File_user_on_media.
     * @example
     * // Delete one File_user_on_media
     * const File_user_on_media = await prisma.file_user_on_media.delete({
     *   where: {
     *     // ... filter to delete one File_user_on_media
     *   }
     * })
     * 
     */
    delete<T extends file_user_on_mediaDeleteArgs>(args: SelectSubset<T, file_user_on_mediaDeleteArgs<ExtArgs>>): Prisma__file_user_on_mediaClient<$Result.GetResult<Prisma.$file_user_on_mediaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one File_user_on_media.
     * @param {file_user_on_mediaUpdateArgs} args - Arguments to update one File_user_on_media.
     * @example
     * // Update one File_user_on_media
     * const file_user_on_media = await prisma.file_user_on_media.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends file_user_on_mediaUpdateArgs>(args: SelectSubset<T, file_user_on_mediaUpdateArgs<ExtArgs>>): Prisma__file_user_on_mediaClient<$Result.GetResult<Prisma.$file_user_on_mediaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more File_user_on_medias.
     * @param {file_user_on_mediaDeleteManyArgs} args - Arguments to filter File_user_on_medias to delete.
     * @example
     * // Delete a few File_user_on_medias
     * const { count } = await prisma.file_user_on_media.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends file_user_on_mediaDeleteManyArgs>(args?: SelectSubset<T, file_user_on_mediaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more File_user_on_medias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {file_user_on_mediaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many File_user_on_medias
     * const file_user_on_media = await prisma.file_user_on_media.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends file_user_on_mediaUpdateManyArgs>(args: SelectSubset<T, file_user_on_mediaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one File_user_on_media.
     * @param {file_user_on_mediaUpsertArgs} args - Arguments to update or create a File_user_on_media.
     * @example
     * // Update or create a File_user_on_media
     * const file_user_on_media = await prisma.file_user_on_media.upsert({
     *   create: {
     *     // ... data to create a File_user_on_media
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the File_user_on_media we want to update
     *   }
     * })
     */
    upsert<T extends file_user_on_mediaUpsertArgs>(args: SelectSubset<T, file_user_on_mediaUpsertArgs<ExtArgs>>): Prisma__file_user_on_mediaClient<$Result.GetResult<Prisma.$file_user_on_mediaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of File_user_on_medias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {file_user_on_mediaCountArgs} args - Arguments to filter File_user_on_medias to count.
     * @example
     * // Count the number of File_user_on_medias
     * const count = await prisma.file_user_on_media.count({
     *   where: {
     *     // ... the filter for the File_user_on_medias we want to count
     *   }
     * })
    **/
    count<T extends file_user_on_mediaCountArgs>(
      args?: Subset<T, file_user_on_mediaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], File_user_on_mediaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a File_user_on_media.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {File_user_on_mediaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends File_user_on_mediaAggregateArgs>(args: Subset<T, File_user_on_mediaAggregateArgs>): Prisma.PrismaPromise<GetFile_user_on_mediaAggregateType<T>>

    /**
     * Group by File_user_on_media.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {file_user_on_mediaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends file_user_on_mediaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: file_user_on_mediaGroupByArgs['orderBy'] }
        : { orderBy?: file_user_on_mediaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, file_user_on_mediaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFile_user_on_mediaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the file_user_on_media model
   */
  readonly fields: file_user_on_mediaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for file_user_on_media.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__file_user_on_mediaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends file_userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, file_userDefaultArgs<ExtArgs>>): Prisma__file_userClient<$Result.GetResult<Prisma.$file_userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    media<T extends file_mediaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, file_mediaDefaultArgs<ExtArgs>>): Prisma__file_mediaClient<$Result.GetResult<Prisma.$file_mediaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the file_user_on_media model
   */
  interface file_user_on_mediaFieldRefs {
    readonly userId: FieldRef<"file_user_on_media", 'String'>
    readonly mediaId: FieldRef<"file_user_on_media", 'String'>
    readonly comment: FieldRef<"file_user_on_media", 'String'>
  }
    

  // Custom InputTypes
  /**
   * file_user_on_media findUnique
   */
  export type file_user_on_mediaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the file_user_on_media
     */
    select?: file_user_on_mediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the file_user_on_media
     */
    omit?: file_user_on_mediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: file_user_on_mediaInclude<ExtArgs> | null
    /**
     * Filter, which file_user_on_media to fetch.
     */
    where: file_user_on_mediaWhereUniqueInput
  }

  /**
   * file_user_on_media findUniqueOrThrow
   */
  export type file_user_on_mediaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the file_user_on_media
     */
    select?: file_user_on_mediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the file_user_on_media
     */
    omit?: file_user_on_mediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: file_user_on_mediaInclude<ExtArgs> | null
    /**
     * Filter, which file_user_on_media to fetch.
     */
    where: file_user_on_mediaWhereUniqueInput
  }

  /**
   * file_user_on_media findFirst
   */
  export type file_user_on_mediaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the file_user_on_media
     */
    select?: file_user_on_mediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the file_user_on_media
     */
    omit?: file_user_on_mediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: file_user_on_mediaInclude<ExtArgs> | null
    /**
     * Filter, which file_user_on_media to fetch.
     */
    where?: file_user_on_mediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of file_user_on_medias to fetch.
     */
    orderBy?: file_user_on_mediaOrderByWithRelationInput | file_user_on_mediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for file_user_on_medias.
     */
    cursor?: file_user_on_mediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` file_user_on_medias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` file_user_on_medias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of file_user_on_medias.
     */
    distinct?: File_user_on_mediaScalarFieldEnum | File_user_on_mediaScalarFieldEnum[]
  }

  /**
   * file_user_on_media findFirstOrThrow
   */
  export type file_user_on_mediaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the file_user_on_media
     */
    select?: file_user_on_mediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the file_user_on_media
     */
    omit?: file_user_on_mediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: file_user_on_mediaInclude<ExtArgs> | null
    /**
     * Filter, which file_user_on_media to fetch.
     */
    where?: file_user_on_mediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of file_user_on_medias to fetch.
     */
    orderBy?: file_user_on_mediaOrderByWithRelationInput | file_user_on_mediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for file_user_on_medias.
     */
    cursor?: file_user_on_mediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` file_user_on_medias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` file_user_on_medias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of file_user_on_medias.
     */
    distinct?: File_user_on_mediaScalarFieldEnum | File_user_on_mediaScalarFieldEnum[]
  }

  /**
   * file_user_on_media findMany
   */
  export type file_user_on_mediaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the file_user_on_media
     */
    select?: file_user_on_mediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the file_user_on_media
     */
    omit?: file_user_on_mediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: file_user_on_mediaInclude<ExtArgs> | null
    /**
     * Filter, which file_user_on_medias to fetch.
     */
    where?: file_user_on_mediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of file_user_on_medias to fetch.
     */
    orderBy?: file_user_on_mediaOrderByWithRelationInput | file_user_on_mediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing file_user_on_medias.
     */
    cursor?: file_user_on_mediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` file_user_on_medias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` file_user_on_medias.
     */
    skip?: number
    distinct?: File_user_on_mediaScalarFieldEnum | File_user_on_mediaScalarFieldEnum[]
  }

  /**
   * file_user_on_media create
   */
  export type file_user_on_mediaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the file_user_on_media
     */
    select?: file_user_on_mediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the file_user_on_media
     */
    omit?: file_user_on_mediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: file_user_on_mediaInclude<ExtArgs> | null
    /**
     * The data needed to create a file_user_on_media.
     */
    data: XOR<file_user_on_mediaCreateInput, file_user_on_mediaUncheckedCreateInput>
  }

  /**
   * file_user_on_media createMany
   */
  export type file_user_on_mediaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many file_user_on_medias.
     */
    data: file_user_on_mediaCreateManyInput | file_user_on_mediaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * file_user_on_media update
   */
  export type file_user_on_mediaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the file_user_on_media
     */
    select?: file_user_on_mediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the file_user_on_media
     */
    omit?: file_user_on_mediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: file_user_on_mediaInclude<ExtArgs> | null
    /**
     * The data needed to update a file_user_on_media.
     */
    data: XOR<file_user_on_mediaUpdateInput, file_user_on_mediaUncheckedUpdateInput>
    /**
     * Choose, which file_user_on_media to update.
     */
    where: file_user_on_mediaWhereUniqueInput
  }

  /**
   * file_user_on_media updateMany
   */
  export type file_user_on_mediaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update file_user_on_medias.
     */
    data: XOR<file_user_on_mediaUpdateManyMutationInput, file_user_on_mediaUncheckedUpdateManyInput>
    /**
     * Filter which file_user_on_medias to update
     */
    where?: file_user_on_mediaWhereInput
    /**
     * Limit how many file_user_on_medias to update.
     */
    limit?: number
  }

  /**
   * file_user_on_media upsert
   */
  export type file_user_on_mediaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the file_user_on_media
     */
    select?: file_user_on_mediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the file_user_on_media
     */
    omit?: file_user_on_mediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: file_user_on_mediaInclude<ExtArgs> | null
    /**
     * The filter to search for the file_user_on_media to update in case it exists.
     */
    where: file_user_on_mediaWhereUniqueInput
    /**
     * In case the file_user_on_media found by the `where` argument doesn't exist, create a new file_user_on_media with this data.
     */
    create: XOR<file_user_on_mediaCreateInput, file_user_on_mediaUncheckedCreateInput>
    /**
     * In case the file_user_on_media was found with the provided `where` argument, update it with this data.
     */
    update: XOR<file_user_on_mediaUpdateInput, file_user_on_mediaUncheckedUpdateInput>
  }

  /**
   * file_user_on_media delete
   */
  export type file_user_on_mediaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the file_user_on_media
     */
    select?: file_user_on_mediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the file_user_on_media
     */
    omit?: file_user_on_mediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: file_user_on_mediaInclude<ExtArgs> | null
    /**
     * Filter which file_user_on_media to delete.
     */
    where: file_user_on_mediaWhereUniqueInput
  }

  /**
   * file_user_on_media deleteMany
   */
  export type file_user_on_mediaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which file_user_on_medias to delete
     */
    where?: file_user_on_mediaWhereInput
    /**
     * Limit how many file_user_on_medias to delete.
     */
    limit?: number
  }

  /**
   * file_user_on_media without action
   */
  export type file_user_on_mediaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the file_user_on_media
     */
    select?: file_user_on_mediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the file_user_on_media
     */
    omit?: file_user_on_mediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: file_user_on_mediaInclude<ExtArgs> | null
  }


  /**
   * Model file_block
   */

  export type AggregateFile_block = {
    _count: File_blockCountAggregateOutputType | null
    _avg: File_blockAvgAggregateOutputType | null
    _sum: File_blockSumAggregateOutputType | null
    _min: File_blockMinAggregateOutputType | null
    _max: File_blockMaxAggregateOutputType | null
  }

  export type File_blockAvgAggregateOutputType = {
    size: number | null
  }

  export type File_blockSumAggregateOutputType = {
    size: number | null
  }

  export type File_blockMinAggregateOutputType = {
    uid: string | null
    createAt: Date | null
    updateAt: Date | null
    mediaId: string | null
    hash_key: string | null
    size: number | null
  }

  export type File_blockMaxAggregateOutputType = {
    uid: string | null
    createAt: Date | null
    updateAt: Date | null
    mediaId: string | null
    hash_key: string | null
    size: number | null
  }

  export type File_blockCountAggregateOutputType = {
    uid: number
    createAt: number
    updateAt: number
    mediaId: number
    hash_key: number
    size: number
    _all: number
  }


  export type File_blockAvgAggregateInputType = {
    size?: true
  }

  export type File_blockSumAggregateInputType = {
    size?: true
  }

  export type File_blockMinAggregateInputType = {
    uid?: true
    createAt?: true
    updateAt?: true
    mediaId?: true
    hash_key?: true
    size?: true
  }

  export type File_blockMaxAggregateInputType = {
    uid?: true
    createAt?: true
    updateAt?: true
    mediaId?: true
    hash_key?: true
    size?: true
  }

  export type File_blockCountAggregateInputType = {
    uid?: true
    createAt?: true
    updateAt?: true
    mediaId?: true
    hash_key?: true
    size?: true
    _all?: true
  }

  export type File_blockAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which file_block to aggregate.
     */
    where?: file_blockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of file_blocks to fetch.
     */
    orderBy?: file_blockOrderByWithRelationInput | file_blockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: file_blockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` file_blocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` file_blocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned file_blocks
    **/
    _count?: true | File_blockCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: File_blockAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: File_blockSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: File_blockMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: File_blockMaxAggregateInputType
  }

  export type GetFile_blockAggregateType<T extends File_blockAggregateArgs> = {
        [P in keyof T & keyof AggregateFile_block]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFile_block[P]>
      : GetScalarType<T[P], AggregateFile_block[P]>
  }




  export type file_blockGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: file_blockWhereInput
    orderBy?: file_blockOrderByWithAggregationInput | file_blockOrderByWithAggregationInput[]
    by: File_blockScalarFieldEnum[] | File_blockScalarFieldEnum
    having?: file_blockScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: File_blockCountAggregateInputType | true
    _avg?: File_blockAvgAggregateInputType
    _sum?: File_blockSumAggregateInputType
    _min?: File_blockMinAggregateInputType
    _max?: File_blockMaxAggregateInputType
  }

  export type File_blockGroupByOutputType = {
    uid: string
    createAt: Date
    updateAt: Date
    mediaId: string
    hash_key: string
    size: number
    _count: File_blockCountAggregateOutputType | null
    _avg: File_blockAvgAggregateOutputType | null
    _sum: File_blockSumAggregateOutputType | null
    _min: File_blockMinAggregateOutputType | null
    _max: File_blockMaxAggregateOutputType | null
  }

  type GetFile_blockGroupByPayload<T extends file_blockGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<File_blockGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof File_blockGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], File_blockGroupByOutputType[P]>
            : GetScalarType<T[P], File_blockGroupByOutputType[P]>
        }
      >
    >


  export type file_blockSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    uid?: boolean
    createAt?: boolean
    updateAt?: boolean
    mediaId?: boolean
    hash_key?: boolean
    size?: boolean
    media?: boolean | file_mediaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["file_block"]>



  export type file_blockSelectScalar = {
    uid?: boolean
    createAt?: boolean
    updateAt?: boolean
    mediaId?: boolean
    hash_key?: boolean
    size?: boolean
  }

  export type file_blockOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"uid" | "createAt" | "updateAt" | "mediaId" | "hash_key" | "size", ExtArgs["result"]["file_block"]>
  export type file_blockInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    media?: boolean | file_mediaDefaultArgs<ExtArgs>
  }

  export type $file_blockPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "file_block"
    objects: {
      media: Prisma.$file_mediaPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      uid: string
      createAt: Date
      updateAt: Date
      mediaId: string
      hash_key: string
      size: number
    }, ExtArgs["result"]["file_block"]>
    composites: {}
  }

  type file_blockGetPayload<S extends boolean | null | undefined | file_blockDefaultArgs> = $Result.GetResult<Prisma.$file_blockPayload, S>

  type file_blockCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<file_blockFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: File_blockCountAggregateInputType | true
    }

  export interface file_blockDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['file_block'], meta: { name: 'file_block' } }
    /**
     * Find zero or one File_block that matches the filter.
     * @param {file_blockFindUniqueArgs} args - Arguments to find a File_block
     * @example
     * // Get one File_block
     * const file_block = await prisma.file_block.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends file_blockFindUniqueArgs>(args: SelectSubset<T, file_blockFindUniqueArgs<ExtArgs>>): Prisma__file_blockClient<$Result.GetResult<Prisma.$file_blockPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one File_block that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {file_blockFindUniqueOrThrowArgs} args - Arguments to find a File_block
     * @example
     * // Get one File_block
     * const file_block = await prisma.file_block.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends file_blockFindUniqueOrThrowArgs>(args: SelectSubset<T, file_blockFindUniqueOrThrowArgs<ExtArgs>>): Prisma__file_blockClient<$Result.GetResult<Prisma.$file_blockPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first File_block that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {file_blockFindFirstArgs} args - Arguments to find a File_block
     * @example
     * // Get one File_block
     * const file_block = await prisma.file_block.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends file_blockFindFirstArgs>(args?: SelectSubset<T, file_blockFindFirstArgs<ExtArgs>>): Prisma__file_blockClient<$Result.GetResult<Prisma.$file_blockPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first File_block that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {file_blockFindFirstOrThrowArgs} args - Arguments to find a File_block
     * @example
     * // Get one File_block
     * const file_block = await prisma.file_block.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends file_blockFindFirstOrThrowArgs>(args?: SelectSubset<T, file_blockFindFirstOrThrowArgs<ExtArgs>>): Prisma__file_blockClient<$Result.GetResult<Prisma.$file_blockPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more File_blocks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {file_blockFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all File_blocks
     * const file_blocks = await prisma.file_block.findMany()
     * 
     * // Get first 10 File_blocks
     * const file_blocks = await prisma.file_block.findMany({ take: 10 })
     * 
     * // Only select the `uid`
     * const file_blockWithUidOnly = await prisma.file_block.findMany({ select: { uid: true } })
     * 
     */
    findMany<T extends file_blockFindManyArgs>(args?: SelectSubset<T, file_blockFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$file_blockPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a File_block.
     * @param {file_blockCreateArgs} args - Arguments to create a File_block.
     * @example
     * // Create one File_block
     * const File_block = await prisma.file_block.create({
     *   data: {
     *     // ... data to create a File_block
     *   }
     * })
     * 
     */
    create<T extends file_blockCreateArgs>(args: SelectSubset<T, file_blockCreateArgs<ExtArgs>>): Prisma__file_blockClient<$Result.GetResult<Prisma.$file_blockPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many File_blocks.
     * @param {file_blockCreateManyArgs} args - Arguments to create many File_blocks.
     * @example
     * // Create many File_blocks
     * const file_block = await prisma.file_block.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends file_blockCreateManyArgs>(args?: SelectSubset<T, file_blockCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a File_block.
     * @param {file_blockDeleteArgs} args - Arguments to delete one File_block.
     * @example
     * // Delete one File_block
     * const File_block = await prisma.file_block.delete({
     *   where: {
     *     // ... filter to delete one File_block
     *   }
     * })
     * 
     */
    delete<T extends file_blockDeleteArgs>(args: SelectSubset<T, file_blockDeleteArgs<ExtArgs>>): Prisma__file_blockClient<$Result.GetResult<Prisma.$file_blockPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one File_block.
     * @param {file_blockUpdateArgs} args - Arguments to update one File_block.
     * @example
     * // Update one File_block
     * const file_block = await prisma.file_block.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends file_blockUpdateArgs>(args: SelectSubset<T, file_blockUpdateArgs<ExtArgs>>): Prisma__file_blockClient<$Result.GetResult<Prisma.$file_blockPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more File_blocks.
     * @param {file_blockDeleteManyArgs} args - Arguments to filter File_blocks to delete.
     * @example
     * // Delete a few File_blocks
     * const { count } = await prisma.file_block.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends file_blockDeleteManyArgs>(args?: SelectSubset<T, file_blockDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more File_blocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {file_blockUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many File_blocks
     * const file_block = await prisma.file_block.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends file_blockUpdateManyArgs>(args: SelectSubset<T, file_blockUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one File_block.
     * @param {file_blockUpsertArgs} args - Arguments to update or create a File_block.
     * @example
     * // Update or create a File_block
     * const file_block = await prisma.file_block.upsert({
     *   create: {
     *     // ... data to create a File_block
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the File_block we want to update
     *   }
     * })
     */
    upsert<T extends file_blockUpsertArgs>(args: SelectSubset<T, file_blockUpsertArgs<ExtArgs>>): Prisma__file_blockClient<$Result.GetResult<Prisma.$file_blockPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of File_blocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {file_blockCountArgs} args - Arguments to filter File_blocks to count.
     * @example
     * // Count the number of File_blocks
     * const count = await prisma.file_block.count({
     *   where: {
     *     // ... the filter for the File_blocks we want to count
     *   }
     * })
    **/
    count<T extends file_blockCountArgs>(
      args?: Subset<T, file_blockCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], File_blockCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a File_block.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {File_blockAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends File_blockAggregateArgs>(args: Subset<T, File_blockAggregateArgs>): Prisma.PrismaPromise<GetFile_blockAggregateType<T>>

    /**
     * Group by File_block.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {file_blockGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends file_blockGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: file_blockGroupByArgs['orderBy'] }
        : { orderBy?: file_blockGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, file_blockGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFile_blockGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the file_block model
   */
  readonly fields: file_blockFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for file_block.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__file_blockClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    media<T extends file_mediaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, file_mediaDefaultArgs<ExtArgs>>): Prisma__file_mediaClient<$Result.GetResult<Prisma.$file_mediaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the file_block model
   */
  interface file_blockFieldRefs {
    readonly uid: FieldRef<"file_block", 'String'>
    readonly createAt: FieldRef<"file_block", 'DateTime'>
    readonly updateAt: FieldRef<"file_block", 'DateTime'>
    readonly mediaId: FieldRef<"file_block", 'String'>
    readonly hash_key: FieldRef<"file_block", 'String'>
    readonly size: FieldRef<"file_block", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * file_block findUnique
   */
  export type file_blockFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the file_block
     */
    select?: file_blockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the file_block
     */
    omit?: file_blockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: file_blockInclude<ExtArgs> | null
    /**
     * Filter, which file_block to fetch.
     */
    where: file_blockWhereUniqueInput
  }

  /**
   * file_block findUniqueOrThrow
   */
  export type file_blockFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the file_block
     */
    select?: file_blockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the file_block
     */
    omit?: file_blockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: file_blockInclude<ExtArgs> | null
    /**
     * Filter, which file_block to fetch.
     */
    where: file_blockWhereUniqueInput
  }

  /**
   * file_block findFirst
   */
  export type file_blockFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the file_block
     */
    select?: file_blockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the file_block
     */
    omit?: file_blockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: file_blockInclude<ExtArgs> | null
    /**
     * Filter, which file_block to fetch.
     */
    where?: file_blockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of file_blocks to fetch.
     */
    orderBy?: file_blockOrderByWithRelationInput | file_blockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for file_blocks.
     */
    cursor?: file_blockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` file_blocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` file_blocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of file_blocks.
     */
    distinct?: File_blockScalarFieldEnum | File_blockScalarFieldEnum[]
  }

  /**
   * file_block findFirstOrThrow
   */
  export type file_blockFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the file_block
     */
    select?: file_blockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the file_block
     */
    omit?: file_blockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: file_blockInclude<ExtArgs> | null
    /**
     * Filter, which file_block to fetch.
     */
    where?: file_blockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of file_blocks to fetch.
     */
    orderBy?: file_blockOrderByWithRelationInput | file_blockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for file_blocks.
     */
    cursor?: file_blockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` file_blocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` file_blocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of file_blocks.
     */
    distinct?: File_blockScalarFieldEnum | File_blockScalarFieldEnum[]
  }

  /**
   * file_block findMany
   */
  export type file_blockFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the file_block
     */
    select?: file_blockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the file_block
     */
    omit?: file_blockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: file_blockInclude<ExtArgs> | null
    /**
     * Filter, which file_blocks to fetch.
     */
    where?: file_blockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of file_blocks to fetch.
     */
    orderBy?: file_blockOrderByWithRelationInput | file_blockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing file_blocks.
     */
    cursor?: file_blockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` file_blocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` file_blocks.
     */
    skip?: number
    distinct?: File_blockScalarFieldEnum | File_blockScalarFieldEnum[]
  }

  /**
   * file_block create
   */
  export type file_blockCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the file_block
     */
    select?: file_blockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the file_block
     */
    omit?: file_blockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: file_blockInclude<ExtArgs> | null
    /**
     * The data needed to create a file_block.
     */
    data: XOR<file_blockCreateInput, file_blockUncheckedCreateInput>
  }

  /**
   * file_block createMany
   */
  export type file_blockCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many file_blocks.
     */
    data: file_blockCreateManyInput | file_blockCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * file_block update
   */
  export type file_blockUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the file_block
     */
    select?: file_blockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the file_block
     */
    omit?: file_blockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: file_blockInclude<ExtArgs> | null
    /**
     * The data needed to update a file_block.
     */
    data: XOR<file_blockUpdateInput, file_blockUncheckedUpdateInput>
    /**
     * Choose, which file_block to update.
     */
    where: file_blockWhereUniqueInput
  }

  /**
   * file_block updateMany
   */
  export type file_blockUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update file_blocks.
     */
    data: XOR<file_blockUpdateManyMutationInput, file_blockUncheckedUpdateManyInput>
    /**
     * Filter which file_blocks to update
     */
    where?: file_blockWhereInput
    /**
     * Limit how many file_blocks to update.
     */
    limit?: number
  }

  /**
   * file_block upsert
   */
  export type file_blockUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the file_block
     */
    select?: file_blockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the file_block
     */
    omit?: file_blockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: file_blockInclude<ExtArgs> | null
    /**
     * The filter to search for the file_block to update in case it exists.
     */
    where: file_blockWhereUniqueInput
    /**
     * In case the file_block found by the `where` argument doesn't exist, create a new file_block with this data.
     */
    create: XOR<file_blockCreateInput, file_blockUncheckedCreateInput>
    /**
     * In case the file_block was found with the provided `where` argument, update it with this data.
     */
    update: XOR<file_blockUpdateInput, file_blockUncheckedUpdateInput>
  }

  /**
   * file_block delete
   */
  export type file_blockDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the file_block
     */
    select?: file_blockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the file_block
     */
    omit?: file_blockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: file_blockInclude<ExtArgs> | null
    /**
     * Filter which file_block to delete.
     */
    where: file_blockWhereUniqueInput
  }

  /**
   * file_block deleteMany
   */
  export type file_blockDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which file_blocks to delete
     */
    where?: file_blockWhereInput
    /**
     * Limit how many file_blocks to delete.
     */
    limit?: number
  }

  /**
   * file_block without action
   */
  export type file_blockDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the file_block
     */
    select?: file_blockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the file_block
     */
    omit?: file_blockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: file_blockInclude<ExtArgs> | null
  }


  /**
   * Model file_media
   */

  export type AggregateFile_media = {
    _count: File_mediaCountAggregateOutputType | null
    _avg: File_mediaAvgAggregateOutputType | null
    _sum: File_mediaSumAggregateOutputType | null
    _min: File_mediaMinAggregateOutputType | null
    _max: File_mediaMaxAggregateOutputType | null
  }

  export type File_mediaAvgAggregateOutputType = {
    size: number | null
  }

  export type File_mediaSumAggregateOutputType = {
    size: number | null
  }

  export type File_mediaMinAggregateOutputType = {
    uid: string | null
    createAt: Date | null
    updateAt: Date | null
    type: $Enums.file_type | null
    name: string | null
    hash_key: string | null
    size: number | null
    disable: boolean | null
    comment: string | null
  }

  export type File_mediaMaxAggregateOutputType = {
    uid: string | null
    createAt: Date | null
    updateAt: Date | null
    type: $Enums.file_type | null
    name: string | null
    hash_key: string | null
    size: number | null
    disable: boolean | null
    comment: string | null
  }

  export type File_mediaCountAggregateOutputType = {
    uid: number
    createAt: number
    updateAt: number
    type: number
    name: number
    hash_key: number
    size: number
    disable: number
    comment: number
    _all: number
  }


  export type File_mediaAvgAggregateInputType = {
    size?: true
  }

  export type File_mediaSumAggregateInputType = {
    size?: true
  }

  export type File_mediaMinAggregateInputType = {
    uid?: true
    createAt?: true
    updateAt?: true
    type?: true
    name?: true
    hash_key?: true
    size?: true
    disable?: true
    comment?: true
  }

  export type File_mediaMaxAggregateInputType = {
    uid?: true
    createAt?: true
    updateAt?: true
    type?: true
    name?: true
    hash_key?: true
    size?: true
    disable?: true
    comment?: true
  }

  export type File_mediaCountAggregateInputType = {
    uid?: true
    createAt?: true
    updateAt?: true
    type?: true
    name?: true
    hash_key?: true
    size?: true
    disable?: true
    comment?: true
    _all?: true
  }

  export type File_mediaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which file_media to aggregate.
     */
    where?: file_mediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of file_medias to fetch.
     */
    orderBy?: file_mediaOrderByWithRelationInput | file_mediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: file_mediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` file_medias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` file_medias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned file_medias
    **/
    _count?: true | File_mediaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: File_mediaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: File_mediaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: File_mediaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: File_mediaMaxAggregateInputType
  }

  export type GetFile_mediaAggregateType<T extends File_mediaAggregateArgs> = {
        [P in keyof T & keyof AggregateFile_media]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFile_media[P]>
      : GetScalarType<T[P], AggregateFile_media[P]>
  }




  export type file_mediaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: file_mediaWhereInput
    orderBy?: file_mediaOrderByWithAggregationInput | file_mediaOrderByWithAggregationInput[]
    by: File_mediaScalarFieldEnum[] | File_mediaScalarFieldEnum
    having?: file_mediaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: File_mediaCountAggregateInputType | true
    _avg?: File_mediaAvgAggregateInputType
    _sum?: File_mediaSumAggregateInputType
    _min?: File_mediaMinAggregateInputType
    _max?: File_mediaMaxAggregateInputType
  }

  export type File_mediaGroupByOutputType = {
    uid: string
    createAt: Date
    updateAt: Date
    type: $Enums.file_type
    name: string
    hash_key: string
    size: number
    disable: boolean
    comment: string | null
    _count: File_mediaCountAggregateOutputType | null
    _avg: File_mediaAvgAggregateOutputType | null
    _sum: File_mediaSumAggregateOutputType | null
    _min: File_mediaMinAggregateOutputType | null
    _max: File_mediaMaxAggregateOutputType | null
  }

  type GetFile_mediaGroupByPayload<T extends file_mediaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<File_mediaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof File_mediaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], File_mediaGroupByOutputType[P]>
            : GetScalarType<T[P], File_mediaGroupByOutputType[P]>
        }
      >
    >


  export type file_mediaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    uid?: boolean
    createAt?: boolean
    updateAt?: boolean
    type?: boolean
    name?: boolean
    hash_key?: boolean
    size?: boolean
    disable?: boolean
    comment?: boolean
    blocks?: boolean | file_media$blocksArgs<ExtArgs>
    users?: boolean | file_media$usersArgs<ExtArgs>
    folders?: boolean | file_media$foldersArgs<ExtArgs>
    _count?: boolean | File_mediaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["file_media"]>



  export type file_mediaSelectScalar = {
    uid?: boolean
    createAt?: boolean
    updateAt?: boolean
    type?: boolean
    name?: boolean
    hash_key?: boolean
    size?: boolean
    disable?: boolean
    comment?: boolean
  }

  export type file_mediaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"uid" | "createAt" | "updateAt" | "type" | "name" | "hash_key" | "size" | "disable" | "comment", ExtArgs["result"]["file_media"]>
  export type file_mediaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    blocks?: boolean | file_media$blocksArgs<ExtArgs>
    users?: boolean | file_media$usersArgs<ExtArgs>
    folders?: boolean | file_media$foldersArgs<ExtArgs>
    _count?: boolean | File_mediaCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $file_mediaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "file_media"
    objects: {
      blocks: Prisma.$file_blockPayload<ExtArgs>[]
      users: Prisma.$file_user_on_mediaPayload<ExtArgs>[]
      folders: Prisma.$file_media_on_folderPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      uid: string
      createAt: Date
      updateAt: Date
      type: $Enums.file_type
      name: string
      hash_key: string
      size: number
      disable: boolean
      comment: string | null
    }, ExtArgs["result"]["file_media"]>
    composites: {}
  }

  type file_mediaGetPayload<S extends boolean | null | undefined | file_mediaDefaultArgs> = $Result.GetResult<Prisma.$file_mediaPayload, S>

  type file_mediaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<file_mediaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: File_mediaCountAggregateInputType | true
    }

  export interface file_mediaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['file_media'], meta: { name: 'file_media' } }
    /**
     * Find zero or one File_media that matches the filter.
     * @param {file_mediaFindUniqueArgs} args - Arguments to find a File_media
     * @example
     * // Get one File_media
     * const file_media = await prisma.file_media.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends file_mediaFindUniqueArgs>(args: SelectSubset<T, file_mediaFindUniqueArgs<ExtArgs>>): Prisma__file_mediaClient<$Result.GetResult<Prisma.$file_mediaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one File_media that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {file_mediaFindUniqueOrThrowArgs} args - Arguments to find a File_media
     * @example
     * // Get one File_media
     * const file_media = await prisma.file_media.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends file_mediaFindUniqueOrThrowArgs>(args: SelectSubset<T, file_mediaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__file_mediaClient<$Result.GetResult<Prisma.$file_mediaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first File_media that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {file_mediaFindFirstArgs} args - Arguments to find a File_media
     * @example
     * // Get one File_media
     * const file_media = await prisma.file_media.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends file_mediaFindFirstArgs>(args?: SelectSubset<T, file_mediaFindFirstArgs<ExtArgs>>): Prisma__file_mediaClient<$Result.GetResult<Prisma.$file_mediaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first File_media that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {file_mediaFindFirstOrThrowArgs} args - Arguments to find a File_media
     * @example
     * // Get one File_media
     * const file_media = await prisma.file_media.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends file_mediaFindFirstOrThrowArgs>(args?: SelectSubset<T, file_mediaFindFirstOrThrowArgs<ExtArgs>>): Prisma__file_mediaClient<$Result.GetResult<Prisma.$file_mediaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more File_medias that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {file_mediaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all File_medias
     * const file_medias = await prisma.file_media.findMany()
     * 
     * // Get first 10 File_medias
     * const file_medias = await prisma.file_media.findMany({ take: 10 })
     * 
     * // Only select the `uid`
     * const file_mediaWithUidOnly = await prisma.file_media.findMany({ select: { uid: true } })
     * 
     */
    findMany<T extends file_mediaFindManyArgs>(args?: SelectSubset<T, file_mediaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$file_mediaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a File_media.
     * @param {file_mediaCreateArgs} args - Arguments to create a File_media.
     * @example
     * // Create one File_media
     * const File_media = await prisma.file_media.create({
     *   data: {
     *     // ... data to create a File_media
     *   }
     * })
     * 
     */
    create<T extends file_mediaCreateArgs>(args: SelectSubset<T, file_mediaCreateArgs<ExtArgs>>): Prisma__file_mediaClient<$Result.GetResult<Prisma.$file_mediaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many File_medias.
     * @param {file_mediaCreateManyArgs} args - Arguments to create many File_medias.
     * @example
     * // Create many File_medias
     * const file_media = await prisma.file_media.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends file_mediaCreateManyArgs>(args?: SelectSubset<T, file_mediaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a File_media.
     * @param {file_mediaDeleteArgs} args - Arguments to delete one File_media.
     * @example
     * // Delete one File_media
     * const File_media = await prisma.file_media.delete({
     *   where: {
     *     // ... filter to delete one File_media
     *   }
     * })
     * 
     */
    delete<T extends file_mediaDeleteArgs>(args: SelectSubset<T, file_mediaDeleteArgs<ExtArgs>>): Prisma__file_mediaClient<$Result.GetResult<Prisma.$file_mediaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one File_media.
     * @param {file_mediaUpdateArgs} args - Arguments to update one File_media.
     * @example
     * // Update one File_media
     * const file_media = await prisma.file_media.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends file_mediaUpdateArgs>(args: SelectSubset<T, file_mediaUpdateArgs<ExtArgs>>): Prisma__file_mediaClient<$Result.GetResult<Prisma.$file_mediaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more File_medias.
     * @param {file_mediaDeleteManyArgs} args - Arguments to filter File_medias to delete.
     * @example
     * // Delete a few File_medias
     * const { count } = await prisma.file_media.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends file_mediaDeleteManyArgs>(args?: SelectSubset<T, file_mediaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more File_medias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {file_mediaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many File_medias
     * const file_media = await prisma.file_media.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends file_mediaUpdateManyArgs>(args: SelectSubset<T, file_mediaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one File_media.
     * @param {file_mediaUpsertArgs} args - Arguments to update or create a File_media.
     * @example
     * // Update or create a File_media
     * const file_media = await prisma.file_media.upsert({
     *   create: {
     *     // ... data to create a File_media
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the File_media we want to update
     *   }
     * })
     */
    upsert<T extends file_mediaUpsertArgs>(args: SelectSubset<T, file_mediaUpsertArgs<ExtArgs>>): Prisma__file_mediaClient<$Result.GetResult<Prisma.$file_mediaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of File_medias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {file_mediaCountArgs} args - Arguments to filter File_medias to count.
     * @example
     * // Count the number of File_medias
     * const count = await prisma.file_media.count({
     *   where: {
     *     // ... the filter for the File_medias we want to count
     *   }
     * })
    **/
    count<T extends file_mediaCountArgs>(
      args?: Subset<T, file_mediaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], File_mediaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a File_media.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {File_mediaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends File_mediaAggregateArgs>(args: Subset<T, File_mediaAggregateArgs>): Prisma.PrismaPromise<GetFile_mediaAggregateType<T>>

    /**
     * Group by File_media.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {file_mediaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends file_mediaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: file_mediaGroupByArgs['orderBy'] }
        : { orderBy?: file_mediaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, file_mediaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFile_mediaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the file_media model
   */
  readonly fields: file_mediaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for file_media.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__file_mediaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    blocks<T extends file_media$blocksArgs<ExtArgs> = {}>(args?: Subset<T, file_media$blocksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$file_blockPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    users<T extends file_media$usersArgs<ExtArgs> = {}>(args?: Subset<T, file_media$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$file_user_on_mediaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    folders<T extends file_media$foldersArgs<ExtArgs> = {}>(args?: Subset<T, file_media$foldersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$file_media_on_folderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the file_media model
   */
  interface file_mediaFieldRefs {
    readonly uid: FieldRef<"file_media", 'String'>
    readonly createAt: FieldRef<"file_media", 'DateTime'>
    readonly updateAt: FieldRef<"file_media", 'DateTime'>
    readonly type: FieldRef<"file_media", 'file_type'>
    readonly name: FieldRef<"file_media", 'String'>
    readonly hash_key: FieldRef<"file_media", 'String'>
    readonly size: FieldRef<"file_media", 'Int'>
    readonly disable: FieldRef<"file_media", 'Boolean'>
    readonly comment: FieldRef<"file_media", 'String'>
  }
    

  // Custom InputTypes
  /**
   * file_media findUnique
   */
  export type file_mediaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the file_media
     */
    select?: file_mediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the file_media
     */
    omit?: file_mediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: file_mediaInclude<ExtArgs> | null
    /**
     * Filter, which file_media to fetch.
     */
    where: file_mediaWhereUniqueInput
  }

  /**
   * file_media findUniqueOrThrow
   */
  export type file_mediaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the file_media
     */
    select?: file_mediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the file_media
     */
    omit?: file_mediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: file_mediaInclude<ExtArgs> | null
    /**
     * Filter, which file_media to fetch.
     */
    where: file_mediaWhereUniqueInput
  }

  /**
   * file_media findFirst
   */
  export type file_mediaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the file_media
     */
    select?: file_mediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the file_media
     */
    omit?: file_mediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: file_mediaInclude<ExtArgs> | null
    /**
     * Filter, which file_media to fetch.
     */
    where?: file_mediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of file_medias to fetch.
     */
    orderBy?: file_mediaOrderByWithRelationInput | file_mediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for file_medias.
     */
    cursor?: file_mediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` file_medias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` file_medias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of file_medias.
     */
    distinct?: File_mediaScalarFieldEnum | File_mediaScalarFieldEnum[]
  }

  /**
   * file_media findFirstOrThrow
   */
  export type file_mediaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the file_media
     */
    select?: file_mediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the file_media
     */
    omit?: file_mediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: file_mediaInclude<ExtArgs> | null
    /**
     * Filter, which file_media to fetch.
     */
    where?: file_mediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of file_medias to fetch.
     */
    orderBy?: file_mediaOrderByWithRelationInput | file_mediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for file_medias.
     */
    cursor?: file_mediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` file_medias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` file_medias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of file_medias.
     */
    distinct?: File_mediaScalarFieldEnum | File_mediaScalarFieldEnum[]
  }

  /**
   * file_media findMany
   */
  export type file_mediaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the file_media
     */
    select?: file_mediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the file_media
     */
    omit?: file_mediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: file_mediaInclude<ExtArgs> | null
    /**
     * Filter, which file_medias to fetch.
     */
    where?: file_mediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of file_medias to fetch.
     */
    orderBy?: file_mediaOrderByWithRelationInput | file_mediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing file_medias.
     */
    cursor?: file_mediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` file_medias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` file_medias.
     */
    skip?: number
    distinct?: File_mediaScalarFieldEnum | File_mediaScalarFieldEnum[]
  }

  /**
   * file_media create
   */
  export type file_mediaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the file_media
     */
    select?: file_mediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the file_media
     */
    omit?: file_mediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: file_mediaInclude<ExtArgs> | null
    /**
     * The data needed to create a file_media.
     */
    data: XOR<file_mediaCreateInput, file_mediaUncheckedCreateInput>
  }

  /**
   * file_media createMany
   */
  export type file_mediaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many file_medias.
     */
    data: file_mediaCreateManyInput | file_mediaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * file_media update
   */
  export type file_mediaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the file_media
     */
    select?: file_mediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the file_media
     */
    omit?: file_mediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: file_mediaInclude<ExtArgs> | null
    /**
     * The data needed to update a file_media.
     */
    data: XOR<file_mediaUpdateInput, file_mediaUncheckedUpdateInput>
    /**
     * Choose, which file_media to update.
     */
    where: file_mediaWhereUniqueInput
  }

  /**
   * file_media updateMany
   */
  export type file_mediaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update file_medias.
     */
    data: XOR<file_mediaUpdateManyMutationInput, file_mediaUncheckedUpdateManyInput>
    /**
     * Filter which file_medias to update
     */
    where?: file_mediaWhereInput
    /**
     * Limit how many file_medias to update.
     */
    limit?: number
  }

  /**
   * file_media upsert
   */
  export type file_mediaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the file_media
     */
    select?: file_mediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the file_media
     */
    omit?: file_mediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: file_mediaInclude<ExtArgs> | null
    /**
     * The filter to search for the file_media to update in case it exists.
     */
    where: file_mediaWhereUniqueInput
    /**
     * In case the file_media found by the `where` argument doesn't exist, create a new file_media with this data.
     */
    create: XOR<file_mediaCreateInput, file_mediaUncheckedCreateInput>
    /**
     * In case the file_media was found with the provided `where` argument, update it with this data.
     */
    update: XOR<file_mediaUpdateInput, file_mediaUncheckedUpdateInput>
  }

  /**
   * file_media delete
   */
  export type file_mediaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the file_media
     */
    select?: file_mediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the file_media
     */
    omit?: file_mediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: file_mediaInclude<ExtArgs> | null
    /**
     * Filter which file_media to delete.
     */
    where: file_mediaWhereUniqueInput
  }

  /**
   * file_media deleteMany
   */
  export type file_mediaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which file_medias to delete
     */
    where?: file_mediaWhereInput
    /**
     * Limit how many file_medias to delete.
     */
    limit?: number
  }

  /**
   * file_media.blocks
   */
  export type file_media$blocksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the file_block
     */
    select?: file_blockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the file_block
     */
    omit?: file_blockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: file_blockInclude<ExtArgs> | null
    where?: file_blockWhereInput
    orderBy?: file_blockOrderByWithRelationInput | file_blockOrderByWithRelationInput[]
    cursor?: file_blockWhereUniqueInput
    take?: number
    skip?: number
    distinct?: File_blockScalarFieldEnum | File_blockScalarFieldEnum[]
  }

  /**
   * file_media.users
   */
  export type file_media$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the file_user_on_media
     */
    select?: file_user_on_mediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the file_user_on_media
     */
    omit?: file_user_on_mediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: file_user_on_mediaInclude<ExtArgs> | null
    where?: file_user_on_mediaWhereInput
    orderBy?: file_user_on_mediaOrderByWithRelationInput | file_user_on_mediaOrderByWithRelationInput[]
    cursor?: file_user_on_mediaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: File_user_on_mediaScalarFieldEnum | File_user_on_mediaScalarFieldEnum[]
  }

  /**
   * file_media.folders
   */
  export type file_media$foldersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the file_media_on_folder
     */
    select?: file_media_on_folderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the file_media_on_folder
     */
    omit?: file_media_on_folderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: file_media_on_folderInclude<ExtArgs> | null
    where?: file_media_on_folderWhereInput
    orderBy?: file_media_on_folderOrderByWithRelationInput | file_media_on_folderOrderByWithRelationInput[]
    cursor?: file_media_on_folderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: File_media_on_folderScalarFieldEnum | File_media_on_folderScalarFieldEnum[]
  }

  /**
   * file_media without action
   */
  export type file_mediaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the file_media
     */
    select?: file_mediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the file_media
     */
    omit?: file_mediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: file_mediaInclude<ExtArgs> | null
  }


  /**
   * Model file_media_on_folder
   */

  export type AggregateFile_media_on_folder = {
    _count: File_media_on_folderCountAggregateOutputType | null
    _min: File_media_on_folderMinAggregateOutputType | null
    _max: File_media_on_folderMaxAggregateOutputType | null
  }

  export type File_media_on_folderMinAggregateOutputType = {
    mediaId: string | null
    folderId: string | null
  }

  export type File_media_on_folderMaxAggregateOutputType = {
    mediaId: string | null
    folderId: string | null
  }

  export type File_media_on_folderCountAggregateOutputType = {
    mediaId: number
    folderId: number
    _all: number
  }


  export type File_media_on_folderMinAggregateInputType = {
    mediaId?: true
    folderId?: true
  }

  export type File_media_on_folderMaxAggregateInputType = {
    mediaId?: true
    folderId?: true
  }

  export type File_media_on_folderCountAggregateInputType = {
    mediaId?: true
    folderId?: true
    _all?: true
  }

  export type File_media_on_folderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which file_media_on_folder to aggregate.
     */
    where?: file_media_on_folderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of file_media_on_folders to fetch.
     */
    orderBy?: file_media_on_folderOrderByWithRelationInput | file_media_on_folderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: file_media_on_folderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` file_media_on_folders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` file_media_on_folders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned file_media_on_folders
    **/
    _count?: true | File_media_on_folderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: File_media_on_folderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: File_media_on_folderMaxAggregateInputType
  }

  export type GetFile_media_on_folderAggregateType<T extends File_media_on_folderAggregateArgs> = {
        [P in keyof T & keyof AggregateFile_media_on_folder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFile_media_on_folder[P]>
      : GetScalarType<T[P], AggregateFile_media_on_folder[P]>
  }




  export type file_media_on_folderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: file_media_on_folderWhereInput
    orderBy?: file_media_on_folderOrderByWithAggregationInput | file_media_on_folderOrderByWithAggregationInput[]
    by: File_media_on_folderScalarFieldEnum[] | File_media_on_folderScalarFieldEnum
    having?: file_media_on_folderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: File_media_on_folderCountAggregateInputType | true
    _min?: File_media_on_folderMinAggregateInputType
    _max?: File_media_on_folderMaxAggregateInputType
  }

  export type File_media_on_folderGroupByOutputType = {
    mediaId: string
    folderId: string
    _count: File_media_on_folderCountAggregateOutputType | null
    _min: File_media_on_folderMinAggregateOutputType | null
    _max: File_media_on_folderMaxAggregateOutputType | null
  }

  type GetFile_media_on_folderGroupByPayload<T extends file_media_on_folderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<File_media_on_folderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof File_media_on_folderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], File_media_on_folderGroupByOutputType[P]>
            : GetScalarType<T[P], File_media_on_folderGroupByOutputType[P]>
        }
      >
    >


  export type file_media_on_folderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    mediaId?: boolean
    folderId?: boolean
    media?: boolean | file_mediaDefaultArgs<ExtArgs>
    folder?: boolean | file_folderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["file_media_on_folder"]>



  export type file_media_on_folderSelectScalar = {
    mediaId?: boolean
    folderId?: boolean
  }

  export type file_media_on_folderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"mediaId" | "folderId", ExtArgs["result"]["file_media_on_folder"]>
  export type file_media_on_folderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    media?: boolean | file_mediaDefaultArgs<ExtArgs>
    folder?: boolean | file_folderDefaultArgs<ExtArgs>
  }

  export type $file_media_on_folderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "file_media_on_folder"
    objects: {
      media: Prisma.$file_mediaPayload<ExtArgs>
      folder: Prisma.$file_folderPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      mediaId: string
      folderId: string
    }, ExtArgs["result"]["file_media_on_folder"]>
    composites: {}
  }

  type file_media_on_folderGetPayload<S extends boolean | null | undefined | file_media_on_folderDefaultArgs> = $Result.GetResult<Prisma.$file_media_on_folderPayload, S>

  type file_media_on_folderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<file_media_on_folderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: File_media_on_folderCountAggregateInputType | true
    }

  export interface file_media_on_folderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['file_media_on_folder'], meta: { name: 'file_media_on_folder' } }
    /**
     * Find zero or one File_media_on_folder that matches the filter.
     * @param {file_media_on_folderFindUniqueArgs} args - Arguments to find a File_media_on_folder
     * @example
     * // Get one File_media_on_folder
     * const file_media_on_folder = await prisma.file_media_on_folder.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends file_media_on_folderFindUniqueArgs>(args: SelectSubset<T, file_media_on_folderFindUniqueArgs<ExtArgs>>): Prisma__file_media_on_folderClient<$Result.GetResult<Prisma.$file_media_on_folderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one File_media_on_folder that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {file_media_on_folderFindUniqueOrThrowArgs} args - Arguments to find a File_media_on_folder
     * @example
     * // Get one File_media_on_folder
     * const file_media_on_folder = await prisma.file_media_on_folder.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends file_media_on_folderFindUniqueOrThrowArgs>(args: SelectSubset<T, file_media_on_folderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__file_media_on_folderClient<$Result.GetResult<Prisma.$file_media_on_folderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first File_media_on_folder that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {file_media_on_folderFindFirstArgs} args - Arguments to find a File_media_on_folder
     * @example
     * // Get one File_media_on_folder
     * const file_media_on_folder = await prisma.file_media_on_folder.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends file_media_on_folderFindFirstArgs>(args?: SelectSubset<T, file_media_on_folderFindFirstArgs<ExtArgs>>): Prisma__file_media_on_folderClient<$Result.GetResult<Prisma.$file_media_on_folderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first File_media_on_folder that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {file_media_on_folderFindFirstOrThrowArgs} args - Arguments to find a File_media_on_folder
     * @example
     * // Get one File_media_on_folder
     * const file_media_on_folder = await prisma.file_media_on_folder.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends file_media_on_folderFindFirstOrThrowArgs>(args?: SelectSubset<T, file_media_on_folderFindFirstOrThrowArgs<ExtArgs>>): Prisma__file_media_on_folderClient<$Result.GetResult<Prisma.$file_media_on_folderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more File_media_on_folders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {file_media_on_folderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all File_media_on_folders
     * const file_media_on_folders = await prisma.file_media_on_folder.findMany()
     * 
     * // Get first 10 File_media_on_folders
     * const file_media_on_folders = await prisma.file_media_on_folder.findMany({ take: 10 })
     * 
     * // Only select the `mediaId`
     * const file_media_on_folderWithMediaIdOnly = await prisma.file_media_on_folder.findMany({ select: { mediaId: true } })
     * 
     */
    findMany<T extends file_media_on_folderFindManyArgs>(args?: SelectSubset<T, file_media_on_folderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$file_media_on_folderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a File_media_on_folder.
     * @param {file_media_on_folderCreateArgs} args - Arguments to create a File_media_on_folder.
     * @example
     * // Create one File_media_on_folder
     * const File_media_on_folder = await prisma.file_media_on_folder.create({
     *   data: {
     *     // ... data to create a File_media_on_folder
     *   }
     * })
     * 
     */
    create<T extends file_media_on_folderCreateArgs>(args: SelectSubset<T, file_media_on_folderCreateArgs<ExtArgs>>): Prisma__file_media_on_folderClient<$Result.GetResult<Prisma.$file_media_on_folderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many File_media_on_folders.
     * @param {file_media_on_folderCreateManyArgs} args - Arguments to create many File_media_on_folders.
     * @example
     * // Create many File_media_on_folders
     * const file_media_on_folder = await prisma.file_media_on_folder.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends file_media_on_folderCreateManyArgs>(args?: SelectSubset<T, file_media_on_folderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a File_media_on_folder.
     * @param {file_media_on_folderDeleteArgs} args - Arguments to delete one File_media_on_folder.
     * @example
     * // Delete one File_media_on_folder
     * const File_media_on_folder = await prisma.file_media_on_folder.delete({
     *   where: {
     *     // ... filter to delete one File_media_on_folder
     *   }
     * })
     * 
     */
    delete<T extends file_media_on_folderDeleteArgs>(args: SelectSubset<T, file_media_on_folderDeleteArgs<ExtArgs>>): Prisma__file_media_on_folderClient<$Result.GetResult<Prisma.$file_media_on_folderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one File_media_on_folder.
     * @param {file_media_on_folderUpdateArgs} args - Arguments to update one File_media_on_folder.
     * @example
     * // Update one File_media_on_folder
     * const file_media_on_folder = await prisma.file_media_on_folder.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends file_media_on_folderUpdateArgs>(args: SelectSubset<T, file_media_on_folderUpdateArgs<ExtArgs>>): Prisma__file_media_on_folderClient<$Result.GetResult<Prisma.$file_media_on_folderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more File_media_on_folders.
     * @param {file_media_on_folderDeleteManyArgs} args - Arguments to filter File_media_on_folders to delete.
     * @example
     * // Delete a few File_media_on_folders
     * const { count } = await prisma.file_media_on_folder.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends file_media_on_folderDeleteManyArgs>(args?: SelectSubset<T, file_media_on_folderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more File_media_on_folders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {file_media_on_folderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many File_media_on_folders
     * const file_media_on_folder = await prisma.file_media_on_folder.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends file_media_on_folderUpdateManyArgs>(args: SelectSubset<T, file_media_on_folderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one File_media_on_folder.
     * @param {file_media_on_folderUpsertArgs} args - Arguments to update or create a File_media_on_folder.
     * @example
     * // Update or create a File_media_on_folder
     * const file_media_on_folder = await prisma.file_media_on_folder.upsert({
     *   create: {
     *     // ... data to create a File_media_on_folder
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the File_media_on_folder we want to update
     *   }
     * })
     */
    upsert<T extends file_media_on_folderUpsertArgs>(args: SelectSubset<T, file_media_on_folderUpsertArgs<ExtArgs>>): Prisma__file_media_on_folderClient<$Result.GetResult<Prisma.$file_media_on_folderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of File_media_on_folders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {file_media_on_folderCountArgs} args - Arguments to filter File_media_on_folders to count.
     * @example
     * // Count the number of File_media_on_folders
     * const count = await prisma.file_media_on_folder.count({
     *   where: {
     *     // ... the filter for the File_media_on_folders we want to count
     *   }
     * })
    **/
    count<T extends file_media_on_folderCountArgs>(
      args?: Subset<T, file_media_on_folderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], File_media_on_folderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a File_media_on_folder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {File_media_on_folderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends File_media_on_folderAggregateArgs>(args: Subset<T, File_media_on_folderAggregateArgs>): Prisma.PrismaPromise<GetFile_media_on_folderAggregateType<T>>

    /**
     * Group by File_media_on_folder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {file_media_on_folderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends file_media_on_folderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: file_media_on_folderGroupByArgs['orderBy'] }
        : { orderBy?: file_media_on_folderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, file_media_on_folderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFile_media_on_folderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the file_media_on_folder model
   */
  readonly fields: file_media_on_folderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for file_media_on_folder.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__file_media_on_folderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    media<T extends file_mediaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, file_mediaDefaultArgs<ExtArgs>>): Prisma__file_mediaClient<$Result.GetResult<Prisma.$file_mediaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    folder<T extends file_folderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, file_folderDefaultArgs<ExtArgs>>): Prisma__file_folderClient<$Result.GetResult<Prisma.$file_folderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the file_media_on_folder model
   */
  interface file_media_on_folderFieldRefs {
    readonly mediaId: FieldRef<"file_media_on_folder", 'String'>
    readonly folderId: FieldRef<"file_media_on_folder", 'String'>
  }
    

  // Custom InputTypes
  /**
   * file_media_on_folder findUnique
   */
  export type file_media_on_folderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the file_media_on_folder
     */
    select?: file_media_on_folderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the file_media_on_folder
     */
    omit?: file_media_on_folderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: file_media_on_folderInclude<ExtArgs> | null
    /**
     * Filter, which file_media_on_folder to fetch.
     */
    where: file_media_on_folderWhereUniqueInput
  }

  /**
   * file_media_on_folder findUniqueOrThrow
   */
  export type file_media_on_folderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the file_media_on_folder
     */
    select?: file_media_on_folderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the file_media_on_folder
     */
    omit?: file_media_on_folderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: file_media_on_folderInclude<ExtArgs> | null
    /**
     * Filter, which file_media_on_folder to fetch.
     */
    where: file_media_on_folderWhereUniqueInput
  }

  /**
   * file_media_on_folder findFirst
   */
  export type file_media_on_folderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the file_media_on_folder
     */
    select?: file_media_on_folderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the file_media_on_folder
     */
    omit?: file_media_on_folderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: file_media_on_folderInclude<ExtArgs> | null
    /**
     * Filter, which file_media_on_folder to fetch.
     */
    where?: file_media_on_folderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of file_media_on_folders to fetch.
     */
    orderBy?: file_media_on_folderOrderByWithRelationInput | file_media_on_folderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for file_media_on_folders.
     */
    cursor?: file_media_on_folderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` file_media_on_folders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` file_media_on_folders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of file_media_on_folders.
     */
    distinct?: File_media_on_folderScalarFieldEnum | File_media_on_folderScalarFieldEnum[]
  }

  /**
   * file_media_on_folder findFirstOrThrow
   */
  export type file_media_on_folderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the file_media_on_folder
     */
    select?: file_media_on_folderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the file_media_on_folder
     */
    omit?: file_media_on_folderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: file_media_on_folderInclude<ExtArgs> | null
    /**
     * Filter, which file_media_on_folder to fetch.
     */
    where?: file_media_on_folderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of file_media_on_folders to fetch.
     */
    orderBy?: file_media_on_folderOrderByWithRelationInput | file_media_on_folderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for file_media_on_folders.
     */
    cursor?: file_media_on_folderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` file_media_on_folders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` file_media_on_folders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of file_media_on_folders.
     */
    distinct?: File_media_on_folderScalarFieldEnum | File_media_on_folderScalarFieldEnum[]
  }

  /**
   * file_media_on_folder findMany
   */
  export type file_media_on_folderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the file_media_on_folder
     */
    select?: file_media_on_folderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the file_media_on_folder
     */
    omit?: file_media_on_folderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: file_media_on_folderInclude<ExtArgs> | null
    /**
     * Filter, which file_media_on_folders to fetch.
     */
    where?: file_media_on_folderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of file_media_on_folders to fetch.
     */
    orderBy?: file_media_on_folderOrderByWithRelationInput | file_media_on_folderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing file_media_on_folders.
     */
    cursor?: file_media_on_folderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` file_media_on_folders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` file_media_on_folders.
     */
    skip?: number
    distinct?: File_media_on_folderScalarFieldEnum | File_media_on_folderScalarFieldEnum[]
  }

  /**
   * file_media_on_folder create
   */
  export type file_media_on_folderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the file_media_on_folder
     */
    select?: file_media_on_folderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the file_media_on_folder
     */
    omit?: file_media_on_folderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: file_media_on_folderInclude<ExtArgs> | null
    /**
     * The data needed to create a file_media_on_folder.
     */
    data: XOR<file_media_on_folderCreateInput, file_media_on_folderUncheckedCreateInput>
  }

  /**
   * file_media_on_folder createMany
   */
  export type file_media_on_folderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many file_media_on_folders.
     */
    data: file_media_on_folderCreateManyInput | file_media_on_folderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * file_media_on_folder update
   */
  export type file_media_on_folderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the file_media_on_folder
     */
    select?: file_media_on_folderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the file_media_on_folder
     */
    omit?: file_media_on_folderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: file_media_on_folderInclude<ExtArgs> | null
    /**
     * The data needed to update a file_media_on_folder.
     */
    data: XOR<file_media_on_folderUpdateInput, file_media_on_folderUncheckedUpdateInput>
    /**
     * Choose, which file_media_on_folder to update.
     */
    where: file_media_on_folderWhereUniqueInput
  }

  /**
   * file_media_on_folder updateMany
   */
  export type file_media_on_folderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update file_media_on_folders.
     */
    data: XOR<file_media_on_folderUpdateManyMutationInput, file_media_on_folderUncheckedUpdateManyInput>
    /**
     * Filter which file_media_on_folders to update
     */
    where?: file_media_on_folderWhereInput
    /**
     * Limit how many file_media_on_folders to update.
     */
    limit?: number
  }

  /**
   * file_media_on_folder upsert
   */
  export type file_media_on_folderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the file_media_on_folder
     */
    select?: file_media_on_folderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the file_media_on_folder
     */
    omit?: file_media_on_folderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: file_media_on_folderInclude<ExtArgs> | null
    /**
     * The filter to search for the file_media_on_folder to update in case it exists.
     */
    where: file_media_on_folderWhereUniqueInput
    /**
     * In case the file_media_on_folder found by the `where` argument doesn't exist, create a new file_media_on_folder with this data.
     */
    create: XOR<file_media_on_folderCreateInput, file_media_on_folderUncheckedCreateInput>
    /**
     * In case the file_media_on_folder was found with the provided `where` argument, update it with this data.
     */
    update: XOR<file_media_on_folderUpdateInput, file_media_on_folderUncheckedUpdateInput>
  }

  /**
   * file_media_on_folder delete
   */
  export type file_media_on_folderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the file_media_on_folder
     */
    select?: file_media_on_folderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the file_media_on_folder
     */
    omit?: file_media_on_folderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: file_media_on_folderInclude<ExtArgs> | null
    /**
     * Filter which file_media_on_folder to delete.
     */
    where: file_media_on_folderWhereUniqueInput
  }

  /**
   * file_media_on_folder deleteMany
   */
  export type file_media_on_folderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which file_media_on_folders to delete
     */
    where?: file_media_on_folderWhereInput
    /**
     * Limit how many file_media_on_folders to delete.
     */
    limit?: number
  }

  /**
   * file_media_on_folder without action
   */
  export type file_media_on_folderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the file_media_on_folder
     */
    select?: file_media_on_folderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the file_media_on_folder
     */
    omit?: file_media_on_folderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: file_media_on_folderInclude<ExtArgs> | null
  }


  /**
   * Model file_folder
   */

  export type AggregateFile_folder = {
    _count: File_folderCountAggregateOutputType | null
    _min: File_folderMinAggregateOutputType | null
    _max: File_folderMaxAggregateOutputType | null
  }

  export type File_folderMinAggregateOutputType = {
    uid: string | null
    createAt: Date | null
    updateAt: Date | null
    name: string | null
    userId: string | null
    parentId: string | null
  }

  export type File_folderMaxAggregateOutputType = {
    uid: string | null
    createAt: Date | null
    updateAt: Date | null
    name: string | null
    userId: string | null
    parentId: string | null
  }

  export type File_folderCountAggregateOutputType = {
    uid: number
    createAt: number
    updateAt: number
    name: number
    userId: number
    parentId: number
    _all: number
  }


  export type File_folderMinAggregateInputType = {
    uid?: true
    createAt?: true
    updateAt?: true
    name?: true
    userId?: true
    parentId?: true
  }

  export type File_folderMaxAggregateInputType = {
    uid?: true
    createAt?: true
    updateAt?: true
    name?: true
    userId?: true
    parentId?: true
  }

  export type File_folderCountAggregateInputType = {
    uid?: true
    createAt?: true
    updateAt?: true
    name?: true
    userId?: true
    parentId?: true
    _all?: true
  }

  export type File_folderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which file_folder to aggregate.
     */
    where?: file_folderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of file_folders to fetch.
     */
    orderBy?: file_folderOrderByWithRelationInput | file_folderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: file_folderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` file_folders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` file_folders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned file_folders
    **/
    _count?: true | File_folderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: File_folderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: File_folderMaxAggregateInputType
  }

  export type GetFile_folderAggregateType<T extends File_folderAggregateArgs> = {
        [P in keyof T & keyof AggregateFile_folder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFile_folder[P]>
      : GetScalarType<T[P], AggregateFile_folder[P]>
  }




  export type file_folderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: file_folderWhereInput
    orderBy?: file_folderOrderByWithAggregationInput | file_folderOrderByWithAggregationInput[]
    by: File_folderScalarFieldEnum[] | File_folderScalarFieldEnum
    having?: file_folderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: File_folderCountAggregateInputType | true
    _min?: File_folderMinAggregateInputType
    _max?: File_folderMaxAggregateInputType
  }

  export type File_folderGroupByOutputType = {
    uid: string
    createAt: Date
    updateAt: Date
    name: string
    userId: string
    parentId: string | null
    _count: File_folderCountAggregateOutputType | null
    _min: File_folderMinAggregateOutputType | null
    _max: File_folderMaxAggregateOutputType | null
  }

  type GetFile_folderGroupByPayload<T extends file_folderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<File_folderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof File_folderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], File_folderGroupByOutputType[P]>
            : GetScalarType<T[P], File_folderGroupByOutputType[P]>
        }
      >
    >


  export type file_folderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    uid?: boolean
    createAt?: boolean
    updateAt?: boolean
    name?: boolean
    userId?: boolean
    parentId?: boolean
    user?: boolean | file_userDefaultArgs<ExtArgs>
    parent?: boolean | file_folder$parentArgs<ExtArgs>
    children?: boolean | file_folder$childrenArgs<ExtArgs>
    medias?: boolean | file_folder$mediasArgs<ExtArgs>
    _count?: boolean | File_folderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["file_folder"]>



  export type file_folderSelectScalar = {
    uid?: boolean
    createAt?: boolean
    updateAt?: boolean
    name?: boolean
    userId?: boolean
    parentId?: boolean
  }

  export type file_folderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"uid" | "createAt" | "updateAt" | "name" | "userId" | "parentId", ExtArgs["result"]["file_folder"]>
  export type file_folderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | file_userDefaultArgs<ExtArgs>
    parent?: boolean | file_folder$parentArgs<ExtArgs>
    children?: boolean | file_folder$childrenArgs<ExtArgs>
    medias?: boolean | file_folder$mediasArgs<ExtArgs>
    _count?: boolean | File_folderCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $file_folderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "file_folder"
    objects: {
      user: Prisma.$file_userPayload<ExtArgs>
      parent: Prisma.$file_folderPayload<ExtArgs> | null
      children: Prisma.$file_folderPayload<ExtArgs>[]
      medias: Prisma.$file_media_on_folderPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      uid: string
      createAt: Date
      updateAt: Date
      name: string
      userId: string
      parentId: string | null
    }, ExtArgs["result"]["file_folder"]>
    composites: {}
  }

  type file_folderGetPayload<S extends boolean | null | undefined | file_folderDefaultArgs> = $Result.GetResult<Prisma.$file_folderPayload, S>

  type file_folderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<file_folderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: File_folderCountAggregateInputType | true
    }

  export interface file_folderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['file_folder'], meta: { name: 'file_folder' } }
    /**
     * Find zero or one File_folder that matches the filter.
     * @param {file_folderFindUniqueArgs} args - Arguments to find a File_folder
     * @example
     * // Get one File_folder
     * const file_folder = await prisma.file_folder.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends file_folderFindUniqueArgs>(args: SelectSubset<T, file_folderFindUniqueArgs<ExtArgs>>): Prisma__file_folderClient<$Result.GetResult<Prisma.$file_folderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one File_folder that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {file_folderFindUniqueOrThrowArgs} args - Arguments to find a File_folder
     * @example
     * // Get one File_folder
     * const file_folder = await prisma.file_folder.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends file_folderFindUniqueOrThrowArgs>(args: SelectSubset<T, file_folderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__file_folderClient<$Result.GetResult<Prisma.$file_folderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first File_folder that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {file_folderFindFirstArgs} args - Arguments to find a File_folder
     * @example
     * // Get one File_folder
     * const file_folder = await prisma.file_folder.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends file_folderFindFirstArgs>(args?: SelectSubset<T, file_folderFindFirstArgs<ExtArgs>>): Prisma__file_folderClient<$Result.GetResult<Prisma.$file_folderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first File_folder that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {file_folderFindFirstOrThrowArgs} args - Arguments to find a File_folder
     * @example
     * // Get one File_folder
     * const file_folder = await prisma.file_folder.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends file_folderFindFirstOrThrowArgs>(args?: SelectSubset<T, file_folderFindFirstOrThrowArgs<ExtArgs>>): Prisma__file_folderClient<$Result.GetResult<Prisma.$file_folderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more File_folders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {file_folderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all File_folders
     * const file_folders = await prisma.file_folder.findMany()
     * 
     * // Get first 10 File_folders
     * const file_folders = await prisma.file_folder.findMany({ take: 10 })
     * 
     * // Only select the `uid`
     * const file_folderWithUidOnly = await prisma.file_folder.findMany({ select: { uid: true } })
     * 
     */
    findMany<T extends file_folderFindManyArgs>(args?: SelectSubset<T, file_folderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$file_folderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a File_folder.
     * @param {file_folderCreateArgs} args - Arguments to create a File_folder.
     * @example
     * // Create one File_folder
     * const File_folder = await prisma.file_folder.create({
     *   data: {
     *     // ... data to create a File_folder
     *   }
     * })
     * 
     */
    create<T extends file_folderCreateArgs>(args: SelectSubset<T, file_folderCreateArgs<ExtArgs>>): Prisma__file_folderClient<$Result.GetResult<Prisma.$file_folderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many File_folders.
     * @param {file_folderCreateManyArgs} args - Arguments to create many File_folders.
     * @example
     * // Create many File_folders
     * const file_folder = await prisma.file_folder.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends file_folderCreateManyArgs>(args?: SelectSubset<T, file_folderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a File_folder.
     * @param {file_folderDeleteArgs} args - Arguments to delete one File_folder.
     * @example
     * // Delete one File_folder
     * const File_folder = await prisma.file_folder.delete({
     *   where: {
     *     // ... filter to delete one File_folder
     *   }
     * })
     * 
     */
    delete<T extends file_folderDeleteArgs>(args: SelectSubset<T, file_folderDeleteArgs<ExtArgs>>): Prisma__file_folderClient<$Result.GetResult<Prisma.$file_folderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one File_folder.
     * @param {file_folderUpdateArgs} args - Arguments to update one File_folder.
     * @example
     * // Update one File_folder
     * const file_folder = await prisma.file_folder.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends file_folderUpdateArgs>(args: SelectSubset<T, file_folderUpdateArgs<ExtArgs>>): Prisma__file_folderClient<$Result.GetResult<Prisma.$file_folderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more File_folders.
     * @param {file_folderDeleteManyArgs} args - Arguments to filter File_folders to delete.
     * @example
     * // Delete a few File_folders
     * const { count } = await prisma.file_folder.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends file_folderDeleteManyArgs>(args?: SelectSubset<T, file_folderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more File_folders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {file_folderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many File_folders
     * const file_folder = await prisma.file_folder.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends file_folderUpdateManyArgs>(args: SelectSubset<T, file_folderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one File_folder.
     * @param {file_folderUpsertArgs} args - Arguments to update or create a File_folder.
     * @example
     * // Update or create a File_folder
     * const file_folder = await prisma.file_folder.upsert({
     *   create: {
     *     // ... data to create a File_folder
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the File_folder we want to update
     *   }
     * })
     */
    upsert<T extends file_folderUpsertArgs>(args: SelectSubset<T, file_folderUpsertArgs<ExtArgs>>): Prisma__file_folderClient<$Result.GetResult<Prisma.$file_folderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of File_folders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {file_folderCountArgs} args - Arguments to filter File_folders to count.
     * @example
     * // Count the number of File_folders
     * const count = await prisma.file_folder.count({
     *   where: {
     *     // ... the filter for the File_folders we want to count
     *   }
     * })
    **/
    count<T extends file_folderCountArgs>(
      args?: Subset<T, file_folderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], File_folderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a File_folder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {File_folderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends File_folderAggregateArgs>(args: Subset<T, File_folderAggregateArgs>): Prisma.PrismaPromise<GetFile_folderAggregateType<T>>

    /**
     * Group by File_folder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {file_folderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends file_folderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: file_folderGroupByArgs['orderBy'] }
        : { orderBy?: file_folderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, file_folderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFile_folderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the file_folder model
   */
  readonly fields: file_folderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for file_folder.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__file_folderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends file_userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, file_userDefaultArgs<ExtArgs>>): Prisma__file_userClient<$Result.GetResult<Prisma.$file_userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    parent<T extends file_folder$parentArgs<ExtArgs> = {}>(args?: Subset<T, file_folder$parentArgs<ExtArgs>>): Prisma__file_folderClient<$Result.GetResult<Prisma.$file_folderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    children<T extends file_folder$childrenArgs<ExtArgs> = {}>(args?: Subset<T, file_folder$childrenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$file_folderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    medias<T extends file_folder$mediasArgs<ExtArgs> = {}>(args?: Subset<T, file_folder$mediasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$file_media_on_folderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the file_folder model
   */
  interface file_folderFieldRefs {
    readonly uid: FieldRef<"file_folder", 'String'>
    readonly createAt: FieldRef<"file_folder", 'DateTime'>
    readonly updateAt: FieldRef<"file_folder", 'DateTime'>
    readonly name: FieldRef<"file_folder", 'String'>
    readonly userId: FieldRef<"file_folder", 'String'>
    readonly parentId: FieldRef<"file_folder", 'String'>
  }
    

  // Custom InputTypes
  /**
   * file_folder findUnique
   */
  export type file_folderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the file_folder
     */
    select?: file_folderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the file_folder
     */
    omit?: file_folderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: file_folderInclude<ExtArgs> | null
    /**
     * Filter, which file_folder to fetch.
     */
    where: file_folderWhereUniqueInput
  }

  /**
   * file_folder findUniqueOrThrow
   */
  export type file_folderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the file_folder
     */
    select?: file_folderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the file_folder
     */
    omit?: file_folderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: file_folderInclude<ExtArgs> | null
    /**
     * Filter, which file_folder to fetch.
     */
    where: file_folderWhereUniqueInput
  }

  /**
   * file_folder findFirst
   */
  export type file_folderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the file_folder
     */
    select?: file_folderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the file_folder
     */
    omit?: file_folderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: file_folderInclude<ExtArgs> | null
    /**
     * Filter, which file_folder to fetch.
     */
    where?: file_folderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of file_folders to fetch.
     */
    orderBy?: file_folderOrderByWithRelationInput | file_folderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for file_folders.
     */
    cursor?: file_folderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` file_folders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` file_folders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of file_folders.
     */
    distinct?: File_folderScalarFieldEnum | File_folderScalarFieldEnum[]
  }

  /**
   * file_folder findFirstOrThrow
   */
  export type file_folderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the file_folder
     */
    select?: file_folderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the file_folder
     */
    omit?: file_folderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: file_folderInclude<ExtArgs> | null
    /**
     * Filter, which file_folder to fetch.
     */
    where?: file_folderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of file_folders to fetch.
     */
    orderBy?: file_folderOrderByWithRelationInput | file_folderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for file_folders.
     */
    cursor?: file_folderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` file_folders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` file_folders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of file_folders.
     */
    distinct?: File_folderScalarFieldEnum | File_folderScalarFieldEnum[]
  }

  /**
   * file_folder findMany
   */
  export type file_folderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the file_folder
     */
    select?: file_folderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the file_folder
     */
    omit?: file_folderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: file_folderInclude<ExtArgs> | null
    /**
     * Filter, which file_folders to fetch.
     */
    where?: file_folderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of file_folders to fetch.
     */
    orderBy?: file_folderOrderByWithRelationInput | file_folderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing file_folders.
     */
    cursor?: file_folderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` file_folders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` file_folders.
     */
    skip?: number
    distinct?: File_folderScalarFieldEnum | File_folderScalarFieldEnum[]
  }

  /**
   * file_folder create
   */
  export type file_folderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the file_folder
     */
    select?: file_folderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the file_folder
     */
    omit?: file_folderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: file_folderInclude<ExtArgs> | null
    /**
     * The data needed to create a file_folder.
     */
    data: XOR<file_folderCreateInput, file_folderUncheckedCreateInput>
  }

  /**
   * file_folder createMany
   */
  export type file_folderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many file_folders.
     */
    data: file_folderCreateManyInput | file_folderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * file_folder update
   */
  export type file_folderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the file_folder
     */
    select?: file_folderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the file_folder
     */
    omit?: file_folderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: file_folderInclude<ExtArgs> | null
    /**
     * The data needed to update a file_folder.
     */
    data: XOR<file_folderUpdateInput, file_folderUncheckedUpdateInput>
    /**
     * Choose, which file_folder to update.
     */
    where: file_folderWhereUniqueInput
  }

  /**
   * file_folder updateMany
   */
  export type file_folderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update file_folders.
     */
    data: XOR<file_folderUpdateManyMutationInput, file_folderUncheckedUpdateManyInput>
    /**
     * Filter which file_folders to update
     */
    where?: file_folderWhereInput
    /**
     * Limit how many file_folders to update.
     */
    limit?: number
  }

  /**
   * file_folder upsert
   */
  export type file_folderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the file_folder
     */
    select?: file_folderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the file_folder
     */
    omit?: file_folderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: file_folderInclude<ExtArgs> | null
    /**
     * The filter to search for the file_folder to update in case it exists.
     */
    where: file_folderWhereUniqueInput
    /**
     * In case the file_folder found by the `where` argument doesn't exist, create a new file_folder with this data.
     */
    create: XOR<file_folderCreateInput, file_folderUncheckedCreateInput>
    /**
     * In case the file_folder was found with the provided `where` argument, update it with this data.
     */
    update: XOR<file_folderUpdateInput, file_folderUncheckedUpdateInput>
  }

  /**
   * file_folder delete
   */
  export type file_folderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the file_folder
     */
    select?: file_folderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the file_folder
     */
    omit?: file_folderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: file_folderInclude<ExtArgs> | null
    /**
     * Filter which file_folder to delete.
     */
    where: file_folderWhereUniqueInput
  }

  /**
   * file_folder deleteMany
   */
  export type file_folderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which file_folders to delete
     */
    where?: file_folderWhereInput
    /**
     * Limit how many file_folders to delete.
     */
    limit?: number
  }

  /**
   * file_folder.parent
   */
  export type file_folder$parentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the file_folder
     */
    select?: file_folderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the file_folder
     */
    omit?: file_folderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: file_folderInclude<ExtArgs> | null
    where?: file_folderWhereInput
  }

  /**
   * file_folder.children
   */
  export type file_folder$childrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the file_folder
     */
    select?: file_folderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the file_folder
     */
    omit?: file_folderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: file_folderInclude<ExtArgs> | null
    where?: file_folderWhereInput
    orderBy?: file_folderOrderByWithRelationInput | file_folderOrderByWithRelationInput[]
    cursor?: file_folderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: File_folderScalarFieldEnum | File_folderScalarFieldEnum[]
  }

  /**
   * file_folder.medias
   */
  export type file_folder$mediasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the file_media_on_folder
     */
    select?: file_media_on_folderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the file_media_on_folder
     */
    omit?: file_media_on_folderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: file_media_on_folderInclude<ExtArgs> | null
    where?: file_media_on_folderWhereInput
    orderBy?: file_media_on_folderOrderByWithRelationInput | file_media_on_folderOrderByWithRelationInput[]
    cursor?: file_media_on_folderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: File_media_on_folderScalarFieldEnum | File_media_on_folderScalarFieldEnum[]
  }

  /**
   * file_folder without action
   */
  export type file_folderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the file_folder
     */
    select?: file_folderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the file_folder
     */
    omit?: file_folderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: file_folderInclude<ExtArgs> | null
  }


  /**
   * Model book_user
   */

  export type AggregateBook_user = {
    _count: Book_userCountAggregateOutputType | null
    _min: Book_userMinAggregateOutputType | null
    _max: Book_userMaxAggregateOutputType | null
  }

  export type Book_userMinAggregateOutputType = {
    id: string | null
    createAt: Date | null
    updateAt: Date | null
    name: string | null
    email: string | null
    password: string | null
    role: $Enums.book_role | null
    book_roleId: string | null
  }

  export type Book_userMaxAggregateOutputType = {
    id: string | null
    createAt: Date | null
    updateAt: Date | null
    name: string | null
    email: string | null
    password: string | null
    role: $Enums.book_role | null
    book_roleId: string | null
  }

  export type Book_userCountAggregateOutputType = {
    id: number
    createAt: number
    updateAt: number
    name: number
    email: number
    password: number
    role: number
    book_roleId: number
    _all: number
  }


  export type Book_userMinAggregateInputType = {
    id?: true
    createAt?: true
    updateAt?: true
    name?: true
    email?: true
    password?: true
    role?: true
    book_roleId?: true
  }

  export type Book_userMaxAggregateInputType = {
    id?: true
    createAt?: true
    updateAt?: true
    name?: true
    email?: true
    password?: true
    role?: true
    book_roleId?: true
  }

  export type Book_userCountAggregateInputType = {
    id?: true
    createAt?: true
    updateAt?: true
    name?: true
    email?: true
    password?: true
    role?: true
    book_roleId?: true
    _all?: true
  }

  export type Book_userAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which book_user to aggregate.
     */
    where?: book_userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of book_users to fetch.
     */
    orderBy?: book_userOrderByWithRelationInput | book_userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: book_userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` book_users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` book_users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned book_users
    **/
    _count?: true | Book_userCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Book_userMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Book_userMaxAggregateInputType
  }

  export type GetBook_userAggregateType<T extends Book_userAggregateArgs> = {
        [P in keyof T & keyof AggregateBook_user]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBook_user[P]>
      : GetScalarType<T[P], AggregateBook_user[P]>
  }




  export type book_userGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: book_userWhereInput
    orderBy?: book_userOrderByWithAggregationInput | book_userOrderByWithAggregationInput[]
    by: Book_userScalarFieldEnum[] | Book_userScalarFieldEnum
    having?: book_userScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Book_userCountAggregateInputType | true
    _min?: Book_userMinAggregateInputType
    _max?: Book_userMaxAggregateInputType
  }

  export type Book_userGroupByOutputType = {
    id: string
    createAt: Date
    updateAt: Date
    name: string
    email: string
    password: string
    role: $Enums.book_role
    book_roleId: string
    _count: Book_userCountAggregateOutputType | null
    _min: Book_userMinAggregateOutputType | null
    _max: Book_userMaxAggregateOutputType | null
  }

  type GetBook_userGroupByPayload<T extends book_userGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Book_userGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Book_userGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Book_userGroupByOutputType[P]>
            : GetScalarType<T[P], Book_userGroupByOutputType[P]>
        }
      >
    >


  export type book_userSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createAt?: boolean
    updateAt?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    book_roleId?: boolean
    borrowed?: boolean | book_user$borrowedArgs<ExtArgs>
    book_borrow_history?: boolean | book_user$book_borrow_historyArgs<ExtArgs>
    book_rating?: boolean | book_user$book_ratingArgs<ExtArgs>
    _count?: boolean | Book_userCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["book_user"]>



  export type book_userSelectScalar = {
    id?: boolean
    createAt?: boolean
    updateAt?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    book_roleId?: boolean
  }

  export type book_userOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createAt" | "updateAt" | "name" | "email" | "password" | "role" | "book_roleId", ExtArgs["result"]["book_user"]>
  export type book_userInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    borrowed?: boolean | book_user$borrowedArgs<ExtArgs>
    book_borrow_history?: boolean | book_user$book_borrow_historyArgs<ExtArgs>
    book_rating?: boolean | book_user$book_ratingArgs<ExtArgs>
    _count?: boolean | Book_userCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $book_userPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "book_user"
    objects: {
      borrowed: Prisma.$book_borrowedPayload<ExtArgs>[]
      book_borrow_history: Prisma.$book_borrow_historyPayload<ExtArgs>[]
      book_rating: Prisma.$book_ratingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createAt: Date
      updateAt: Date
      name: string
      email: string
      password: string
      role: $Enums.book_role
      book_roleId: string
    }, ExtArgs["result"]["book_user"]>
    composites: {}
  }

  type book_userGetPayload<S extends boolean | null | undefined | book_userDefaultArgs> = $Result.GetResult<Prisma.$book_userPayload, S>

  type book_userCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<book_userFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Book_userCountAggregateInputType | true
    }

  export interface book_userDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['book_user'], meta: { name: 'book_user' } }
    /**
     * Find zero or one Book_user that matches the filter.
     * @param {book_userFindUniqueArgs} args - Arguments to find a Book_user
     * @example
     * // Get one Book_user
     * const book_user = await prisma.book_user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends book_userFindUniqueArgs>(args: SelectSubset<T, book_userFindUniqueArgs<ExtArgs>>): Prisma__book_userClient<$Result.GetResult<Prisma.$book_userPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Book_user that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {book_userFindUniqueOrThrowArgs} args - Arguments to find a Book_user
     * @example
     * // Get one Book_user
     * const book_user = await prisma.book_user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends book_userFindUniqueOrThrowArgs>(args: SelectSubset<T, book_userFindUniqueOrThrowArgs<ExtArgs>>): Prisma__book_userClient<$Result.GetResult<Prisma.$book_userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Book_user that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {book_userFindFirstArgs} args - Arguments to find a Book_user
     * @example
     * // Get one Book_user
     * const book_user = await prisma.book_user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends book_userFindFirstArgs>(args?: SelectSubset<T, book_userFindFirstArgs<ExtArgs>>): Prisma__book_userClient<$Result.GetResult<Prisma.$book_userPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Book_user that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {book_userFindFirstOrThrowArgs} args - Arguments to find a Book_user
     * @example
     * // Get one Book_user
     * const book_user = await prisma.book_user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends book_userFindFirstOrThrowArgs>(args?: SelectSubset<T, book_userFindFirstOrThrowArgs<ExtArgs>>): Prisma__book_userClient<$Result.GetResult<Prisma.$book_userPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Book_users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {book_userFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Book_users
     * const book_users = await prisma.book_user.findMany()
     * 
     * // Get first 10 Book_users
     * const book_users = await prisma.book_user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const book_userWithIdOnly = await prisma.book_user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends book_userFindManyArgs>(args?: SelectSubset<T, book_userFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$book_userPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Book_user.
     * @param {book_userCreateArgs} args - Arguments to create a Book_user.
     * @example
     * // Create one Book_user
     * const Book_user = await prisma.book_user.create({
     *   data: {
     *     // ... data to create a Book_user
     *   }
     * })
     * 
     */
    create<T extends book_userCreateArgs>(args: SelectSubset<T, book_userCreateArgs<ExtArgs>>): Prisma__book_userClient<$Result.GetResult<Prisma.$book_userPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Book_users.
     * @param {book_userCreateManyArgs} args - Arguments to create many Book_users.
     * @example
     * // Create many Book_users
     * const book_user = await prisma.book_user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends book_userCreateManyArgs>(args?: SelectSubset<T, book_userCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Book_user.
     * @param {book_userDeleteArgs} args - Arguments to delete one Book_user.
     * @example
     * // Delete one Book_user
     * const Book_user = await prisma.book_user.delete({
     *   where: {
     *     // ... filter to delete one Book_user
     *   }
     * })
     * 
     */
    delete<T extends book_userDeleteArgs>(args: SelectSubset<T, book_userDeleteArgs<ExtArgs>>): Prisma__book_userClient<$Result.GetResult<Prisma.$book_userPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Book_user.
     * @param {book_userUpdateArgs} args - Arguments to update one Book_user.
     * @example
     * // Update one Book_user
     * const book_user = await prisma.book_user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends book_userUpdateArgs>(args: SelectSubset<T, book_userUpdateArgs<ExtArgs>>): Prisma__book_userClient<$Result.GetResult<Prisma.$book_userPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Book_users.
     * @param {book_userDeleteManyArgs} args - Arguments to filter Book_users to delete.
     * @example
     * // Delete a few Book_users
     * const { count } = await prisma.book_user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends book_userDeleteManyArgs>(args?: SelectSubset<T, book_userDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Book_users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {book_userUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Book_users
     * const book_user = await prisma.book_user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends book_userUpdateManyArgs>(args: SelectSubset<T, book_userUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Book_user.
     * @param {book_userUpsertArgs} args - Arguments to update or create a Book_user.
     * @example
     * // Update or create a Book_user
     * const book_user = await prisma.book_user.upsert({
     *   create: {
     *     // ... data to create a Book_user
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Book_user we want to update
     *   }
     * })
     */
    upsert<T extends book_userUpsertArgs>(args: SelectSubset<T, book_userUpsertArgs<ExtArgs>>): Prisma__book_userClient<$Result.GetResult<Prisma.$book_userPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Book_users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {book_userCountArgs} args - Arguments to filter Book_users to count.
     * @example
     * // Count the number of Book_users
     * const count = await prisma.book_user.count({
     *   where: {
     *     // ... the filter for the Book_users we want to count
     *   }
     * })
    **/
    count<T extends book_userCountArgs>(
      args?: Subset<T, book_userCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Book_userCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Book_user.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Book_userAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Book_userAggregateArgs>(args: Subset<T, Book_userAggregateArgs>): Prisma.PrismaPromise<GetBook_userAggregateType<T>>

    /**
     * Group by Book_user.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {book_userGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends book_userGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: book_userGroupByArgs['orderBy'] }
        : { orderBy?: book_userGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, book_userGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBook_userGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the book_user model
   */
  readonly fields: book_userFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for book_user.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__book_userClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    borrowed<T extends book_user$borrowedArgs<ExtArgs> = {}>(args?: Subset<T, book_user$borrowedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$book_borrowedPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    book_borrow_history<T extends book_user$book_borrow_historyArgs<ExtArgs> = {}>(args?: Subset<T, book_user$book_borrow_historyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$book_borrow_historyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    book_rating<T extends book_user$book_ratingArgs<ExtArgs> = {}>(args?: Subset<T, book_user$book_ratingArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$book_ratingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the book_user model
   */
  interface book_userFieldRefs {
    readonly id: FieldRef<"book_user", 'String'>
    readonly createAt: FieldRef<"book_user", 'DateTime'>
    readonly updateAt: FieldRef<"book_user", 'DateTime'>
    readonly name: FieldRef<"book_user", 'String'>
    readonly email: FieldRef<"book_user", 'String'>
    readonly password: FieldRef<"book_user", 'String'>
    readonly role: FieldRef<"book_user", 'book_role'>
    readonly book_roleId: FieldRef<"book_user", 'String'>
  }
    

  // Custom InputTypes
  /**
   * book_user findUnique
   */
  export type book_userFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the book_user
     */
    select?: book_userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the book_user
     */
    omit?: book_userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: book_userInclude<ExtArgs> | null
    /**
     * Filter, which book_user to fetch.
     */
    where: book_userWhereUniqueInput
  }

  /**
   * book_user findUniqueOrThrow
   */
  export type book_userFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the book_user
     */
    select?: book_userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the book_user
     */
    omit?: book_userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: book_userInclude<ExtArgs> | null
    /**
     * Filter, which book_user to fetch.
     */
    where: book_userWhereUniqueInput
  }

  /**
   * book_user findFirst
   */
  export type book_userFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the book_user
     */
    select?: book_userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the book_user
     */
    omit?: book_userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: book_userInclude<ExtArgs> | null
    /**
     * Filter, which book_user to fetch.
     */
    where?: book_userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of book_users to fetch.
     */
    orderBy?: book_userOrderByWithRelationInput | book_userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for book_users.
     */
    cursor?: book_userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` book_users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` book_users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of book_users.
     */
    distinct?: Book_userScalarFieldEnum | Book_userScalarFieldEnum[]
  }

  /**
   * book_user findFirstOrThrow
   */
  export type book_userFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the book_user
     */
    select?: book_userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the book_user
     */
    omit?: book_userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: book_userInclude<ExtArgs> | null
    /**
     * Filter, which book_user to fetch.
     */
    where?: book_userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of book_users to fetch.
     */
    orderBy?: book_userOrderByWithRelationInput | book_userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for book_users.
     */
    cursor?: book_userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` book_users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` book_users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of book_users.
     */
    distinct?: Book_userScalarFieldEnum | Book_userScalarFieldEnum[]
  }

  /**
   * book_user findMany
   */
  export type book_userFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the book_user
     */
    select?: book_userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the book_user
     */
    omit?: book_userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: book_userInclude<ExtArgs> | null
    /**
     * Filter, which book_users to fetch.
     */
    where?: book_userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of book_users to fetch.
     */
    orderBy?: book_userOrderByWithRelationInput | book_userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing book_users.
     */
    cursor?: book_userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` book_users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` book_users.
     */
    skip?: number
    distinct?: Book_userScalarFieldEnum | Book_userScalarFieldEnum[]
  }

  /**
   * book_user create
   */
  export type book_userCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the book_user
     */
    select?: book_userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the book_user
     */
    omit?: book_userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: book_userInclude<ExtArgs> | null
    /**
     * The data needed to create a book_user.
     */
    data: XOR<book_userCreateInput, book_userUncheckedCreateInput>
  }

  /**
   * book_user createMany
   */
  export type book_userCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many book_users.
     */
    data: book_userCreateManyInput | book_userCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * book_user update
   */
  export type book_userUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the book_user
     */
    select?: book_userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the book_user
     */
    omit?: book_userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: book_userInclude<ExtArgs> | null
    /**
     * The data needed to update a book_user.
     */
    data: XOR<book_userUpdateInput, book_userUncheckedUpdateInput>
    /**
     * Choose, which book_user to update.
     */
    where: book_userWhereUniqueInput
  }

  /**
   * book_user updateMany
   */
  export type book_userUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update book_users.
     */
    data: XOR<book_userUpdateManyMutationInput, book_userUncheckedUpdateManyInput>
    /**
     * Filter which book_users to update
     */
    where?: book_userWhereInput
    /**
     * Limit how many book_users to update.
     */
    limit?: number
  }

  /**
   * book_user upsert
   */
  export type book_userUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the book_user
     */
    select?: book_userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the book_user
     */
    omit?: book_userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: book_userInclude<ExtArgs> | null
    /**
     * The filter to search for the book_user to update in case it exists.
     */
    where: book_userWhereUniqueInput
    /**
     * In case the book_user found by the `where` argument doesn't exist, create a new book_user with this data.
     */
    create: XOR<book_userCreateInput, book_userUncheckedCreateInput>
    /**
     * In case the book_user was found with the provided `where` argument, update it with this data.
     */
    update: XOR<book_userUpdateInput, book_userUncheckedUpdateInput>
  }

  /**
   * book_user delete
   */
  export type book_userDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the book_user
     */
    select?: book_userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the book_user
     */
    omit?: book_userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: book_userInclude<ExtArgs> | null
    /**
     * Filter which book_user to delete.
     */
    where: book_userWhereUniqueInput
  }

  /**
   * book_user deleteMany
   */
  export type book_userDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which book_users to delete
     */
    where?: book_userWhereInput
    /**
     * Limit how many book_users to delete.
     */
    limit?: number
  }

  /**
   * book_user.borrowed
   */
  export type book_user$borrowedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the book_borrowed
     */
    select?: book_borrowedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the book_borrowed
     */
    omit?: book_borrowedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: book_borrowedInclude<ExtArgs> | null
    where?: book_borrowedWhereInput
    orderBy?: book_borrowedOrderByWithRelationInput | book_borrowedOrderByWithRelationInput[]
    cursor?: book_borrowedWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Book_borrowedScalarFieldEnum | Book_borrowedScalarFieldEnum[]
  }

  /**
   * book_user.book_borrow_history
   */
  export type book_user$book_borrow_historyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the book_borrow_history
     */
    select?: book_borrow_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the book_borrow_history
     */
    omit?: book_borrow_historyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: book_borrow_historyInclude<ExtArgs> | null
    where?: book_borrow_historyWhereInput
    orderBy?: book_borrow_historyOrderByWithRelationInput | book_borrow_historyOrderByWithRelationInput[]
    cursor?: book_borrow_historyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Book_borrow_historyScalarFieldEnum | Book_borrow_historyScalarFieldEnum[]
  }

  /**
   * book_user.book_rating
   */
  export type book_user$book_ratingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the book_rating
     */
    select?: book_ratingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the book_rating
     */
    omit?: book_ratingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: book_ratingInclude<ExtArgs> | null
    where?: book_ratingWhereInput
    orderBy?: book_ratingOrderByWithRelationInput | book_ratingOrderByWithRelationInput[]
    cursor?: book_ratingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Book_ratingScalarFieldEnum | Book_ratingScalarFieldEnum[]
  }

  /**
   * book_user without action
   */
  export type book_userDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the book_user
     */
    select?: book_userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the book_user
     */
    omit?: book_userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: book_userInclude<ExtArgs> | null
  }


  /**
   * Model book_book
   */

  export type AggregateBook_book = {
    _count: Book_bookCountAggregateOutputType | null
    _min: Book_bookMinAggregateOutputType | null
    _max: Book_bookMaxAggregateOutputType | null
  }

  export type Book_bookMinAggregateOutputType = {
    id: string | null
    createAt: Date | null
    updateAt: Date | null
    title: string | null
    author: string | null
    isbn: string | null
    description: string | null
    publication: Date | null
    categoryId: string | null
    available: boolean | null
  }

  export type Book_bookMaxAggregateOutputType = {
    id: string | null
    createAt: Date | null
    updateAt: Date | null
    title: string | null
    author: string | null
    isbn: string | null
    description: string | null
    publication: Date | null
    categoryId: string | null
    available: boolean | null
  }

  export type Book_bookCountAggregateOutputType = {
    id: number
    createAt: number
    updateAt: number
    title: number
    author: number
    isbn: number
    description: number
    publication: number
    categoryId: number
    available: number
    _all: number
  }


  export type Book_bookMinAggregateInputType = {
    id?: true
    createAt?: true
    updateAt?: true
    title?: true
    author?: true
    isbn?: true
    description?: true
    publication?: true
    categoryId?: true
    available?: true
  }

  export type Book_bookMaxAggregateInputType = {
    id?: true
    createAt?: true
    updateAt?: true
    title?: true
    author?: true
    isbn?: true
    description?: true
    publication?: true
    categoryId?: true
    available?: true
  }

  export type Book_bookCountAggregateInputType = {
    id?: true
    createAt?: true
    updateAt?: true
    title?: true
    author?: true
    isbn?: true
    description?: true
    publication?: true
    categoryId?: true
    available?: true
    _all?: true
  }

  export type Book_bookAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which book_book to aggregate.
     */
    where?: book_bookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of book_books to fetch.
     */
    orderBy?: book_bookOrderByWithRelationInput | book_bookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: book_bookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` book_books from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` book_books.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned book_books
    **/
    _count?: true | Book_bookCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Book_bookMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Book_bookMaxAggregateInputType
  }

  export type GetBook_bookAggregateType<T extends Book_bookAggregateArgs> = {
        [P in keyof T & keyof AggregateBook_book]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBook_book[P]>
      : GetScalarType<T[P], AggregateBook_book[P]>
  }




  export type book_bookGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: book_bookWhereInput
    orderBy?: book_bookOrderByWithAggregationInput | book_bookOrderByWithAggregationInput[]
    by: Book_bookScalarFieldEnum[] | Book_bookScalarFieldEnum
    having?: book_bookScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Book_bookCountAggregateInputType | true
    _min?: Book_bookMinAggregateInputType
    _max?: Book_bookMaxAggregateInputType
  }

  export type Book_bookGroupByOutputType = {
    id: string
    createAt: Date
    updateAt: Date
    title: string
    author: string
    isbn: string
    description: string | null
    publication: Date
    categoryId: string
    available: boolean
    _count: Book_bookCountAggregateOutputType | null
    _min: Book_bookMinAggregateOutputType | null
    _max: Book_bookMaxAggregateOutputType | null
  }

  type GetBook_bookGroupByPayload<T extends book_bookGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Book_bookGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Book_bookGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Book_bookGroupByOutputType[P]>
            : GetScalarType<T[P], Book_bookGroupByOutputType[P]>
        }
      >
    >


  export type book_bookSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createAt?: boolean
    updateAt?: boolean
    title?: boolean
    author?: boolean
    isbn?: boolean
    description?: boolean
    publication?: boolean
    categoryId?: boolean
    available?: boolean
    category?: boolean | book_categoryDefaultArgs<ExtArgs>
    borrowed?: boolean | book_book$borrowedArgs<ExtArgs>
    book_borrow_history?: boolean | book_book$book_borrow_historyArgs<ExtArgs>
    book_rating?: boolean | book_book$book_ratingArgs<ExtArgs>
    _count?: boolean | Book_bookCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["book_book"]>



  export type book_bookSelectScalar = {
    id?: boolean
    createAt?: boolean
    updateAt?: boolean
    title?: boolean
    author?: boolean
    isbn?: boolean
    description?: boolean
    publication?: boolean
    categoryId?: boolean
    available?: boolean
  }

  export type book_bookOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createAt" | "updateAt" | "title" | "author" | "isbn" | "description" | "publication" | "categoryId" | "available", ExtArgs["result"]["book_book"]>
  export type book_bookInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | book_categoryDefaultArgs<ExtArgs>
    borrowed?: boolean | book_book$borrowedArgs<ExtArgs>
    book_borrow_history?: boolean | book_book$book_borrow_historyArgs<ExtArgs>
    book_rating?: boolean | book_book$book_ratingArgs<ExtArgs>
    _count?: boolean | Book_bookCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $book_bookPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "book_book"
    objects: {
      category: Prisma.$book_categoryPayload<ExtArgs>
      borrowed: Prisma.$book_borrowedPayload<ExtArgs>[]
      book_borrow_history: Prisma.$book_borrow_historyPayload<ExtArgs>[]
      book_rating: Prisma.$book_ratingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createAt: Date
      updateAt: Date
      title: string
      author: string
      isbn: string
      description: string | null
      publication: Date
      categoryId: string
      available: boolean
    }, ExtArgs["result"]["book_book"]>
    composites: {}
  }

  type book_bookGetPayload<S extends boolean | null | undefined | book_bookDefaultArgs> = $Result.GetResult<Prisma.$book_bookPayload, S>

  type book_bookCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<book_bookFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Book_bookCountAggregateInputType | true
    }

  export interface book_bookDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['book_book'], meta: { name: 'book_book' } }
    /**
     * Find zero or one Book_book that matches the filter.
     * @param {book_bookFindUniqueArgs} args - Arguments to find a Book_book
     * @example
     * // Get one Book_book
     * const book_book = await prisma.book_book.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends book_bookFindUniqueArgs>(args: SelectSubset<T, book_bookFindUniqueArgs<ExtArgs>>): Prisma__book_bookClient<$Result.GetResult<Prisma.$book_bookPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Book_book that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {book_bookFindUniqueOrThrowArgs} args - Arguments to find a Book_book
     * @example
     * // Get one Book_book
     * const book_book = await prisma.book_book.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends book_bookFindUniqueOrThrowArgs>(args: SelectSubset<T, book_bookFindUniqueOrThrowArgs<ExtArgs>>): Prisma__book_bookClient<$Result.GetResult<Prisma.$book_bookPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Book_book that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {book_bookFindFirstArgs} args - Arguments to find a Book_book
     * @example
     * // Get one Book_book
     * const book_book = await prisma.book_book.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends book_bookFindFirstArgs>(args?: SelectSubset<T, book_bookFindFirstArgs<ExtArgs>>): Prisma__book_bookClient<$Result.GetResult<Prisma.$book_bookPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Book_book that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {book_bookFindFirstOrThrowArgs} args - Arguments to find a Book_book
     * @example
     * // Get one Book_book
     * const book_book = await prisma.book_book.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends book_bookFindFirstOrThrowArgs>(args?: SelectSubset<T, book_bookFindFirstOrThrowArgs<ExtArgs>>): Prisma__book_bookClient<$Result.GetResult<Prisma.$book_bookPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Book_books that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {book_bookFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Book_books
     * const book_books = await prisma.book_book.findMany()
     * 
     * // Get first 10 Book_books
     * const book_books = await prisma.book_book.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const book_bookWithIdOnly = await prisma.book_book.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends book_bookFindManyArgs>(args?: SelectSubset<T, book_bookFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$book_bookPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Book_book.
     * @param {book_bookCreateArgs} args - Arguments to create a Book_book.
     * @example
     * // Create one Book_book
     * const Book_book = await prisma.book_book.create({
     *   data: {
     *     // ... data to create a Book_book
     *   }
     * })
     * 
     */
    create<T extends book_bookCreateArgs>(args: SelectSubset<T, book_bookCreateArgs<ExtArgs>>): Prisma__book_bookClient<$Result.GetResult<Prisma.$book_bookPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Book_books.
     * @param {book_bookCreateManyArgs} args - Arguments to create many Book_books.
     * @example
     * // Create many Book_books
     * const book_book = await prisma.book_book.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends book_bookCreateManyArgs>(args?: SelectSubset<T, book_bookCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Book_book.
     * @param {book_bookDeleteArgs} args - Arguments to delete one Book_book.
     * @example
     * // Delete one Book_book
     * const Book_book = await prisma.book_book.delete({
     *   where: {
     *     // ... filter to delete one Book_book
     *   }
     * })
     * 
     */
    delete<T extends book_bookDeleteArgs>(args: SelectSubset<T, book_bookDeleteArgs<ExtArgs>>): Prisma__book_bookClient<$Result.GetResult<Prisma.$book_bookPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Book_book.
     * @param {book_bookUpdateArgs} args - Arguments to update one Book_book.
     * @example
     * // Update one Book_book
     * const book_book = await prisma.book_book.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends book_bookUpdateArgs>(args: SelectSubset<T, book_bookUpdateArgs<ExtArgs>>): Prisma__book_bookClient<$Result.GetResult<Prisma.$book_bookPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Book_books.
     * @param {book_bookDeleteManyArgs} args - Arguments to filter Book_books to delete.
     * @example
     * // Delete a few Book_books
     * const { count } = await prisma.book_book.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends book_bookDeleteManyArgs>(args?: SelectSubset<T, book_bookDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Book_books.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {book_bookUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Book_books
     * const book_book = await prisma.book_book.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends book_bookUpdateManyArgs>(args: SelectSubset<T, book_bookUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Book_book.
     * @param {book_bookUpsertArgs} args - Arguments to update or create a Book_book.
     * @example
     * // Update or create a Book_book
     * const book_book = await prisma.book_book.upsert({
     *   create: {
     *     // ... data to create a Book_book
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Book_book we want to update
     *   }
     * })
     */
    upsert<T extends book_bookUpsertArgs>(args: SelectSubset<T, book_bookUpsertArgs<ExtArgs>>): Prisma__book_bookClient<$Result.GetResult<Prisma.$book_bookPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Book_books.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {book_bookCountArgs} args - Arguments to filter Book_books to count.
     * @example
     * // Count the number of Book_books
     * const count = await prisma.book_book.count({
     *   where: {
     *     // ... the filter for the Book_books we want to count
     *   }
     * })
    **/
    count<T extends book_bookCountArgs>(
      args?: Subset<T, book_bookCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Book_bookCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Book_book.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Book_bookAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Book_bookAggregateArgs>(args: Subset<T, Book_bookAggregateArgs>): Prisma.PrismaPromise<GetBook_bookAggregateType<T>>

    /**
     * Group by Book_book.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {book_bookGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends book_bookGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: book_bookGroupByArgs['orderBy'] }
        : { orderBy?: book_bookGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, book_bookGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBook_bookGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the book_book model
   */
  readonly fields: book_bookFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for book_book.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__book_bookClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    category<T extends book_categoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, book_categoryDefaultArgs<ExtArgs>>): Prisma__book_categoryClient<$Result.GetResult<Prisma.$book_categoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    borrowed<T extends book_book$borrowedArgs<ExtArgs> = {}>(args?: Subset<T, book_book$borrowedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$book_borrowedPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    book_borrow_history<T extends book_book$book_borrow_historyArgs<ExtArgs> = {}>(args?: Subset<T, book_book$book_borrow_historyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$book_borrow_historyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    book_rating<T extends book_book$book_ratingArgs<ExtArgs> = {}>(args?: Subset<T, book_book$book_ratingArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$book_ratingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the book_book model
   */
  interface book_bookFieldRefs {
    readonly id: FieldRef<"book_book", 'String'>
    readonly createAt: FieldRef<"book_book", 'DateTime'>
    readonly updateAt: FieldRef<"book_book", 'DateTime'>
    readonly title: FieldRef<"book_book", 'String'>
    readonly author: FieldRef<"book_book", 'String'>
    readonly isbn: FieldRef<"book_book", 'String'>
    readonly description: FieldRef<"book_book", 'String'>
    readonly publication: FieldRef<"book_book", 'DateTime'>
    readonly categoryId: FieldRef<"book_book", 'String'>
    readonly available: FieldRef<"book_book", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * book_book findUnique
   */
  export type book_bookFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the book_book
     */
    select?: book_bookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the book_book
     */
    omit?: book_bookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: book_bookInclude<ExtArgs> | null
    /**
     * Filter, which book_book to fetch.
     */
    where: book_bookWhereUniqueInput
  }

  /**
   * book_book findUniqueOrThrow
   */
  export type book_bookFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the book_book
     */
    select?: book_bookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the book_book
     */
    omit?: book_bookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: book_bookInclude<ExtArgs> | null
    /**
     * Filter, which book_book to fetch.
     */
    where: book_bookWhereUniqueInput
  }

  /**
   * book_book findFirst
   */
  export type book_bookFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the book_book
     */
    select?: book_bookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the book_book
     */
    omit?: book_bookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: book_bookInclude<ExtArgs> | null
    /**
     * Filter, which book_book to fetch.
     */
    where?: book_bookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of book_books to fetch.
     */
    orderBy?: book_bookOrderByWithRelationInput | book_bookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for book_books.
     */
    cursor?: book_bookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` book_books from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` book_books.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of book_books.
     */
    distinct?: Book_bookScalarFieldEnum | Book_bookScalarFieldEnum[]
  }

  /**
   * book_book findFirstOrThrow
   */
  export type book_bookFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the book_book
     */
    select?: book_bookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the book_book
     */
    omit?: book_bookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: book_bookInclude<ExtArgs> | null
    /**
     * Filter, which book_book to fetch.
     */
    where?: book_bookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of book_books to fetch.
     */
    orderBy?: book_bookOrderByWithRelationInput | book_bookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for book_books.
     */
    cursor?: book_bookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` book_books from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` book_books.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of book_books.
     */
    distinct?: Book_bookScalarFieldEnum | Book_bookScalarFieldEnum[]
  }

  /**
   * book_book findMany
   */
  export type book_bookFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the book_book
     */
    select?: book_bookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the book_book
     */
    omit?: book_bookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: book_bookInclude<ExtArgs> | null
    /**
     * Filter, which book_books to fetch.
     */
    where?: book_bookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of book_books to fetch.
     */
    orderBy?: book_bookOrderByWithRelationInput | book_bookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing book_books.
     */
    cursor?: book_bookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` book_books from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` book_books.
     */
    skip?: number
    distinct?: Book_bookScalarFieldEnum | Book_bookScalarFieldEnum[]
  }

  /**
   * book_book create
   */
  export type book_bookCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the book_book
     */
    select?: book_bookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the book_book
     */
    omit?: book_bookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: book_bookInclude<ExtArgs> | null
    /**
     * The data needed to create a book_book.
     */
    data: XOR<book_bookCreateInput, book_bookUncheckedCreateInput>
  }

  /**
   * book_book createMany
   */
  export type book_bookCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many book_books.
     */
    data: book_bookCreateManyInput | book_bookCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * book_book update
   */
  export type book_bookUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the book_book
     */
    select?: book_bookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the book_book
     */
    omit?: book_bookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: book_bookInclude<ExtArgs> | null
    /**
     * The data needed to update a book_book.
     */
    data: XOR<book_bookUpdateInput, book_bookUncheckedUpdateInput>
    /**
     * Choose, which book_book to update.
     */
    where: book_bookWhereUniqueInput
  }

  /**
   * book_book updateMany
   */
  export type book_bookUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update book_books.
     */
    data: XOR<book_bookUpdateManyMutationInput, book_bookUncheckedUpdateManyInput>
    /**
     * Filter which book_books to update
     */
    where?: book_bookWhereInput
    /**
     * Limit how many book_books to update.
     */
    limit?: number
  }

  /**
   * book_book upsert
   */
  export type book_bookUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the book_book
     */
    select?: book_bookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the book_book
     */
    omit?: book_bookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: book_bookInclude<ExtArgs> | null
    /**
     * The filter to search for the book_book to update in case it exists.
     */
    where: book_bookWhereUniqueInput
    /**
     * In case the book_book found by the `where` argument doesn't exist, create a new book_book with this data.
     */
    create: XOR<book_bookCreateInput, book_bookUncheckedCreateInput>
    /**
     * In case the book_book was found with the provided `where` argument, update it with this data.
     */
    update: XOR<book_bookUpdateInput, book_bookUncheckedUpdateInput>
  }

  /**
   * book_book delete
   */
  export type book_bookDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the book_book
     */
    select?: book_bookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the book_book
     */
    omit?: book_bookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: book_bookInclude<ExtArgs> | null
    /**
     * Filter which book_book to delete.
     */
    where: book_bookWhereUniqueInput
  }

  /**
   * book_book deleteMany
   */
  export type book_bookDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which book_books to delete
     */
    where?: book_bookWhereInput
    /**
     * Limit how many book_books to delete.
     */
    limit?: number
  }

  /**
   * book_book.borrowed
   */
  export type book_book$borrowedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the book_borrowed
     */
    select?: book_borrowedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the book_borrowed
     */
    omit?: book_borrowedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: book_borrowedInclude<ExtArgs> | null
    where?: book_borrowedWhereInput
    orderBy?: book_borrowedOrderByWithRelationInput | book_borrowedOrderByWithRelationInput[]
    cursor?: book_borrowedWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Book_borrowedScalarFieldEnum | Book_borrowedScalarFieldEnum[]
  }

  /**
   * book_book.book_borrow_history
   */
  export type book_book$book_borrow_historyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the book_borrow_history
     */
    select?: book_borrow_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the book_borrow_history
     */
    omit?: book_borrow_historyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: book_borrow_historyInclude<ExtArgs> | null
    where?: book_borrow_historyWhereInput
    orderBy?: book_borrow_historyOrderByWithRelationInput | book_borrow_historyOrderByWithRelationInput[]
    cursor?: book_borrow_historyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Book_borrow_historyScalarFieldEnum | Book_borrow_historyScalarFieldEnum[]
  }

  /**
   * book_book.book_rating
   */
  export type book_book$book_ratingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the book_rating
     */
    select?: book_ratingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the book_rating
     */
    omit?: book_ratingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: book_ratingInclude<ExtArgs> | null
    where?: book_ratingWhereInput
    orderBy?: book_ratingOrderByWithRelationInput | book_ratingOrderByWithRelationInput[]
    cursor?: book_ratingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Book_ratingScalarFieldEnum | Book_ratingScalarFieldEnum[]
  }

  /**
   * book_book without action
   */
  export type book_bookDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the book_book
     */
    select?: book_bookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the book_book
     */
    omit?: book_bookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: book_bookInclude<ExtArgs> | null
  }


  /**
   * Model book_category
   */

  export type AggregateBook_category = {
    _count: Book_categoryCountAggregateOutputType | null
    _min: Book_categoryMinAggregateOutputType | null
    _max: Book_categoryMaxAggregateOutputType | null
  }

  export type Book_categoryMinAggregateOutputType = {
    id: string | null
    createAt: Date | null
    updateAt: Date | null
    categoryName: string | null
  }

  export type Book_categoryMaxAggregateOutputType = {
    id: string | null
    createAt: Date | null
    updateAt: Date | null
    categoryName: string | null
  }

  export type Book_categoryCountAggregateOutputType = {
    id: number
    createAt: number
    updateAt: number
    categoryName: number
    _all: number
  }


  export type Book_categoryMinAggregateInputType = {
    id?: true
    createAt?: true
    updateAt?: true
    categoryName?: true
  }

  export type Book_categoryMaxAggregateInputType = {
    id?: true
    createAt?: true
    updateAt?: true
    categoryName?: true
  }

  export type Book_categoryCountAggregateInputType = {
    id?: true
    createAt?: true
    updateAt?: true
    categoryName?: true
    _all?: true
  }

  export type Book_categoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which book_category to aggregate.
     */
    where?: book_categoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of book_categories to fetch.
     */
    orderBy?: book_categoryOrderByWithRelationInput | book_categoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: book_categoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` book_categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` book_categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned book_categories
    **/
    _count?: true | Book_categoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Book_categoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Book_categoryMaxAggregateInputType
  }

  export type GetBook_categoryAggregateType<T extends Book_categoryAggregateArgs> = {
        [P in keyof T & keyof AggregateBook_category]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBook_category[P]>
      : GetScalarType<T[P], AggregateBook_category[P]>
  }




  export type book_categoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: book_categoryWhereInput
    orderBy?: book_categoryOrderByWithAggregationInput | book_categoryOrderByWithAggregationInput[]
    by: Book_categoryScalarFieldEnum[] | Book_categoryScalarFieldEnum
    having?: book_categoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Book_categoryCountAggregateInputType | true
    _min?: Book_categoryMinAggregateInputType
    _max?: Book_categoryMaxAggregateInputType
  }

  export type Book_categoryGroupByOutputType = {
    id: string
    createAt: Date
    updateAt: Date
    categoryName: string
    _count: Book_categoryCountAggregateOutputType | null
    _min: Book_categoryMinAggregateOutputType | null
    _max: Book_categoryMaxAggregateOutputType | null
  }

  type GetBook_categoryGroupByPayload<T extends book_categoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Book_categoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Book_categoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Book_categoryGroupByOutputType[P]>
            : GetScalarType<T[P], Book_categoryGroupByOutputType[P]>
        }
      >
    >


  export type book_categorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createAt?: boolean
    updateAt?: boolean
    categoryName?: boolean
    books?: boolean | book_category$booksArgs<ExtArgs>
    _count?: boolean | Book_categoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["book_category"]>



  export type book_categorySelectScalar = {
    id?: boolean
    createAt?: boolean
    updateAt?: boolean
    categoryName?: boolean
  }

  export type book_categoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createAt" | "updateAt" | "categoryName", ExtArgs["result"]["book_category"]>
  export type book_categoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    books?: boolean | book_category$booksArgs<ExtArgs>
    _count?: boolean | Book_categoryCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $book_categoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "book_category"
    objects: {
      books: Prisma.$book_bookPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createAt: Date
      updateAt: Date
      categoryName: string
    }, ExtArgs["result"]["book_category"]>
    composites: {}
  }

  type book_categoryGetPayload<S extends boolean | null | undefined | book_categoryDefaultArgs> = $Result.GetResult<Prisma.$book_categoryPayload, S>

  type book_categoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<book_categoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Book_categoryCountAggregateInputType | true
    }

  export interface book_categoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['book_category'], meta: { name: 'book_category' } }
    /**
     * Find zero or one Book_category that matches the filter.
     * @param {book_categoryFindUniqueArgs} args - Arguments to find a Book_category
     * @example
     * // Get one Book_category
     * const book_category = await prisma.book_category.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends book_categoryFindUniqueArgs>(args: SelectSubset<T, book_categoryFindUniqueArgs<ExtArgs>>): Prisma__book_categoryClient<$Result.GetResult<Prisma.$book_categoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Book_category that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {book_categoryFindUniqueOrThrowArgs} args - Arguments to find a Book_category
     * @example
     * // Get one Book_category
     * const book_category = await prisma.book_category.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends book_categoryFindUniqueOrThrowArgs>(args: SelectSubset<T, book_categoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__book_categoryClient<$Result.GetResult<Prisma.$book_categoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Book_category that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {book_categoryFindFirstArgs} args - Arguments to find a Book_category
     * @example
     * // Get one Book_category
     * const book_category = await prisma.book_category.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends book_categoryFindFirstArgs>(args?: SelectSubset<T, book_categoryFindFirstArgs<ExtArgs>>): Prisma__book_categoryClient<$Result.GetResult<Prisma.$book_categoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Book_category that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {book_categoryFindFirstOrThrowArgs} args - Arguments to find a Book_category
     * @example
     * // Get one Book_category
     * const book_category = await prisma.book_category.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends book_categoryFindFirstOrThrowArgs>(args?: SelectSubset<T, book_categoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__book_categoryClient<$Result.GetResult<Prisma.$book_categoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Book_categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {book_categoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Book_categories
     * const book_categories = await prisma.book_category.findMany()
     * 
     * // Get first 10 Book_categories
     * const book_categories = await prisma.book_category.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const book_categoryWithIdOnly = await prisma.book_category.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends book_categoryFindManyArgs>(args?: SelectSubset<T, book_categoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$book_categoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Book_category.
     * @param {book_categoryCreateArgs} args - Arguments to create a Book_category.
     * @example
     * // Create one Book_category
     * const Book_category = await prisma.book_category.create({
     *   data: {
     *     // ... data to create a Book_category
     *   }
     * })
     * 
     */
    create<T extends book_categoryCreateArgs>(args: SelectSubset<T, book_categoryCreateArgs<ExtArgs>>): Prisma__book_categoryClient<$Result.GetResult<Prisma.$book_categoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Book_categories.
     * @param {book_categoryCreateManyArgs} args - Arguments to create many Book_categories.
     * @example
     * // Create many Book_categories
     * const book_category = await prisma.book_category.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends book_categoryCreateManyArgs>(args?: SelectSubset<T, book_categoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Book_category.
     * @param {book_categoryDeleteArgs} args - Arguments to delete one Book_category.
     * @example
     * // Delete one Book_category
     * const Book_category = await prisma.book_category.delete({
     *   where: {
     *     // ... filter to delete one Book_category
     *   }
     * })
     * 
     */
    delete<T extends book_categoryDeleteArgs>(args: SelectSubset<T, book_categoryDeleteArgs<ExtArgs>>): Prisma__book_categoryClient<$Result.GetResult<Prisma.$book_categoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Book_category.
     * @param {book_categoryUpdateArgs} args - Arguments to update one Book_category.
     * @example
     * // Update one Book_category
     * const book_category = await prisma.book_category.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends book_categoryUpdateArgs>(args: SelectSubset<T, book_categoryUpdateArgs<ExtArgs>>): Prisma__book_categoryClient<$Result.GetResult<Prisma.$book_categoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Book_categories.
     * @param {book_categoryDeleteManyArgs} args - Arguments to filter Book_categories to delete.
     * @example
     * // Delete a few Book_categories
     * const { count } = await prisma.book_category.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends book_categoryDeleteManyArgs>(args?: SelectSubset<T, book_categoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Book_categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {book_categoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Book_categories
     * const book_category = await prisma.book_category.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends book_categoryUpdateManyArgs>(args: SelectSubset<T, book_categoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Book_category.
     * @param {book_categoryUpsertArgs} args - Arguments to update or create a Book_category.
     * @example
     * // Update or create a Book_category
     * const book_category = await prisma.book_category.upsert({
     *   create: {
     *     // ... data to create a Book_category
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Book_category we want to update
     *   }
     * })
     */
    upsert<T extends book_categoryUpsertArgs>(args: SelectSubset<T, book_categoryUpsertArgs<ExtArgs>>): Prisma__book_categoryClient<$Result.GetResult<Prisma.$book_categoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Book_categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {book_categoryCountArgs} args - Arguments to filter Book_categories to count.
     * @example
     * // Count the number of Book_categories
     * const count = await prisma.book_category.count({
     *   where: {
     *     // ... the filter for the Book_categories we want to count
     *   }
     * })
    **/
    count<T extends book_categoryCountArgs>(
      args?: Subset<T, book_categoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Book_categoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Book_category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Book_categoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Book_categoryAggregateArgs>(args: Subset<T, Book_categoryAggregateArgs>): Prisma.PrismaPromise<GetBook_categoryAggregateType<T>>

    /**
     * Group by Book_category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {book_categoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends book_categoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: book_categoryGroupByArgs['orderBy'] }
        : { orderBy?: book_categoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, book_categoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBook_categoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the book_category model
   */
  readonly fields: book_categoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for book_category.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__book_categoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    books<T extends book_category$booksArgs<ExtArgs> = {}>(args?: Subset<T, book_category$booksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$book_bookPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the book_category model
   */
  interface book_categoryFieldRefs {
    readonly id: FieldRef<"book_category", 'String'>
    readonly createAt: FieldRef<"book_category", 'DateTime'>
    readonly updateAt: FieldRef<"book_category", 'DateTime'>
    readonly categoryName: FieldRef<"book_category", 'String'>
  }
    

  // Custom InputTypes
  /**
   * book_category findUnique
   */
  export type book_categoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the book_category
     */
    select?: book_categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the book_category
     */
    omit?: book_categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: book_categoryInclude<ExtArgs> | null
    /**
     * Filter, which book_category to fetch.
     */
    where: book_categoryWhereUniqueInput
  }

  /**
   * book_category findUniqueOrThrow
   */
  export type book_categoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the book_category
     */
    select?: book_categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the book_category
     */
    omit?: book_categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: book_categoryInclude<ExtArgs> | null
    /**
     * Filter, which book_category to fetch.
     */
    where: book_categoryWhereUniqueInput
  }

  /**
   * book_category findFirst
   */
  export type book_categoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the book_category
     */
    select?: book_categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the book_category
     */
    omit?: book_categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: book_categoryInclude<ExtArgs> | null
    /**
     * Filter, which book_category to fetch.
     */
    where?: book_categoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of book_categories to fetch.
     */
    orderBy?: book_categoryOrderByWithRelationInput | book_categoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for book_categories.
     */
    cursor?: book_categoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` book_categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` book_categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of book_categories.
     */
    distinct?: Book_categoryScalarFieldEnum | Book_categoryScalarFieldEnum[]
  }

  /**
   * book_category findFirstOrThrow
   */
  export type book_categoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the book_category
     */
    select?: book_categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the book_category
     */
    omit?: book_categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: book_categoryInclude<ExtArgs> | null
    /**
     * Filter, which book_category to fetch.
     */
    where?: book_categoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of book_categories to fetch.
     */
    orderBy?: book_categoryOrderByWithRelationInput | book_categoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for book_categories.
     */
    cursor?: book_categoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` book_categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` book_categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of book_categories.
     */
    distinct?: Book_categoryScalarFieldEnum | Book_categoryScalarFieldEnum[]
  }

  /**
   * book_category findMany
   */
  export type book_categoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the book_category
     */
    select?: book_categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the book_category
     */
    omit?: book_categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: book_categoryInclude<ExtArgs> | null
    /**
     * Filter, which book_categories to fetch.
     */
    where?: book_categoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of book_categories to fetch.
     */
    orderBy?: book_categoryOrderByWithRelationInput | book_categoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing book_categories.
     */
    cursor?: book_categoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` book_categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` book_categories.
     */
    skip?: number
    distinct?: Book_categoryScalarFieldEnum | Book_categoryScalarFieldEnum[]
  }

  /**
   * book_category create
   */
  export type book_categoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the book_category
     */
    select?: book_categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the book_category
     */
    omit?: book_categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: book_categoryInclude<ExtArgs> | null
    /**
     * The data needed to create a book_category.
     */
    data: XOR<book_categoryCreateInput, book_categoryUncheckedCreateInput>
  }

  /**
   * book_category createMany
   */
  export type book_categoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many book_categories.
     */
    data: book_categoryCreateManyInput | book_categoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * book_category update
   */
  export type book_categoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the book_category
     */
    select?: book_categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the book_category
     */
    omit?: book_categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: book_categoryInclude<ExtArgs> | null
    /**
     * The data needed to update a book_category.
     */
    data: XOR<book_categoryUpdateInput, book_categoryUncheckedUpdateInput>
    /**
     * Choose, which book_category to update.
     */
    where: book_categoryWhereUniqueInput
  }

  /**
   * book_category updateMany
   */
  export type book_categoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update book_categories.
     */
    data: XOR<book_categoryUpdateManyMutationInput, book_categoryUncheckedUpdateManyInput>
    /**
     * Filter which book_categories to update
     */
    where?: book_categoryWhereInput
    /**
     * Limit how many book_categories to update.
     */
    limit?: number
  }

  /**
   * book_category upsert
   */
  export type book_categoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the book_category
     */
    select?: book_categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the book_category
     */
    omit?: book_categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: book_categoryInclude<ExtArgs> | null
    /**
     * The filter to search for the book_category to update in case it exists.
     */
    where: book_categoryWhereUniqueInput
    /**
     * In case the book_category found by the `where` argument doesn't exist, create a new book_category with this data.
     */
    create: XOR<book_categoryCreateInput, book_categoryUncheckedCreateInput>
    /**
     * In case the book_category was found with the provided `where` argument, update it with this data.
     */
    update: XOR<book_categoryUpdateInput, book_categoryUncheckedUpdateInput>
  }

  /**
   * book_category delete
   */
  export type book_categoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the book_category
     */
    select?: book_categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the book_category
     */
    omit?: book_categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: book_categoryInclude<ExtArgs> | null
    /**
     * Filter which book_category to delete.
     */
    where: book_categoryWhereUniqueInput
  }

  /**
   * book_category deleteMany
   */
  export type book_categoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which book_categories to delete
     */
    where?: book_categoryWhereInput
    /**
     * Limit how many book_categories to delete.
     */
    limit?: number
  }

  /**
   * book_category.books
   */
  export type book_category$booksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the book_book
     */
    select?: book_bookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the book_book
     */
    omit?: book_bookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: book_bookInclude<ExtArgs> | null
    where?: book_bookWhereInput
    orderBy?: book_bookOrderByWithRelationInput | book_bookOrderByWithRelationInput[]
    cursor?: book_bookWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Book_bookScalarFieldEnum | Book_bookScalarFieldEnum[]
  }

  /**
   * book_category without action
   */
  export type book_categoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the book_category
     */
    select?: book_categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the book_category
     */
    omit?: book_categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: book_categoryInclude<ExtArgs> | null
  }


  /**
   * Model book_borrowed
   */

  export type AggregateBook_borrowed = {
    _count: Book_borrowedCountAggregateOutputType | null
    _min: Book_borrowedMinAggregateOutputType | null
    _max: Book_borrowedMaxAggregateOutputType | null
  }

  export type Book_borrowedMinAggregateOutputType = {
    id: string | null
    borrowDate: Date | null
    returnDate: Date | null
    dueDate: Date | null
    userId: string | null
    bookId: string | null
    returned: boolean | null
  }

  export type Book_borrowedMaxAggregateOutputType = {
    id: string | null
    borrowDate: Date | null
    returnDate: Date | null
    dueDate: Date | null
    userId: string | null
    bookId: string | null
    returned: boolean | null
  }

  export type Book_borrowedCountAggregateOutputType = {
    id: number
    borrowDate: number
    returnDate: number
    dueDate: number
    userId: number
    bookId: number
    returned: number
    _all: number
  }


  export type Book_borrowedMinAggregateInputType = {
    id?: true
    borrowDate?: true
    returnDate?: true
    dueDate?: true
    userId?: true
    bookId?: true
    returned?: true
  }

  export type Book_borrowedMaxAggregateInputType = {
    id?: true
    borrowDate?: true
    returnDate?: true
    dueDate?: true
    userId?: true
    bookId?: true
    returned?: true
  }

  export type Book_borrowedCountAggregateInputType = {
    id?: true
    borrowDate?: true
    returnDate?: true
    dueDate?: true
    userId?: true
    bookId?: true
    returned?: true
    _all?: true
  }

  export type Book_borrowedAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which book_borrowed to aggregate.
     */
    where?: book_borrowedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of book_borroweds to fetch.
     */
    orderBy?: book_borrowedOrderByWithRelationInput | book_borrowedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: book_borrowedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` book_borroweds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` book_borroweds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned book_borroweds
    **/
    _count?: true | Book_borrowedCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Book_borrowedMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Book_borrowedMaxAggregateInputType
  }

  export type GetBook_borrowedAggregateType<T extends Book_borrowedAggregateArgs> = {
        [P in keyof T & keyof AggregateBook_borrowed]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBook_borrowed[P]>
      : GetScalarType<T[P], AggregateBook_borrowed[P]>
  }




  export type book_borrowedGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: book_borrowedWhereInput
    orderBy?: book_borrowedOrderByWithAggregationInput | book_borrowedOrderByWithAggregationInput[]
    by: Book_borrowedScalarFieldEnum[] | Book_borrowedScalarFieldEnum
    having?: book_borrowedScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Book_borrowedCountAggregateInputType | true
    _min?: Book_borrowedMinAggregateInputType
    _max?: Book_borrowedMaxAggregateInputType
  }

  export type Book_borrowedGroupByOutputType = {
    id: string
    borrowDate: Date
    returnDate: Date | null
    dueDate: Date
    userId: string
    bookId: string
    returned: boolean
    _count: Book_borrowedCountAggregateOutputType | null
    _min: Book_borrowedMinAggregateOutputType | null
    _max: Book_borrowedMaxAggregateOutputType | null
  }

  type GetBook_borrowedGroupByPayload<T extends book_borrowedGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Book_borrowedGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Book_borrowedGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Book_borrowedGroupByOutputType[P]>
            : GetScalarType<T[P], Book_borrowedGroupByOutputType[P]>
        }
      >
    >


  export type book_borrowedSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    borrowDate?: boolean
    returnDate?: boolean
    dueDate?: boolean
    userId?: boolean
    bookId?: boolean
    returned?: boolean
    user?: boolean | book_userDefaultArgs<ExtArgs>
    book?: boolean | book_bookDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["book_borrowed"]>



  export type book_borrowedSelectScalar = {
    id?: boolean
    borrowDate?: boolean
    returnDate?: boolean
    dueDate?: boolean
    userId?: boolean
    bookId?: boolean
    returned?: boolean
  }

  export type book_borrowedOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "borrowDate" | "returnDate" | "dueDate" | "userId" | "bookId" | "returned", ExtArgs["result"]["book_borrowed"]>
  export type book_borrowedInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | book_userDefaultArgs<ExtArgs>
    book?: boolean | book_bookDefaultArgs<ExtArgs>
  }

  export type $book_borrowedPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "book_borrowed"
    objects: {
      user: Prisma.$book_userPayload<ExtArgs>
      book: Prisma.$book_bookPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      borrowDate: Date
      returnDate: Date | null
      dueDate: Date
      userId: string
      bookId: string
      returned: boolean
    }, ExtArgs["result"]["book_borrowed"]>
    composites: {}
  }

  type book_borrowedGetPayload<S extends boolean | null | undefined | book_borrowedDefaultArgs> = $Result.GetResult<Prisma.$book_borrowedPayload, S>

  type book_borrowedCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<book_borrowedFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Book_borrowedCountAggregateInputType | true
    }

  export interface book_borrowedDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['book_borrowed'], meta: { name: 'book_borrowed' } }
    /**
     * Find zero or one Book_borrowed that matches the filter.
     * @param {book_borrowedFindUniqueArgs} args - Arguments to find a Book_borrowed
     * @example
     * // Get one Book_borrowed
     * const book_borrowed = await prisma.book_borrowed.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends book_borrowedFindUniqueArgs>(args: SelectSubset<T, book_borrowedFindUniqueArgs<ExtArgs>>): Prisma__book_borrowedClient<$Result.GetResult<Prisma.$book_borrowedPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Book_borrowed that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {book_borrowedFindUniqueOrThrowArgs} args - Arguments to find a Book_borrowed
     * @example
     * // Get one Book_borrowed
     * const book_borrowed = await prisma.book_borrowed.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends book_borrowedFindUniqueOrThrowArgs>(args: SelectSubset<T, book_borrowedFindUniqueOrThrowArgs<ExtArgs>>): Prisma__book_borrowedClient<$Result.GetResult<Prisma.$book_borrowedPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Book_borrowed that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {book_borrowedFindFirstArgs} args - Arguments to find a Book_borrowed
     * @example
     * // Get one Book_borrowed
     * const book_borrowed = await prisma.book_borrowed.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends book_borrowedFindFirstArgs>(args?: SelectSubset<T, book_borrowedFindFirstArgs<ExtArgs>>): Prisma__book_borrowedClient<$Result.GetResult<Prisma.$book_borrowedPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Book_borrowed that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {book_borrowedFindFirstOrThrowArgs} args - Arguments to find a Book_borrowed
     * @example
     * // Get one Book_borrowed
     * const book_borrowed = await prisma.book_borrowed.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends book_borrowedFindFirstOrThrowArgs>(args?: SelectSubset<T, book_borrowedFindFirstOrThrowArgs<ExtArgs>>): Prisma__book_borrowedClient<$Result.GetResult<Prisma.$book_borrowedPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Book_borroweds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {book_borrowedFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Book_borroweds
     * const book_borroweds = await prisma.book_borrowed.findMany()
     * 
     * // Get first 10 Book_borroweds
     * const book_borroweds = await prisma.book_borrowed.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const book_borrowedWithIdOnly = await prisma.book_borrowed.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends book_borrowedFindManyArgs>(args?: SelectSubset<T, book_borrowedFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$book_borrowedPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Book_borrowed.
     * @param {book_borrowedCreateArgs} args - Arguments to create a Book_borrowed.
     * @example
     * // Create one Book_borrowed
     * const Book_borrowed = await prisma.book_borrowed.create({
     *   data: {
     *     // ... data to create a Book_borrowed
     *   }
     * })
     * 
     */
    create<T extends book_borrowedCreateArgs>(args: SelectSubset<T, book_borrowedCreateArgs<ExtArgs>>): Prisma__book_borrowedClient<$Result.GetResult<Prisma.$book_borrowedPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Book_borroweds.
     * @param {book_borrowedCreateManyArgs} args - Arguments to create many Book_borroweds.
     * @example
     * // Create many Book_borroweds
     * const book_borrowed = await prisma.book_borrowed.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends book_borrowedCreateManyArgs>(args?: SelectSubset<T, book_borrowedCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Book_borrowed.
     * @param {book_borrowedDeleteArgs} args - Arguments to delete one Book_borrowed.
     * @example
     * // Delete one Book_borrowed
     * const Book_borrowed = await prisma.book_borrowed.delete({
     *   where: {
     *     // ... filter to delete one Book_borrowed
     *   }
     * })
     * 
     */
    delete<T extends book_borrowedDeleteArgs>(args: SelectSubset<T, book_borrowedDeleteArgs<ExtArgs>>): Prisma__book_borrowedClient<$Result.GetResult<Prisma.$book_borrowedPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Book_borrowed.
     * @param {book_borrowedUpdateArgs} args - Arguments to update one Book_borrowed.
     * @example
     * // Update one Book_borrowed
     * const book_borrowed = await prisma.book_borrowed.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends book_borrowedUpdateArgs>(args: SelectSubset<T, book_borrowedUpdateArgs<ExtArgs>>): Prisma__book_borrowedClient<$Result.GetResult<Prisma.$book_borrowedPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Book_borroweds.
     * @param {book_borrowedDeleteManyArgs} args - Arguments to filter Book_borroweds to delete.
     * @example
     * // Delete a few Book_borroweds
     * const { count } = await prisma.book_borrowed.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends book_borrowedDeleteManyArgs>(args?: SelectSubset<T, book_borrowedDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Book_borroweds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {book_borrowedUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Book_borroweds
     * const book_borrowed = await prisma.book_borrowed.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends book_borrowedUpdateManyArgs>(args: SelectSubset<T, book_borrowedUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Book_borrowed.
     * @param {book_borrowedUpsertArgs} args - Arguments to update or create a Book_borrowed.
     * @example
     * // Update or create a Book_borrowed
     * const book_borrowed = await prisma.book_borrowed.upsert({
     *   create: {
     *     // ... data to create a Book_borrowed
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Book_borrowed we want to update
     *   }
     * })
     */
    upsert<T extends book_borrowedUpsertArgs>(args: SelectSubset<T, book_borrowedUpsertArgs<ExtArgs>>): Prisma__book_borrowedClient<$Result.GetResult<Prisma.$book_borrowedPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Book_borroweds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {book_borrowedCountArgs} args - Arguments to filter Book_borroweds to count.
     * @example
     * // Count the number of Book_borroweds
     * const count = await prisma.book_borrowed.count({
     *   where: {
     *     // ... the filter for the Book_borroweds we want to count
     *   }
     * })
    **/
    count<T extends book_borrowedCountArgs>(
      args?: Subset<T, book_borrowedCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Book_borrowedCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Book_borrowed.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Book_borrowedAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Book_borrowedAggregateArgs>(args: Subset<T, Book_borrowedAggregateArgs>): Prisma.PrismaPromise<GetBook_borrowedAggregateType<T>>

    /**
     * Group by Book_borrowed.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {book_borrowedGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends book_borrowedGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: book_borrowedGroupByArgs['orderBy'] }
        : { orderBy?: book_borrowedGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, book_borrowedGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBook_borrowedGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the book_borrowed model
   */
  readonly fields: book_borrowedFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for book_borrowed.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__book_borrowedClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends book_userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, book_userDefaultArgs<ExtArgs>>): Prisma__book_userClient<$Result.GetResult<Prisma.$book_userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    book<T extends book_bookDefaultArgs<ExtArgs> = {}>(args?: Subset<T, book_bookDefaultArgs<ExtArgs>>): Prisma__book_bookClient<$Result.GetResult<Prisma.$book_bookPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the book_borrowed model
   */
  interface book_borrowedFieldRefs {
    readonly id: FieldRef<"book_borrowed", 'String'>
    readonly borrowDate: FieldRef<"book_borrowed", 'DateTime'>
    readonly returnDate: FieldRef<"book_borrowed", 'DateTime'>
    readonly dueDate: FieldRef<"book_borrowed", 'DateTime'>
    readonly userId: FieldRef<"book_borrowed", 'String'>
    readonly bookId: FieldRef<"book_borrowed", 'String'>
    readonly returned: FieldRef<"book_borrowed", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * book_borrowed findUnique
   */
  export type book_borrowedFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the book_borrowed
     */
    select?: book_borrowedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the book_borrowed
     */
    omit?: book_borrowedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: book_borrowedInclude<ExtArgs> | null
    /**
     * Filter, which book_borrowed to fetch.
     */
    where: book_borrowedWhereUniqueInput
  }

  /**
   * book_borrowed findUniqueOrThrow
   */
  export type book_borrowedFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the book_borrowed
     */
    select?: book_borrowedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the book_borrowed
     */
    omit?: book_borrowedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: book_borrowedInclude<ExtArgs> | null
    /**
     * Filter, which book_borrowed to fetch.
     */
    where: book_borrowedWhereUniqueInput
  }

  /**
   * book_borrowed findFirst
   */
  export type book_borrowedFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the book_borrowed
     */
    select?: book_borrowedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the book_borrowed
     */
    omit?: book_borrowedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: book_borrowedInclude<ExtArgs> | null
    /**
     * Filter, which book_borrowed to fetch.
     */
    where?: book_borrowedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of book_borroweds to fetch.
     */
    orderBy?: book_borrowedOrderByWithRelationInput | book_borrowedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for book_borroweds.
     */
    cursor?: book_borrowedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` book_borroweds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` book_borroweds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of book_borroweds.
     */
    distinct?: Book_borrowedScalarFieldEnum | Book_borrowedScalarFieldEnum[]
  }

  /**
   * book_borrowed findFirstOrThrow
   */
  export type book_borrowedFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the book_borrowed
     */
    select?: book_borrowedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the book_borrowed
     */
    omit?: book_borrowedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: book_borrowedInclude<ExtArgs> | null
    /**
     * Filter, which book_borrowed to fetch.
     */
    where?: book_borrowedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of book_borroweds to fetch.
     */
    orderBy?: book_borrowedOrderByWithRelationInput | book_borrowedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for book_borroweds.
     */
    cursor?: book_borrowedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` book_borroweds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` book_borroweds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of book_borroweds.
     */
    distinct?: Book_borrowedScalarFieldEnum | Book_borrowedScalarFieldEnum[]
  }

  /**
   * book_borrowed findMany
   */
  export type book_borrowedFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the book_borrowed
     */
    select?: book_borrowedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the book_borrowed
     */
    omit?: book_borrowedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: book_borrowedInclude<ExtArgs> | null
    /**
     * Filter, which book_borroweds to fetch.
     */
    where?: book_borrowedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of book_borroweds to fetch.
     */
    orderBy?: book_borrowedOrderByWithRelationInput | book_borrowedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing book_borroweds.
     */
    cursor?: book_borrowedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` book_borroweds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` book_borroweds.
     */
    skip?: number
    distinct?: Book_borrowedScalarFieldEnum | Book_borrowedScalarFieldEnum[]
  }

  /**
   * book_borrowed create
   */
  export type book_borrowedCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the book_borrowed
     */
    select?: book_borrowedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the book_borrowed
     */
    omit?: book_borrowedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: book_borrowedInclude<ExtArgs> | null
    /**
     * The data needed to create a book_borrowed.
     */
    data: XOR<book_borrowedCreateInput, book_borrowedUncheckedCreateInput>
  }

  /**
   * book_borrowed createMany
   */
  export type book_borrowedCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many book_borroweds.
     */
    data: book_borrowedCreateManyInput | book_borrowedCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * book_borrowed update
   */
  export type book_borrowedUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the book_borrowed
     */
    select?: book_borrowedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the book_borrowed
     */
    omit?: book_borrowedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: book_borrowedInclude<ExtArgs> | null
    /**
     * The data needed to update a book_borrowed.
     */
    data: XOR<book_borrowedUpdateInput, book_borrowedUncheckedUpdateInput>
    /**
     * Choose, which book_borrowed to update.
     */
    where: book_borrowedWhereUniqueInput
  }

  /**
   * book_borrowed updateMany
   */
  export type book_borrowedUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update book_borroweds.
     */
    data: XOR<book_borrowedUpdateManyMutationInput, book_borrowedUncheckedUpdateManyInput>
    /**
     * Filter which book_borroweds to update
     */
    where?: book_borrowedWhereInput
    /**
     * Limit how many book_borroweds to update.
     */
    limit?: number
  }

  /**
   * book_borrowed upsert
   */
  export type book_borrowedUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the book_borrowed
     */
    select?: book_borrowedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the book_borrowed
     */
    omit?: book_borrowedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: book_borrowedInclude<ExtArgs> | null
    /**
     * The filter to search for the book_borrowed to update in case it exists.
     */
    where: book_borrowedWhereUniqueInput
    /**
     * In case the book_borrowed found by the `where` argument doesn't exist, create a new book_borrowed with this data.
     */
    create: XOR<book_borrowedCreateInput, book_borrowedUncheckedCreateInput>
    /**
     * In case the book_borrowed was found with the provided `where` argument, update it with this data.
     */
    update: XOR<book_borrowedUpdateInput, book_borrowedUncheckedUpdateInput>
  }

  /**
   * book_borrowed delete
   */
  export type book_borrowedDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the book_borrowed
     */
    select?: book_borrowedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the book_borrowed
     */
    omit?: book_borrowedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: book_borrowedInclude<ExtArgs> | null
    /**
     * Filter which book_borrowed to delete.
     */
    where: book_borrowedWhereUniqueInput
  }

  /**
   * book_borrowed deleteMany
   */
  export type book_borrowedDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which book_borroweds to delete
     */
    where?: book_borrowedWhereInput
    /**
     * Limit how many book_borroweds to delete.
     */
    limit?: number
  }

  /**
   * book_borrowed without action
   */
  export type book_borrowedDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the book_borrowed
     */
    select?: book_borrowedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the book_borrowed
     */
    omit?: book_borrowedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: book_borrowedInclude<ExtArgs> | null
  }


  /**
   * Model book_borrow_history
   */

  export type AggregateBook_borrow_history = {
    _count: Book_borrow_historyCountAggregateOutputType | null
    _min: Book_borrow_historyMinAggregateOutputType | null
    _max: Book_borrow_historyMaxAggregateOutputType | null
  }

  export type Book_borrow_historyMinAggregateOutputType = {
    id: string | null
    borrowDate: Date | null
    returnDate: Date | null
    userId: string | null
    bookId: string | null
    returned: boolean | null
  }

  export type Book_borrow_historyMaxAggregateOutputType = {
    id: string | null
    borrowDate: Date | null
    returnDate: Date | null
    userId: string | null
    bookId: string | null
    returned: boolean | null
  }

  export type Book_borrow_historyCountAggregateOutputType = {
    id: number
    borrowDate: number
    returnDate: number
    userId: number
    bookId: number
    returned: number
    _all: number
  }


  export type Book_borrow_historyMinAggregateInputType = {
    id?: true
    borrowDate?: true
    returnDate?: true
    userId?: true
    bookId?: true
    returned?: true
  }

  export type Book_borrow_historyMaxAggregateInputType = {
    id?: true
    borrowDate?: true
    returnDate?: true
    userId?: true
    bookId?: true
    returned?: true
  }

  export type Book_borrow_historyCountAggregateInputType = {
    id?: true
    borrowDate?: true
    returnDate?: true
    userId?: true
    bookId?: true
    returned?: true
    _all?: true
  }

  export type Book_borrow_historyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which book_borrow_history to aggregate.
     */
    where?: book_borrow_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of book_borrow_histories to fetch.
     */
    orderBy?: book_borrow_historyOrderByWithRelationInput | book_borrow_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: book_borrow_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` book_borrow_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` book_borrow_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned book_borrow_histories
    **/
    _count?: true | Book_borrow_historyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Book_borrow_historyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Book_borrow_historyMaxAggregateInputType
  }

  export type GetBook_borrow_historyAggregateType<T extends Book_borrow_historyAggregateArgs> = {
        [P in keyof T & keyof AggregateBook_borrow_history]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBook_borrow_history[P]>
      : GetScalarType<T[P], AggregateBook_borrow_history[P]>
  }




  export type book_borrow_historyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: book_borrow_historyWhereInput
    orderBy?: book_borrow_historyOrderByWithAggregationInput | book_borrow_historyOrderByWithAggregationInput[]
    by: Book_borrow_historyScalarFieldEnum[] | Book_borrow_historyScalarFieldEnum
    having?: book_borrow_historyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Book_borrow_historyCountAggregateInputType | true
    _min?: Book_borrow_historyMinAggregateInputType
    _max?: Book_borrow_historyMaxAggregateInputType
  }

  export type Book_borrow_historyGroupByOutputType = {
    id: string
    borrowDate: Date
    returnDate: Date | null
    userId: string
    bookId: string
    returned: boolean
    _count: Book_borrow_historyCountAggregateOutputType | null
    _min: Book_borrow_historyMinAggregateOutputType | null
    _max: Book_borrow_historyMaxAggregateOutputType | null
  }

  type GetBook_borrow_historyGroupByPayload<T extends book_borrow_historyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Book_borrow_historyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Book_borrow_historyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Book_borrow_historyGroupByOutputType[P]>
            : GetScalarType<T[P], Book_borrow_historyGroupByOutputType[P]>
        }
      >
    >


  export type book_borrow_historySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    borrowDate?: boolean
    returnDate?: boolean
    userId?: boolean
    bookId?: boolean
    returned?: boolean
    user?: boolean | book_userDefaultArgs<ExtArgs>
    book?: boolean | book_bookDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["book_borrow_history"]>



  export type book_borrow_historySelectScalar = {
    id?: boolean
    borrowDate?: boolean
    returnDate?: boolean
    userId?: boolean
    bookId?: boolean
    returned?: boolean
  }

  export type book_borrow_historyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "borrowDate" | "returnDate" | "userId" | "bookId" | "returned", ExtArgs["result"]["book_borrow_history"]>
  export type book_borrow_historyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | book_userDefaultArgs<ExtArgs>
    book?: boolean | book_bookDefaultArgs<ExtArgs>
  }

  export type $book_borrow_historyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "book_borrow_history"
    objects: {
      user: Prisma.$book_userPayload<ExtArgs>
      book: Prisma.$book_bookPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      borrowDate: Date
      returnDate: Date | null
      userId: string
      bookId: string
      returned: boolean
    }, ExtArgs["result"]["book_borrow_history"]>
    composites: {}
  }

  type book_borrow_historyGetPayload<S extends boolean | null | undefined | book_borrow_historyDefaultArgs> = $Result.GetResult<Prisma.$book_borrow_historyPayload, S>

  type book_borrow_historyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<book_borrow_historyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Book_borrow_historyCountAggregateInputType | true
    }

  export interface book_borrow_historyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['book_borrow_history'], meta: { name: 'book_borrow_history' } }
    /**
     * Find zero or one Book_borrow_history that matches the filter.
     * @param {book_borrow_historyFindUniqueArgs} args - Arguments to find a Book_borrow_history
     * @example
     * // Get one Book_borrow_history
     * const book_borrow_history = await prisma.book_borrow_history.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends book_borrow_historyFindUniqueArgs>(args: SelectSubset<T, book_borrow_historyFindUniqueArgs<ExtArgs>>): Prisma__book_borrow_historyClient<$Result.GetResult<Prisma.$book_borrow_historyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Book_borrow_history that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {book_borrow_historyFindUniqueOrThrowArgs} args - Arguments to find a Book_borrow_history
     * @example
     * // Get one Book_borrow_history
     * const book_borrow_history = await prisma.book_borrow_history.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends book_borrow_historyFindUniqueOrThrowArgs>(args: SelectSubset<T, book_borrow_historyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__book_borrow_historyClient<$Result.GetResult<Prisma.$book_borrow_historyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Book_borrow_history that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {book_borrow_historyFindFirstArgs} args - Arguments to find a Book_borrow_history
     * @example
     * // Get one Book_borrow_history
     * const book_borrow_history = await prisma.book_borrow_history.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends book_borrow_historyFindFirstArgs>(args?: SelectSubset<T, book_borrow_historyFindFirstArgs<ExtArgs>>): Prisma__book_borrow_historyClient<$Result.GetResult<Prisma.$book_borrow_historyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Book_borrow_history that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {book_borrow_historyFindFirstOrThrowArgs} args - Arguments to find a Book_borrow_history
     * @example
     * // Get one Book_borrow_history
     * const book_borrow_history = await prisma.book_borrow_history.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends book_borrow_historyFindFirstOrThrowArgs>(args?: SelectSubset<T, book_borrow_historyFindFirstOrThrowArgs<ExtArgs>>): Prisma__book_borrow_historyClient<$Result.GetResult<Prisma.$book_borrow_historyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Book_borrow_histories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {book_borrow_historyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Book_borrow_histories
     * const book_borrow_histories = await prisma.book_borrow_history.findMany()
     * 
     * // Get first 10 Book_borrow_histories
     * const book_borrow_histories = await prisma.book_borrow_history.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const book_borrow_historyWithIdOnly = await prisma.book_borrow_history.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends book_borrow_historyFindManyArgs>(args?: SelectSubset<T, book_borrow_historyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$book_borrow_historyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Book_borrow_history.
     * @param {book_borrow_historyCreateArgs} args - Arguments to create a Book_borrow_history.
     * @example
     * // Create one Book_borrow_history
     * const Book_borrow_history = await prisma.book_borrow_history.create({
     *   data: {
     *     // ... data to create a Book_borrow_history
     *   }
     * })
     * 
     */
    create<T extends book_borrow_historyCreateArgs>(args: SelectSubset<T, book_borrow_historyCreateArgs<ExtArgs>>): Prisma__book_borrow_historyClient<$Result.GetResult<Prisma.$book_borrow_historyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Book_borrow_histories.
     * @param {book_borrow_historyCreateManyArgs} args - Arguments to create many Book_borrow_histories.
     * @example
     * // Create many Book_borrow_histories
     * const book_borrow_history = await prisma.book_borrow_history.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends book_borrow_historyCreateManyArgs>(args?: SelectSubset<T, book_borrow_historyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Book_borrow_history.
     * @param {book_borrow_historyDeleteArgs} args - Arguments to delete one Book_borrow_history.
     * @example
     * // Delete one Book_borrow_history
     * const Book_borrow_history = await prisma.book_borrow_history.delete({
     *   where: {
     *     // ... filter to delete one Book_borrow_history
     *   }
     * })
     * 
     */
    delete<T extends book_borrow_historyDeleteArgs>(args: SelectSubset<T, book_borrow_historyDeleteArgs<ExtArgs>>): Prisma__book_borrow_historyClient<$Result.GetResult<Prisma.$book_borrow_historyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Book_borrow_history.
     * @param {book_borrow_historyUpdateArgs} args - Arguments to update one Book_borrow_history.
     * @example
     * // Update one Book_borrow_history
     * const book_borrow_history = await prisma.book_borrow_history.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends book_borrow_historyUpdateArgs>(args: SelectSubset<T, book_borrow_historyUpdateArgs<ExtArgs>>): Prisma__book_borrow_historyClient<$Result.GetResult<Prisma.$book_borrow_historyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Book_borrow_histories.
     * @param {book_borrow_historyDeleteManyArgs} args - Arguments to filter Book_borrow_histories to delete.
     * @example
     * // Delete a few Book_borrow_histories
     * const { count } = await prisma.book_borrow_history.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends book_borrow_historyDeleteManyArgs>(args?: SelectSubset<T, book_borrow_historyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Book_borrow_histories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {book_borrow_historyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Book_borrow_histories
     * const book_borrow_history = await prisma.book_borrow_history.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends book_borrow_historyUpdateManyArgs>(args: SelectSubset<T, book_borrow_historyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Book_borrow_history.
     * @param {book_borrow_historyUpsertArgs} args - Arguments to update or create a Book_borrow_history.
     * @example
     * // Update or create a Book_borrow_history
     * const book_borrow_history = await prisma.book_borrow_history.upsert({
     *   create: {
     *     // ... data to create a Book_borrow_history
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Book_borrow_history we want to update
     *   }
     * })
     */
    upsert<T extends book_borrow_historyUpsertArgs>(args: SelectSubset<T, book_borrow_historyUpsertArgs<ExtArgs>>): Prisma__book_borrow_historyClient<$Result.GetResult<Prisma.$book_borrow_historyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Book_borrow_histories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {book_borrow_historyCountArgs} args - Arguments to filter Book_borrow_histories to count.
     * @example
     * // Count the number of Book_borrow_histories
     * const count = await prisma.book_borrow_history.count({
     *   where: {
     *     // ... the filter for the Book_borrow_histories we want to count
     *   }
     * })
    **/
    count<T extends book_borrow_historyCountArgs>(
      args?: Subset<T, book_borrow_historyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Book_borrow_historyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Book_borrow_history.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Book_borrow_historyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Book_borrow_historyAggregateArgs>(args: Subset<T, Book_borrow_historyAggregateArgs>): Prisma.PrismaPromise<GetBook_borrow_historyAggregateType<T>>

    /**
     * Group by Book_borrow_history.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {book_borrow_historyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends book_borrow_historyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: book_borrow_historyGroupByArgs['orderBy'] }
        : { orderBy?: book_borrow_historyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, book_borrow_historyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBook_borrow_historyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the book_borrow_history model
   */
  readonly fields: book_borrow_historyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for book_borrow_history.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__book_borrow_historyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends book_userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, book_userDefaultArgs<ExtArgs>>): Prisma__book_userClient<$Result.GetResult<Prisma.$book_userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    book<T extends book_bookDefaultArgs<ExtArgs> = {}>(args?: Subset<T, book_bookDefaultArgs<ExtArgs>>): Prisma__book_bookClient<$Result.GetResult<Prisma.$book_bookPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the book_borrow_history model
   */
  interface book_borrow_historyFieldRefs {
    readonly id: FieldRef<"book_borrow_history", 'String'>
    readonly borrowDate: FieldRef<"book_borrow_history", 'DateTime'>
    readonly returnDate: FieldRef<"book_borrow_history", 'DateTime'>
    readonly userId: FieldRef<"book_borrow_history", 'String'>
    readonly bookId: FieldRef<"book_borrow_history", 'String'>
    readonly returned: FieldRef<"book_borrow_history", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * book_borrow_history findUnique
   */
  export type book_borrow_historyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the book_borrow_history
     */
    select?: book_borrow_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the book_borrow_history
     */
    omit?: book_borrow_historyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: book_borrow_historyInclude<ExtArgs> | null
    /**
     * Filter, which book_borrow_history to fetch.
     */
    where: book_borrow_historyWhereUniqueInput
  }

  /**
   * book_borrow_history findUniqueOrThrow
   */
  export type book_borrow_historyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the book_borrow_history
     */
    select?: book_borrow_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the book_borrow_history
     */
    omit?: book_borrow_historyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: book_borrow_historyInclude<ExtArgs> | null
    /**
     * Filter, which book_borrow_history to fetch.
     */
    where: book_borrow_historyWhereUniqueInput
  }

  /**
   * book_borrow_history findFirst
   */
  export type book_borrow_historyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the book_borrow_history
     */
    select?: book_borrow_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the book_borrow_history
     */
    omit?: book_borrow_historyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: book_borrow_historyInclude<ExtArgs> | null
    /**
     * Filter, which book_borrow_history to fetch.
     */
    where?: book_borrow_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of book_borrow_histories to fetch.
     */
    orderBy?: book_borrow_historyOrderByWithRelationInput | book_borrow_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for book_borrow_histories.
     */
    cursor?: book_borrow_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` book_borrow_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` book_borrow_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of book_borrow_histories.
     */
    distinct?: Book_borrow_historyScalarFieldEnum | Book_borrow_historyScalarFieldEnum[]
  }

  /**
   * book_borrow_history findFirstOrThrow
   */
  export type book_borrow_historyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the book_borrow_history
     */
    select?: book_borrow_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the book_borrow_history
     */
    omit?: book_borrow_historyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: book_borrow_historyInclude<ExtArgs> | null
    /**
     * Filter, which book_borrow_history to fetch.
     */
    where?: book_borrow_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of book_borrow_histories to fetch.
     */
    orderBy?: book_borrow_historyOrderByWithRelationInput | book_borrow_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for book_borrow_histories.
     */
    cursor?: book_borrow_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` book_borrow_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` book_borrow_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of book_borrow_histories.
     */
    distinct?: Book_borrow_historyScalarFieldEnum | Book_borrow_historyScalarFieldEnum[]
  }

  /**
   * book_borrow_history findMany
   */
  export type book_borrow_historyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the book_borrow_history
     */
    select?: book_borrow_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the book_borrow_history
     */
    omit?: book_borrow_historyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: book_borrow_historyInclude<ExtArgs> | null
    /**
     * Filter, which book_borrow_histories to fetch.
     */
    where?: book_borrow_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of book_borrow_histories to fetch.
     */
    orderBy?: book_borrow_historyOrderByWithRelationInput | book_borrow_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing book_borrow_histories.
     */
    cursor?: book_borrow_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` book_borrow_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` book_borrow_histories.
     */
    skip?: number
    distinct?: Book_borrow_historyScalarFieldEnum | Book_borrow_historyScalarFieldEnum[]
  }

  /**
   * book_borrow_history create
   */
  export type book_borrow_historyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the book_borrow_history
     */
    select?: book_borrow_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the book_borrow_history
     */
    omit?: book_borrow_historyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: book_borrow_historyInclude<ExtArgs> | null
    /**
     * The data needed to create a book_borrow_history.
     */
    data: XOR<book_borrow_historyCreateInput, book_borrow_historyUncheckedCreateInput>
  }

  /**
   * book_borrow_history createMany
   */
  export type book_borrow_historyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many book_borrow_histories.
     */
    data: book_borrow_historyCreateManyInput | book_borrow_historyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * book_borrow_history update
   */
  export type book_borrow_historyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the book_borrow_history
     */
    select?: book_borrow_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the book_borrow_history
     */
    omit?: book_borrow_historyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: book_borrow_historyInclude<ExtArgs> | null
    /**
     * The data needed to update a book_borrow_history.
     */
    data: XOR<book_borrow_historyUpdateInput, book_borrow_historyUncheckedUpdateInput>
    /**
     * Choose, which book_borrow_history to update.
     */
    where: book_borrow_historyWhereUniqueInput
  }

  /**
   * book_borrow_history updateMany
   */
  export type book_borrow_historyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update book_borrow_histories.
     */
    data: XOR<book_borrow_historyUpdateManyMutationInput, book_borrow_historyUncheckedUpdateManyInput>
    /**
     * Filter which book_borrow_histories to update
     */
    where?: book_borrow_historyWhereInput
    /**
     * Limit how many book_borrow_histories to update.
     */
    limit?: number
  }

  /**
   * book_borrow_history upsert
   */
  export type book_borrow_historyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the book_borrow_history
     */
    select?: book_borrow_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the book_borrow_history
     */
    omit?: book_borrow_historyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: book_borrow_historyInclude<ExtArgs> | null
    /**
     * The filter to search for the book_borrow_history to update in case it exists.
     */
    where: book_borrow_historyWhereUniqueInput
    /**
     * In case the book_borrow_history found by the `where` argument doesn't exist, create a new book_borrow_history with this data.
     */
    create: XOR<book_borrow_historyCreateInput, book_borrow_historyUncheckedCreateInput>
    /**
     * In case the book_borrow_history was found with the provided `where` argument, update it with this data.
     */
    update: XOR<book_borrow_historyUpdateInput, book_borrow_historyUncheckedUpdateInput>
  }

  /**
   * book_borrow_history delete
   */
  export type book_borrow_historyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the book_borrow_history
     */
    select?: book_borrow_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the book_borrow_history
     */
    omit?: book_borrow_historyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: book_borrow_historyInclude<ExtArgs> | null
    /**
     * Filter which book_borrow_history to delete.
     */
    where: book_borrow_historyWhereUniqueInput
  }

  /**
   * book_borrow_history deleteMany
   */
  export type book_borrow_historyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which book_borrow_histories to delete
     */
    where?: book_borrow_historyWhereInput
    /**
     * Limit how many book_borrow_histories to delete.
     */
    limit?: number
  }

  /**
   * book_borrow_history without action
   */
  export type book_borrow_historyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the book_borrow_history
     */
    select?: book_borrow_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the book_borrow_history
     */
    omit?: book_borrow_historyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: book_borrow_historyInclude<ExtArgs> | null
  }


  /**
   * Model book_rating
   */

  export type AggregateBook_rating = {
    _count: Book_ratingCountAggregateOutputType | null
    _avg: Book_ratingAvgAggregateOutputType | null
    _sum: Book_ratingSumAggregateOutputType | null
    _min: Book_ratingMinAggregateOutputType | null
    _max: Book_ratingMaxAggregateOutputType | null
  }

  export type Book_ratingAvgAggregateOutputType = {
    rating: number | null
  }

  export type Book_ratingSumAggregateOutputType = {
    rating: number | null
  }

  export type Book_ratingMinAggregateOutputType = {
    id: string | null
    createAt: Date | null
    updateAt: Date | null
    rating: number | null
    review: string | null
    userId: string | null
    bookId: string | null
  }

  export type Book_ratingMaxAggregateOutputType = {
    id: string | null
    createAt: Date | null
    updateAt: Date | null
    rating: number | null
    review: string | null
    userId: string | null
    bookId: string | null
  }

  export type Book_ratingCountAggregateOutputType = {
    id: number
    createAt: number
    updateAt: number
    rating: number
    review: number
    userId: number
    bookId: number
    _all: number
  }


  export type Book_ratingAvgAggregateInputType = {
    rating?: true
  }

  export type Book_ratingSumAggregateInputType = {
    rating?: true
  }

  export type Book_ratingMinAggregateInputType = {
    id?: true
    createAt?: true
    updateAt?: true
    rating?: true
    review?: true
    userId?: true
    bookId?: true
  }

  export type Book_ratingMaxAggregateInputType = {
    id?: true
    createAt?: true
    updateAt?: true
    rating?: true
    review?: true
    userId?: true
    bookId?: true
  }

  export type Book_ratingCountAggregateInputType = {
    id?: true
    createAt?: true
    updateAt?: true
    rating?: true
    review?: true
    userId?: true
    bookId?: true
    _all?: true
  }

  export type Book_ratingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which book_rating to aggregate.
     */
    where?: book_ratingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of book_ratings to fetch.
     */
    orderBy?: book_ratingOrderByWithRelationInput | book_ratingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: book_ratingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` book_ratings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` book_ratings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned book_ratings
    **/
    _count?: true | Book_ratingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Book_ratingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Book_ratingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Book_ratingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Book_ratingMaxAggregateInputType
  }

  export type GetBook_ratingAggregateType<T extends Book_ratingAggregateArgs> = {
        [P in keyof T & keyof AggregateBook_rating]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBook_rating[P]>
      : GetScalarType<T[P], AggregateBook_rating[P]>
  }




  export type book_ratingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: book_ratingWhereInput
    orderBy?: book_ratingOrderByWithAggregationInput | book_ratingOrderByWithAggregationInput[]
    by: Book_ratingScalarFieldEnum[] | Book_ratingScalarFieldEnum
    having?: book_ratingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Book_ratingCountAggregateInputType | true
    _avg?: Book_ratingAvgAggregateInputType
    _sum?: Book_ratingSumAggregateInputType
    _min?: Book_ratingMinAggregateInputType
    _max?: Book_ratingMaxAggregateInputType
  }

  export type Book_ratingGroupByOutputType = {
    id: string
    createAt: Date
    updateAt: Date
    rating: number
    review: string | null
    userId: string
    bookId: string
    _count: Book_ratingCountAggregateOutputType | null
    _avg: Book_ratingAvgAggregateOutputType | null
    _sum: Book_ratingSumAggregateOutputType | null
    _min: Book_ratingMinAggregateOutputType | null
    _max: Book_ratingMaxAggregateOutputType | null
  }

  type GetBook_ratingGroupByPayload<T extends book_ratingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Book_ratingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Book_ratingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Book_ratingGroupByOutputType[P]>
            : GetScalarType<T[P], Book_ratingGroupByOutputType[P]>
        }
      >
    >


  export type book_ratingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createAt?: boolean
    updateAt?: boolean
    rating?: boolean
    review?: boolean
    userId?: boolean
    bookId?: boolean
    user?: boolean | book_userDefaultArgs<ExtArgs>
    book?: boolean | book_bookDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["book_rating"]>



  export type book_ratingSelectScalar = {
    id?: boolean
    createAt?: boolean
    updateAt?: boolean
    rating?: boolean
    review?: boolean
    userId?: boolean
    bookId?: boolean
  }

  export type book_ratingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createAt" | "updateAt" | "rating" | "review" | "userId" | "bookId", ExtArgs["result"]["book_rating"]>
  export type book_ratingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | book_userDefaultArgs<ExtArgs>
    book?: boolean | book_bookDefaultArgs<ExtArgs>
  }

  export type $book_ratingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "book_rating"
    objects: {
      user: Prisma.$book_userPayload<ExtArgs>
      book: Prisma.$book_bookPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createAt: Date
      updateAt: Date
      rating: number
      review: string | null
      userId: string
      bookId: string
    }, ExtArgs["result"]["book_rating"]>
    composites: {}
  }

  type book_ratingGetPayload<S extends boolean | null | undefined | book_ratingDefaultArgs> = $Result.GetResult<Prisma.$book_ratingPayload, S>

  type book_ratingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<book_ratingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Book_ratingCountAggregateInputType | true
    }

  export interface book_ratingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['book_rating'], meta: { name: 'book_rating' } }
    /**
     * Find zero or one Book_rating that matches the filter.
     * @param {book_ratingFindUniqueArgs} args - Arguments to find a Book_rating
     * @example
     * // Get one Book_rating
     * const book_rating = await prisma.book_rating.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends book_ratingFindUniqueArgs>(args: SelectSubset<T, book_ratingFindUniqueArgs<ExtArgs>>): Prisma__book_ratingClient<$Result.GetResult<Prisma.$book_ratingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Book_rating that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {book_ratingFindUniqueOrThrowArgs} args - Arguments to find a Book_rating
     * @example
     * // Get one Book_rating
     * const book_rating = await prisma.book_rating.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends book_ratingFindUniqueOrThrowArgs>(args: SelectSubset<T, book_ratingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__book_ratingClient<$Result.GetResult<Prisma.$book_ratingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Book_rating that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {book_ratingFindFirstArgs} args - Arguments to find a Book_rating
     * @example
     * // Get one Book_rating
     * const book_rating = await prisma.book_rating.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends book_ratingFindFirstArgs>(args?: SelectSubset<T, book_ratingFindFirstArgs<ExtArgs>>): Prisma__book_ratingClient<$Result.GetResult<Prisma.$book_ratingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Book_rating that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {book_ratingFindFirstOrThrowArgs} args - Arguments to find a Book_rating
     * @example
     * // Get one Book_rating
     * const book_rating = await prisma.book_rating.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends book_ratingFindFirstOrThrowArgs>(args?: SelectSubset<T, book_ratingFindFirstOrThrowArgs<ExtArgs>>): Prisma__book_ratingClient<$Result.GetResult<Prisma.$book_ratingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Book_ratings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {book_ratingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Book_ratings
     * const book_ratings = await prisma.book_rating.findMany()
     * 
     * // Get first 10 Book_ratings
     * const book_ratings = await prisma.book_rating.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const book_ratingWithIdOnly = await prisma.book_rating.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends book_ratingFindManyArgs>(args?: SelectSubset<T, book_ratingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$book_ratingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Book_rating.
     * @param {book_ratingCreateArgs} args - Arguments to create a Book_rating.
     * @example
     * // Create one Book_rating
     * const Book_rating = await prisma.book_rating.create({
     *   data: {
     *     // ... data to create a Book_rating
     *   }
     * })
     * 
     */
    create<T extends book_ratingCreateArgs>(args: SelectSubset<T, book_ratingCreateArgs<ExtArgs>>): Prisma__book_ratingClient<$Result.GetResult<Prisma.$book_ratingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Book_ratings.
     * @param {book_ratingCreateManyArgs} args - Arguments to create many Book_ratings.
     * @example
     * // Create many Book_ratings
     * const book_rating = await prisma.book_rating.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends book_ratingCreateManyArgs>(args?: SelectSubset<T, book_ratingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Book_rating.
     * @param {book_ratingDeleteArgs} args - Arguments to delete one Book_rating.
     * @example
     * // Delete one Book_rating
     * const Book_rating = await prisma.book_rating.delete({
     *   where: {
     *     // ... filter to delete one Book_rating
     *   }
     * })
     * 
     */
    delete<T extends book_ratingDeleteArgs>(args: SelectSubset<T, book_ratingDeleteArgs<ExtArgs>>): Prisma__book_ratingClient<$Result.GetResult<Prisma.$book_ratingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Book_rating.
     * @param {book_ratingUpdateArgs} args - Arguments to update one Book_rating.
     * @example
     * // Update one Book_rating
     * const book_rating = await prisma.book_rating.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends book_ratingUpdateArgs>(args: SelectSubset<T, book_ratingUpdateArgs<ExtArgs>>): Prisma__book_ratingClient<$Result.GetResult<Prisma.$book_ratingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Book_ratings.
     * @param {book_ratingDeleteManyArgs} args - Arguments to filter Book_ratings to delete.
     * @example
     * // Delete a few Book_ratings
     * const { count } = await prisma.book_rating.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends book_ratingDeleteManyArgs>(args?: SelectSubset<T, book_ratingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Book_ratings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {book_ratingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Book_ratings
     * const book_rating = await prisma.book_rating.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends book_ratingUpdateManyArgs>(args: SelectSubset<T, book_ratingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Book_rating.
     * @param {book_ratingUpsertArgs} args - Arguments to update or create a Book_rating.
     * @example
     * // Update or create a Book_rating
     * const book_rating = await prisma.book_rating.upsert({
     *   create: {
     *     // ... data to create a Book_rating
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Book_rating we want to update
     *   }
     * })
     */
    upsert<T extends book_ratingUpsertArgs>(args: SelectSubset<T, book_ratingUpsertArgs<ExtArgs>>): Prisma__book_ratingClient<$Result.GetResult<Prisma.$book_ratingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Book_ratings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {book_ratingCountArgs} args - Arguments to filter Book_ratings to count.
     * @example
     * // Count the number of Book_ratings
     * const count = await prisma.book_rating.count({
     *   where: {
     *     // ... the filter for the Book_ratings we want to count
     *   }
     * })
    **/
    count<T extends book_ratingCountArgs>(
      args?: Subset<T, book_ratingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Book_ratingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Book_rating.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Book_ratingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Book_ratingAggregateArgs>(args: Subset<T, Book_ratingAggregateArgs>): Prisma.PrismaPromise<GetBook_ratingAggregateType<T>>

    /**
     * Group by Book_rating.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {book_ratingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends book_ratingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: book_ratingGroupByArgs['orderBy'] }
        : { orderBy?: book_ratingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, book_ratingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBook_ratingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the book_rating model
   */
  readonly fields: book_ratingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for book_rating.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__book_ratingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends book_userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, book_userDefaultArgs<ExtArgs>>): Prisma__book_userClient<$Result.GetResult<Prisma.$book_userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    book<T extends book_bookDefaultArgs<ExtArgs> = {}>(args?: Subset<T, book_bookDefaultArgs<ExtArgs>>): Prisma__book_bookClient<$Result.GetResult<Prisma.$book_bookPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the book_rating model
   */
  interface book_ratingFieldRefs {
    readonly id: FieldRef<"book_rating", 'String'>
    readonly createAt: FieldRef<"book_rating", 'DateTime'>
    readonly updateAt: FieldRef<"book_rating", 'DateTime'>
    readonly rating: FieldRef<"book_rating", 'Float'>
    readonly review: FieldRef<"book_rating", 'String'>
    readonly userId: FieldRef<"book_rating", 'String'>
    readonly bookId: FieldRef<"book_rating", 'String'>
  }
    

  // Custom InputTypes
  /**
   * book_rating findUnique
   */
  export type book_ratingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the book_rating
     */
    select?: book_ratingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the book_rating
     */
    omit?: book_ratingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: book_ratingInclude<ExtArgs> | null
    /**
     * Filter, which book_rating to fetch.
     */
    where: book_ratingWhereUniqueInput
  }

  /**
   * book_rating findUniqueOrThrow
   */
  export type book_ratingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the book_rating
     */
    select?: book_ratingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the book_rating
     */
    omit?: book_ratingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: book_ratingInclude<ExtArgs> | null
    /**
     * Filter, which book_rating to fetch.
     */
    where: book_ratingWhereUniqueInput
  }

  /**
   * book_rating findFirst
   */
  export type book_ratingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the book_rating
     */
    select?: book_ratingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the book_rating
     */
    omit?: book_ratingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: book_ratingInclude<ExtArgs> | null
    /**
     * Filter, which book_rating to fetch.
     */
    where?: book_ratingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of book_ratings to fetch.
     */
    orderBy?: book_ratingOrderByWithRelationInput | book_ratingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for book_ratings.
     */
    cursor?: book_ratingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` book_ratings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` book_ratings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of book_ratings.
     */
    distinct?: Book_ratingScalarFieldEnum | Book_ratingScalarFieldEnum[]
  }

  /**
   * book_rating findFirstOrThrow
   */
  export type book_ratingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the book_rating
     */
    select?: book_ratingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the book_rating
     */
    omit?: book_ratingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: book_ratingInclude<ExtArgs> | null
    /**
     * Filter, which book_rating to fetch.
     */
    where?: book_ratingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of book_ratings to fetch.
     */
    orderBy?: book_ratingOrderByWithRelationInput | book_ratingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for book_ratings.
     */
    cursor?: book_ratingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` book_ratings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` book_ratings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of book_ratings.
     */
    distinct?: Book_ratingScalarFieldEnum | Book_ratingScalarFieldEnum[]
  }

  /**
   * book_rating findMany
   */
  export type book_ratingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the book_rating
     */
    select?: book_ratingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the book_rating
     */
    omit?: book_ratingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: book_ratingInclude<ExtArgs> | null
    /**
     * Filter, which book_ratings to fetch.
     */
    where?: book_ratingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of book_ratings to fetch.
     */
    orderBy?: book_ratingOrderByWithRelationInput | book_ratingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing book_ratings.
     */
    cursor?: book_ratingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` book_ratings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` book_ratings.
     */
    skip?: number
    distinct?: Book_ratingScalarFieldEnum | Book_ratingScalarFieldEnum[]
  }

  /**
   * book_rating create
   */
  export type book_ratingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the book_rating
     */
    select?: book_ratingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the book_rating
     */
    omit?: book_ratingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: book_ratingInclude<ExtArgs> | null
    /**
     * The data needed to create a book_rating.
     */
    data: XOR<book_ratingCreateInput, book_ratingUncheckedCreateInput>
  }

  /**
   * book_rating createMany
   */
  export type book_ratingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many book_ratings.
     */
    data: book_ratingCreateManyInput | book_ratingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * book_rating update
   */
  export type book_ratingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the book_rating
     */
    select?: book_ratingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the book_rating
     */
    omit?: book_ratingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: book_ratingInclude<ExtArgs> | null
    /**
     * The data needed to update a book_rating.
     */
    data: XOR<book_ratingUpdateInput, book_ratingUncheckedUpdateInput>
    /**
     * Choose, which book_rating to update.
     */
    where: book_ratingWhereUniqueInput
  }

  /**
   * book_rating updateMany
   */
  export type book_ratingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update book_ratings.
     */
    data: XOR<book_ratingUpdateManyMutationInput, book_ratingUncheckedUpdateManyInput>
    /**
     * Filter which book_ratings to update
     */
    where?: book_ratingWhereInput
    /**
     * Limit how many book_ratings to update.
     */
    limit?: number
  }

  /**
   * book_rating upsert
   */
  export type book_ratingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the book_rating
     */
    select?: book_ratingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the book_rating
     */
    omit?: book_ratingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: book_ratingInclude<ExtArgs> | null
    /**
     * The filter to search for the book_rating to update in case it exists.
     */
    where: book_ratingWhereUniqueInput
    /**
     * In case the book_rating found by the `where` argument doesn't exist, create a new book_rating with this data.
     */
    create: XOR<book_ratingCreateInput, book_ratingUncheckedCreateInput>
    /**
     * In case the book_rating was found with the provided `where` argument, update it with this data.
     */
    update: XOR<book_ratingUpdateInput, book_ratingUncheckedUpdateInput>
  }

  /**
   * book_rating delete
   */
  export type book_ratingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the book_rating
     */
    select?: book_ratingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the book_rating
     */
    omit?: book_ratingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: book_ratingInclude<ExtArgs> | null
    /**
     * Filter which book_rating to delete.
     */
    where: book_ratingWhereUniqueInput
  }

  /**
   * book_rating deleteMany
   */
  export type book_ratingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which book_ratings to delete
     */
    where?: book_ratingWhereInput
    /**
     * Limit how many book_ratings to delete.
     */
    limit?: number
  }

  /**
   * book_rating without action
   */
  export type book_ratingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the book_rating
     */
    select?: book_ratingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the book_rating
     */
    omit?: book_ratingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: book_ratingInclude<ExtArgs> | null
  }


  /**
   * Model study_user
   */

  export type AggregateStudy_user = {
    _count: Study_userCountAggregateOutputType | null
    _min: Study_userMinAggregateOutputType | null
    _max: Study_userMaxAggregateOutputType | null
  }

  export type Study_userMinAggregateOutputType = {
    uid: string | null
    createAt: Date | null
    updateAt: Date | null
    name: string | null
    account: string | null
    password: string | null
    isAdmin: boolean | null
  }

  export type Study_userMaxAggregateOutputType = {
    uid: string | null
    createAt: Date | null
    updateAt: Date | null
    name: string | null
    account: string | null
    password: string | null
    isAdmin: boolean | null
  }

  export type Study_userCountAggregateOutputType = {
    uid: number
    createAt: number
    updateAt: number
    name: number
    account: number
    password: number
    isAdmin: number
    _all: number
  }


  export type Study_userMinAggregateInputType = {
    uid?: true
    createAt?: true
    updateAt?: true
    name?: true
    account?: true
    password?: true
    isAdmin?: true
  }

  export type Study_userMaxAggregateInputType = {
    uid?: true
    createAt?: true
    updateAt?: true
    name?: true
    account?: true
    password?: true
    isAdmin?: true
  }

  export type Study_userCountAggregateInputType = {
    uid?: true
    createAt?: true
    updateAt?: true
    name?: true
    account?: true
    password?: true
    isAdmin?: true
    _all?: true
  }

  export type Study_userAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which study_user to aggregate.
     */
    where?: study_userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of study_users to fetch.
     */
    orderBy?: study_userOrderByWithRelationInput | study_userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: study_userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` study_users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` study_users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned study_users
    **/
    _count?: true | Study_userCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Study_userMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Study_userMaxAggregateInputType
  }

  export type GetStudy_userAggregateType<T extends Study_userAggregateArgs> = {
        [P in keyof T & keyof AggregateStudy_user]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudy_user[P]>
      : GetScalarType<T[P], AggregateStudy_user[P]>
  }




  export type study_userGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: study_userWhereInput
    orderBy?: study_userOrderByWithAggregationInput | study_userOrderByWithAggregationInput[]
    by: Study_userScalarFieldEnum[] | Study_userScalarFieldEnum
    having?: study_userScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Study_userCountAggregateInputType | true
    _min?: Study_userMinAggregateInputType
    _max?: Study_userMaxAggregateInputType
  }

  export type Study_userGroupByOutputType = {
    uid: string
    createAt: Date
    updateAt: Date
    name: string
    account: string
    password: string
    isAdmin: boolean
    _count: Study_userCountAggregateOutputType | null
    _min: Study_userMinAggregateOutputType | null
    _max: Study_userMaxAggregateOutputType | null
  }

  type GetStudy_userGroupByPayload<T extends study_userGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Study_userGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Study_userGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Study_userGroupByOutputType[P]>
            : GetScalarType<T[P], Study_userGroupByOutputType[P]>
        }
      >
    >


  export type study_userSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    uid?: boolean
    createAt?: boolean
    updateAt?: boolean
    name?: boolean
    account?: boolean
    password?: boolean
    isAdmin?: boolean
    reservation?: boolean | study_user$reservationArgs<ExtArgs>
    message?: boolean | study_user$messageArgs<ExtArgs>
    _count?: boolean | Study_userCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["study_user"]>



  export type study_userSelectScalar = {
    uid?: boolean
    createAt?: boolean
    updateAt?: boolean
    name?: boolean
    account?: boolean
    password?: boolean
    isAdmin?: boolean
  }

  export type study_userOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"uid" | "createAt" | "updateAt" | "name" | "account" | "password" | "isAdmin", ExtArgs["result"]["study_user"]>
  export type study_userInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reservation?: boolean | study_user$reservationArgs<ExtArgs>
    message?: boolean | study_user$messageArgs<ExtArgs>
    _count?: boolean | Study_userCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $study_userPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "study_user"
    objects: {
      reservation: Prisma.$study_reservationPayload<ExtArgs>[]
      message: Prisma.$study_messagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      uid: string
      createAt: Date
      updateAt: Date
      name: string
      account: string
      password: string
      isAdmin: boolean
    }, ExtArgs["result"]["study_user"]>
    composites: {}
  }

  type study_userGetPayload<S extends boolean | null | undefined | study_userDefaultArgs> = $Result.GetResult<Prisma.$study_userPayload, S>

  type study_userCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<study_userFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Study_userCountAggregateInputType | true
    }

  export interface study_userDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['study_user'], meta: { name: 'study_user' } }
    /**
     * Find zero or one Study_user that matches the filter.
     * @param {study_userFindUniqueArgs} args - Arguments to find a Study_user
     * @example
     * // Get one Study_user
     * const study_user = await prisma.study_user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends study_userFindUniqueArgs>(args: SelectSubset<T, study_userFindUniqueArgs<ExtArgs>>): Prisma__study_userClient<$Result.GetResult<Prisma.$study_userPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Study_user that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {study_userFindUniqueOrThrowArgs} args - Arguments to find a Study_user
     * @example
     * // Get one Study_user
     * const study_user = await prisma.study_user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends study_userFindUniqueOrThrowArgs>(args: SelectSubset<T, study_userFindUniqueOrThrowArgs<ExtArgs>>): Prisma__study_userClient<$Result.GetResult<Prisma.$study_userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Study_user that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {study_userFindFirstArgs} args - Arguments to find a Study_user
     * @example
     * // Get one Study_user
     * const study_user = await prisma.study_user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends study_userFindFirstArgs>(args?: SelectSubset<T, study_userFindFirstArgs<ExtArgs>>): Prisma__study_userClient<$Result.GetResult<Prisma.$study_userPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Study_user that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {study_userFindFirstOrThrowArgs} args - Arguments to find a Study_user
     * @example
     * // Get one Study_user
     * const study_user = await prisma.study_user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends study_userFindFirstOrThrowArgs>(args?: SelectSubset<T, study_userFindFirstOrThrowArgs<ExtArgs>>): Prisma__study_userClient<$Result.GetResult<Prisma.$study_userPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Study_users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {study_userFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Study_users
     * const study_users = await prisma.study_user.findMany()
     * 
     * // Get first 10 Study_users
     * const study_users = await prisma.study_user.findMany({ take: 10 })
     * 
     * // Only select the `uid`
     * const study_userWithUidOnly = await prisma.study_user.findMany({ select: { uid: true } })
     * 
     */
    findMany<T extends study_userFindManyArgs>(args?: SelectSubset<T, study_userFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$study_userPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Study_user.
     * @param {study_userCreateArgs} args - Arguments to create a Study_user.
     * @example
     * // Create one Study_user
     * const Study_user = await prisma.study_user.create({
     *   data: {
     *     // ... data to create a Study_user
     *   }
     * })
     * 
     */
    create<T extends study_userCreateArgs>(args: SelectSubset<T, study_userCreateArgs<ExtArgs>>): Prisma__study_userClient<$Result.GetResult<Prisma.$study_userPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Study_users.
     * @param {study_userCreateManyArgs} args - Arguments to create many Study_users.
     * @example
     * // Create many Study_users
     * const study_user = await prisma.study_user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends study_userCreateManyArgs>(args?: SelectSubset<T, study_userCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Study_user.
     * @param {study_userDeleteArgs} args - Arguments to delete one Study_user.
     * @example
     * // Delete one Study_user
     * const Study_user = await prisma.study_user.delete({
     *   where: {
     *     // ... filter to delete one Study_user
     *   }
     * })
     * 
     */
    delete<T extends study_userDeleteArgs>(args: SelectSubset<T, study_userDeleteArgs<ExtArgs>>): Prisma__study_userClient<$Result.GetResult<Prisma.$study_userPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Study_user.
     * @param {study_userUpdateArgs} args - Arguments to update one Study_user.
     * @example
     * // Update one Study_user
     * const study_user = await prisma.study_user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends study_userUpdateArgs>(args: SelectSubset<T, study_userUpdateArgs<ExtArgs>>): Prisma__study_userClient<$Result.GetResult<Prisma.$study_userPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Study_users.
     * @param {study_userDeleteManyArgs} args - Arguments to filter Study_users to delete.
     * @example
     * // Delete a few Study_users
     * const { count } = await prisma.study_user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends study_userDeleteManyArgs>(args?: SelectSubset<T, study_userDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Study_users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {study_userUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Study_users
     * const study_user = await prisma.study_user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends study_userUpdateManyArgs>(args: SelectSubset<T, study_userUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Study_user.
     * @param {study_userUpsertArgs} args - Arguments to update or create a Study_user.
     * @example
     * // Update or create a Study_user
     * const study_user = await prisma.study_user.upsert({
     *   create: {
     *     // ... data to create a Study_user
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Study_user we want to update
     *   }
     * })
     */
    upsert<T extends study_userUpsertArgs>(args: SelectSubset<T, study_userUpsertArgs<ExtArgs>>): Prisma__study_userClient<$Result.GetResult<Prisma.$study_userPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Study_users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {study_userCountArgs} args - Arguments to filter Study_users to count.
     * @example
     * // Count the number of Study_users
     * const count = await prisma.study_user.count({
     *   where: {
     *     // ... the filter for the Study_users we want to count
     *   }
     * })
    **/
    count<T extends study_userCountArgs>(
      args?: Subset<T, study_userCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Study_userCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Study_user.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Study_userAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Study_userAggregateArgs>(args: Subset<T, Study_userAggregateArgs>): Prisma.PrismaPromise<GetStudy_userAggregateType<T>>

    /**
     * Group by Study_user.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {study_userGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends study_userGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: study_userGroupByArgs['orderBy'] }
        : { orderBy?: study_userGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, study_userGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudy_userGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the study_user model
   */
  readonly fields: study_userFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for study_user.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__study_userClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    reservation<T extends study_user$reservationArgs<ExtArgs> = {}>(args?: Subset<T, study_user$reservationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$study_reservationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    message<T extends study_user$messageArgs<ExtArgs> = {}>(args?: Subset<T, study_user$messageArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$study_messagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the study_user model
   */
  interface study_userFieldRefs {
    readonly uid: FieldRef<"study_user", 'String'>
    readonly createAt: FieldRef<"study_user", 'DateTime'>
    readonly updateAt: FieldRef<"study_user", 'DateTime'>
    readonly name: FieldRef<"study_user", 'String'>
    readonly account: FieldRef<"study_user", 'String'>
    readonly password: FieldRef<"study_user", 'String'>
    readonly isAdmin: FieldRef<"study_user", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * study_user findUnique
   */
  export type study_userFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the study_user
     */
    select?: study_userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the study_user
     */
    omit?: study_userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: study_userInclude<ExtArgs> | null
    /**
     * Filter, which study_user to fetch.
     */
    where: study_userWhereUniqueInput
  }

  /**
   * study_user findUniqueOrThrow
   */
  export type study_userFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the study_user
     */
    select?: study_userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the study_user
     */
    omit?: study_userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: study_userInclude<ExtArgs> | null
    /**
     * Filter, which study_user to fetch.
     */
    where: study_userWhereUniqueInput
  }

  /**
   * study_user findFirst
   */
  export type study_userFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the study_user
     */
    select?: study_userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the study_user
     */
    omit?: study_userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: study_userInclude<ExtArgs> | null
    /**
     * Filter, which study_user to fetch.
     */
    where?: study_userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of study_users to fetch.
     */
    orderBy?: study_userOrderByWithRelationInput | study_userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for study_users.
     */
    cursor?: study_userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` study_users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` study_users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of study_users.
     */
    distinct?: Study_userScalarFieldEnum | Study_userScalarFieldEnum[]
  }

  /**
   * study_user findFirstOrThrow
   */
  export type study_userFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the study_user
     */
    select?: study_userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the study_user
     */
    omit?: study_userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: study_userInclude<ExtArgs> | null
    /**
     * Filter, which study_user to fetch.
     */
    where?: study_userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of study_users to fetch.
     */
    orderBy?: study_userOrderByWithRelationInput | study_userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for study_users.
     */
    cursor?: study_userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` study_users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` study_users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of study_users.
     */
    distinct?: Study_userScalarFieldEnum | Study_userScalarFieldEnum[]
  }

  /**
   * study_user findMany
   */
  export type study_userFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the study_user
     */
    select?: study_userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the study_user
     */
    omit?: study_userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: study_userInclude<ExtArgs> | null
    /**
     * Filter, which study_users to fetch.
     */
    where?: study_userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of study_users to fetch.
     */
    orderBy?: study_userOrderByWithRelationInput | study_userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing study_users.
     */
    cursor?: study_userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` study_users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` study_users.
     */
    skip?: number
    distinct?: Study_userScalarFieldEnum | Study_userScalarFieldEnum[]
  }

  /**
   * study_user create
   */
  export type study_userCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the study_user
     */
    select?: study_userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the study_user
     */
    omit?: study_userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: study_userInclude<ExtArgs> | null
    /**
     * The data needed to create a study_user.
     */
    data: XOR<study_userCreateInput, study_userUncheckedCreateInput>
  }

  /**
   * study_user createMany
   */
  export type study_userCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many study_users.
     */
    data: study_userCreateManyInput | study_userCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * study_user update
   */
  export type study_userUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the study_user
     */
    select?: study_userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the study_user
     */
    omit?: study_userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: study_userInclude<ExtArgs> | null
    /**
     * The data needed to update a study_user.
     */
    data: XOR<study_userUpdateInput, study_userUncheckedUpdateInput>
    /**
     * Choose, which study_user to update.
     */
    where: study_userWhereUniqueInput
  }

  /**
   * study_user updateMany
   */
  export type study_userUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update study_users.
     */
    data: XOR<study_userUpdateManyMutationInput, study_userUncheckedUpdateManyInput>
    /**
     * Filter which study_users to update
     */
    where?: study_userWhereInput
    /**
     * Limit how many study_users to update.
     */
    limit?: number
  }

  /**
   * study_user upsert
   */
  export type study_userUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the study_user
     */
    select?: study_userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the study_user
     */
    omit?: study_userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: study_userInclude<ExtArgs> | null
    /**
     * The filter to search for the study_user to update in case it exists.
     */
    where: study_userWhereUniqueInput
    /**
     * In case the study_user found by the `where` argument doesn't exist, create a new study_user with this data.
     */
    create: XOR<study_userCreateInput, study_userUncheckedCreateInput>
    /**
     * In case the study_user was found with the provided `where` argument, update it with this data.
     */
    update: XOR<study_userUpdateInput, study_userUncheckedUpdateInput>
  }

  /**
   * study_user delete
   */
  export type study_userDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the study_user
     */
    select?: study_userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the study_user
     */
    omit?: study_userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: study_userInclude<ExtArgs> | null
    /**
     * Filter which study_user to delete.
     */
    where: study_userWhereUniqueInput
  }

  /**
   * study_user deleteMany
   */
  export type study_userDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which study_users to delete
     */
    where?: study_userWhereInput
    /**
     * Limit how many study_users to delete.
     */
    limit?: number
  }

  /**
   * study_user.reservation
   */
  export type study_user$reservationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the study_reservation
     */
    select?: study_reservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the study_reservation
     */
    omit?: study_reservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: study_reservationInclude<ExtArgs> | null
    where?: study_reservationWhereInput
    orderBy?: study_reservationOrderByWithRelationInput | study_reservationOrderByWithRelationInput[]
    cursor?: study_reservationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Study_reservationScalarFieldEnum | Study_reservationScalarFieldEnum[]
  }

  /**
   * study_user.message
   */
  export type study_user$messageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the study_message
     */
    select?: study_messageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the study_message
     */
    omit?: study_messageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: study_messageInclude<ExtArgs> | null
    where?: study_messageWhereInput
    orderBy?: study_messageOrderByWithRelationInput | study_messageOrderByWithRelationInput[]
    cursor?: study_messageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Study_messageScalarFieldEnum | Study_messageScalarFieldEnum[]
  }

  /**
   * study_user without action
   */
  export type study_userDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the study_user
     */
    select?: study_userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the study_user
     */
    omit?: study_userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: study_userInclude<ExtArgs> | null
  }


  /**
   * Model study_store
   */

  export type AggregateStudy_store = {
    _count: Study_storeCountAggregateOutputType | null
    _min: Study_storeMinAggregateOutputType | null
    _max: Study_storeMaxAggregateOutputType | null
  }

  export type Study_storeMinAggregateOutputType = {
    uid: string | null
    createAt: Date | null
    updateAt: Date | null
    name: string | null
    local: string | null
    address: string | null
    status: boolean | null
    remark: string | null
  }

  export type Study_storeMaxAggregateOutputType = {
    uid: string | null
    createAt: Date | null
    updateAt: Date | null
    name: string | null
    local: string | null
    address: string | null
    status: boolean | null
    remark: string | null
  }

  export type Study_storeCountAggregateOutputType = {
    uid: number
    createAt: number
    updateAt: number
    name: number
    local: number
    address: number
    status: number
    remark: number
    _all: number
  }


  export type Study_storeMinAggregateInputType = {
    uid?: true
    createAt?: true
    updateAt?: true
    name?: true
    local?: true
    address?: true
    status?: true
    remark?: true
  }

  export type Study_storeMaxAggregateInputType = {
    uid?: true
    createAt?: true
    updateAt?: true
    name?: true
    local?: true
    address?: true
    status?: true
    remark?: true
  }

  export type Study_storeCountAggregateInputType = {
    uid?: true
    createAt?: true
    updateAt?: true
    name?: true
    local?: true
    address?: true
    status?: true
    remark?: true
    _all?: true
  }

  export type Study_storeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which study_store to aggregate.
     */
    where?: study_storeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of study_stores to fetch.
     */
    orderBy?: study_storeOrderByWithRelationInput | study_storeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: study_storeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` study_stores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` study_stores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned study_stores
    **/
    _count?: true | Study_storeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Study_storeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Study_storeMaxAggregateInputType
  }

  export type GetStudy_storeAggregateType<T extends Study_storeAggregateArgs> = {
        [P in keyof T & keyof AggregateStudy_store]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudy_store[P]>
      : GetScalarType<T[P], AggregateStudy_store[P]>
  }




  export type study_storeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: study_storeWhereInput
    orderBy?: study_storeOrderByWithAggregationInput | study_storeOrderByWithAggregationInput[]
    by: Study_storeScalarFieldEnum[] | Study_storeScalarFieldEnum
    having?: study_storeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Study_storeCountAggregateInputType | true
    _min?: Study_storeMinAggregateInputType
    _max?: Study_storeMaxAggregateInputType
  }

  export type Study_storeGroupByOutputType = {
    uid: string
    createAt: Date
    updateAt: Date
    name: string
    local: string
    address: string
    status: boolean
    remark: string | null
    _count: Study_storeCountAggregateOutputType | null
    _min: Study_storeMinAggregateOutputType | null
    _max: Study_storeMaxAggregateOutputType | null
  }

  type GetStudy_storeGroupByPayload<T extends study_storeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Study_storeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Study_storeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Study_storeGroupByOutputType[P]>
            : GetScalarType<T[P], Study_storeGroupByOutputType[P]>
        }
      >
    >


  export type study_storeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    uid?: boolean
    createAt?: boolean
    updateAt?: boolean
    name?: boolean
    local?: boolean
    address?: boolean
    status?: boolean
    remark?: boolean
    floors?: boolean | study_store$floorsArgs<ExtArgs>
    _count?: boolean | Study_storeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["study_store"]>



  export type study_storeSelectScalar = {
    uid?: boolean
    createAt?: boolean
    updateAt?: boolean
    name?: boolean
    local?: boolean
    address?: boolean
    status?: boolean
    remark?: boolean
  }

  export type study_storeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"uid" | "createAt" | "updateAt" | "name" | "local" | "address" | "status" | "remark", ExtArgs["result"]["study_store"]>
  export type study_storeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    floors?: boolean | study_store$floorsArgs<ExtArgs>
    _count?: boolean | Study_storeCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $study_storePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "study_store"
    objects: {
      floors: Prisma.$study_floorPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      uid: string
      createAt: Date
      updateAt: Date
      name: string
      local: string
      address: string
      status: boolean
      remark: string | null
    }, ExtArgs["result"]["study_store"]>
    composites: {}
  }

  type study_storeGetPayload<S extends boolean | null | undefined | study_storeDefaultArgs> = $Result.GetResult<Prisma.$study_storePayload, S>

  type study_storeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<study_storeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Study_storeCountAggregateInputType | true
    }

  export interface study_storeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['study_store'], meta: { name: 'study_store' } }
    /**
     * Find zero or one Study_store that matches the filter.
     * @param {study_storeFindUniqueArgs} args - Arguments to find a Study_store
     * @example
     * // Get one Study_store
     * const study_store = await prisma.study_store.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends study_storeFindUniqueArgs>(args: SelectSubset<T, study_storeFindUniqueArgs<ExtArgs>>): Prisma__study_storeClient<$Result.GetResult<Prisma.$study_storePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Study_store that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {study_storeFindUniqueOrThrowArgs} args - Arguments to find a Study_store
     * @example
     * // Get one Study_store
     * const study_store = await prisma.study_store.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends study_storeFindUniqueOrThrowArgs>(args: SelectSubset<T, study_storeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__study_storeClient<$Result.GetResult<Prisma.$study_storePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Study_store that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {study_storeFindFirstArgs} args - Arguments to find a Study_store
     * @example
     * // Get one Study_store
     * const study_store = await prisma.study_store.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends study_storeFindFirstArgs>(args?: SelectSubset<T, study_storeFindFirstArgs<ExtArgs>>): Prisma__study_storeClient<$Result.GetResult<Prisma.$study_storePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Study_store that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {study_storeFindFirstOrThrowArgs} args - Arguments to find a Study_store
     * @example
     * // Get one Study_store
     * const study_store = await prisma.study_store.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends study_storeFindFirstOrThrowArgs>(args?: SelectSubset<T, study_storeFindFirstOrThrowArgs<ExtArgs>>): Prisma__study_storeClient<$Result.GetResult<Prisma.$study_storePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Study_stores that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {study_storeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Study_stores
     * const study_stores = await prisma.study_store.findMany()
     * 
     * // Get first 10 Study_stores
     * const study_stores = await prisma.study_store.findMany({ take: 10 })
     * 
     * // Only select the `uid`
     * const study_storeWithUidOnly = await prisma.study_store.findMany({ select: { uid: true } })
     * 
     */
    findMany<T extends study_storeFindManyArgs>(args?: SelectSubset<T, study_storeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$study_storePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Study_store.
     * @param {study_storeCreateArgs} args - Arguments to create a Study_store.
     * @example
     * // Create one Study_store
     * const Study_store = await prisma.study_store.create({
     *   data: {
     *     // ... data to create a Study_store
     *   }
     * })
     * 
     */
    create<T extends study_storeCreateArgs>(args: SelectSubset<T, study_storeCreateArgs<ExtArgs>>): Prisma__study_storeClient<$Result.GetResult<Prisma.$study_storePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Study_stores.
     * @param {study_storeCreateManyArgs} args - Arguments to create many Study_stores.
     * @example
     * // Create many Study_stores
     * const study_store = await prisma.study_store.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends study_storeCreateManyArgs>(args?: SelectSubset<T, study_storeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Study_store.
     * @param {study_storeDeleteArgs} args - Arguments to delete one Study_store.
     * @example
     * // Delete one Study_store
     * const Study_store = await prisma.study_store.delete({
     *   where: {
     *     // ... filter to delete one Study_store
     *   }
     * })
     * 
     */
    delete<T extends study_storeDeleteArgs>(args: SelectSubset<T, study_storeDeleteArgs<ExtArgs>>): Prisma__study_storeClient<$Result.GetResult<Prisma.$study_storePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Study_store.
     * @param {study_storeUpdateArgs} args - Arguments to update one Study_store.
     * @example
     * // Update one Study_store
     * const study_store = await prisma.study_store.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends study_storeUpdateArgs>(args: SelectSubset<T, study_storeUpdateArgs<ExtArgs>>): Prisma__study_storeClient<$Result.GetResult<Prisma.$study_storePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Study_stores.
     * @param {study_storeDeleteManyArgs} args - Arguments to filter Study_stores to delete.
     * @example
     * // Delete a few Study_stores
     * const { count } = await prisma.study_store.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends study_storeDeleteManyArgs>(args?: SelectSubset<T, study_storeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Study_stores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {study_storeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Study_stores
     * const study_store = await prisma.study_store.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends study_storeUpdateManyArgs>(args: SelectSubset<T, study_storeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Study_store.
     * @param {study_storeUpsertArgs} args - Arguments to update or create a Study_store.
     * @example
     * // Update or create a Study_store
     * const study_store = await prisma.study_store.upsert({
     *   create: {
     *     // ... data to create a Study_store
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Study_store we want to update
     *   }
     * })
     */
    upsert<T extends study_storeUpsertArgs>(args: SelectSubset<T, study_storeUpsertArgs<ExtArgs>>): Prisma__study_storeClient<$Result.GetResult<Prisma.$study_storePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Study_stores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {study_storeCountArgs} args - Arguments to filter Study_stores to count.
     * @example
     * // Count the number of Study_stores
     * const count = await prisma.study_store.count({
     *   where: {
     *     // ... the filter for the Study_stores we want to count
     *   }
     * })
    **/
    count<T extends study_storeCountArgs>(
      args?: Subset<T, study_storeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Study_storeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Study_store.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Study_storeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Study_storeAggregateArgs>(args: Subset<T, Study_storeAggregateArgs>): Prisma.PrismaPromise<GetStudy_storeAggregateType<T>>

    /**
     * Group by Study_store.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {study_storeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends study_storeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: study_storeGroupByArgs['orderBy'] }
        : { orderBy?: study_storeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, study_storeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudy_storeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the study_store model
   */
  readonly fields: study_storeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for study_store.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__study_storeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    floors<T extends study_store$floorsArgs<ExtArgs> = {}>(args?: Subset<T, study_store$floorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$study_floorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the study_store model
   */
  interface study_storeFieldRefs {
    readonly uid: FieldRef<"study_store", 'String'>
    readonly createAt: FieldRef<"study_store", 'DateTime'>
    readonly updateAt: FieldRef<"study_store", 'DateTime'>
    readonly name: FieldRef<"study_store", 'String'>
    readonly local: FieldRef<"study_store", 'String'>
    readonly address: FieldRef<"study_store", 'String'>
    readonly status: FieldRef<"study_store", 'Boolean'>
    readonly remark: FieldRef<"study_store", 'String'>
  }
    

  // Custom InputTypes
  /**
   * study_store findUnique
   */
  export type study_storeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the study_store
     */
    select?: study_storeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the study_store
     */
    omit?: study_storeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: study_storeInclude<ExtArgs> | null
    /**
     * Filter, which study_store to fetch.
     */
    where: study_storeWhereUniqueInput
  }

  /**
   * study_store findUniqueOrThrow
   */
  export type study_storeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the study_store
     */
    select?: study_storeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the study_store
     */
    omit?: study_storeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: study_storeInclude<ExtArgs> | null
    /**
     * Filter, which study_store to fetch.
     */
    where: study_storeWhereUniqueInput
  }

  /**
   * study_store findFirst
   */
  export type study_storeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the study_store
     */
    select?: study_storeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the study_store
     */
    omit?: study_storeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: study_storeInclude<ExtArgs> | null
    /**
     * Filter, which study_store to fetch.
     */
    where?: study_storeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of study_stores to fetch.
     */
    orderBy?: study_storeOrderByWithRelationInput | study_storeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for study_stores.
     */
    cursor?: study_storeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` study_stores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` study_stores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of study_stores.
     */
    distinct?: Study_storeScalarFieldEnum | Study_storeScalarFieldEnum[]
  }

  /**
   * study_store findFirstOrThrow
   */
  export type study_storeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the study_store
     */
    select?: study_storeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the study_store
     */
    omit?: study_storeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: study_storeInclude<ExtArgs> | null
    /**
     * Filter, which study_store to fetch.
     */
    where?: study_storeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of study_stores to fetch.
     */
    orderBy?: study_storeOrderByWithRelationInput | study_storeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for study_stores.
     */
    cursor?: study_storeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` study_stores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` study_stores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of study_stores.
     */
    distinct?: Study_storeScalarFieldEnum | Study_storeScalarFieldEnum[]
  }

  /**
   * study_store findMany
   */
  export type study_storeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the study_store
     */
    select?: study_storeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the study_store
     */
    omit?: study_storeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: study_storeInclude<ExtArgs> | null
    /**
     * Filter, which study_stores to fetch.
     */
    where?: study_storeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of study_stores to fetch.
     */
    orderBy?: study_storeOrderByWithRelationInput | study_storeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing study_stores.
     */
    cursor?: study_storeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` study_stores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` study_stores.
     */
    skip?: number
    distinct?: Study_storeScalarFieldEnum | Study_storeScalarFieldEnum[]
  }

  /**
   * study_store create
   */
  export type study_storeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the study_store
     */
    select?: study_storeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the study_store
     */
    omit?: study_storeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: study_storeInclude<ExtArgs> | null
    /**
     * The data needed to create a study_store.
     */
    data: XOR<study_storeCreateInput, study_storeUncheckedCreateInput>
  }

  /**
   * study_store createMany
   */
  export type study_storeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many study_stores.
     */
    data: study_storeCreateManyInput | study_storeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * study_store update
   */
  export type study_storeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the study_store
     */
    select?: study_storeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the study_store
     */
    omit?: study_storeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: study_storeInclude<ExtArgs> | null
    /**
     * The data needed to update a study_store.
     */
    data: XOR<study_storeUpdateInput, study_storeUncheckedUpdateInput>
    /**
     * Choose, which study_store to update.
     */
    where: study_storeWhereUniqueInput
  }

  /**
   * study_store updateMany
   */
  export type study_storeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update study_stores.
     */
    data: XOR<study_storeUpdateManyMutationInput, study_storeUncheckedUpdateManyInput>
    /**
     * Filter which study_stores to update
     */
    where?: study_storeWhereInput
    /**
     * Limit how many study_stores to update.
     */
    limit?: number
  }

  /**
   * study_store upsert
   */
  export type study_storeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the study_store
     */
    select?: study_storeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the study_store
     */
    omit?: study_storeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: study_storeInclude<ExtArgs> | null
    /**
     * The filter to search for the study_store to update in case it exists.
     */
    where: study_storeWhereUniqueInput
    /**
     * In case the study_store found by the `where` argument doesn't exist, create a new study_store with this data.
     */
    create: XOR<study_storeCreateInput, study_storeUncheckedCreateInput>
    /**
     * In case the study_store was found with the provided `where` argument, update it with this data.
     */
    update: XOR<study_storeUpdateInput, study_storeUncheckedUpdateInput>
  }

  /**
   * study_store delete
   */
  export type study_storeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the study_store
     */
    select?: study_storeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the study_store
     */
    omit?: study_storeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: study_storeInclude<ExtArgs> | null
    /**
     * Filter which study_store to delete.
     */
    where: study_storeWhereUniqueInput
  }

  /**
   * study_store deleteMany
   */
  export type study_storeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which study_stores to delete
     */
    where?: study_storeWhereInput
    /**
     * Limit how many study_stores to delete.
     */
    limit?: number
  }

  /**
   * study_store.floors
   */
  export type study_store$floorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the study_floor
     */
    select?: study_floorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the study_floor
     */
    omit?: study_floorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: study_floorInclude<ExtArgs> | null
    where?: study_floorWhereInput
    orderBy?: study_floorOrderByWithRelationInput | study_floorOrderByWithRelationInput[]
    cursor?: study_floorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Study_floorScalarFieldEnum | Study_floorScalarFieldEnum[]
  }

  /**
   * study_store without action
   */
  export type study_storeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the study_store
     */
    select?: study_storeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the study_store
     */
    omit?: study_storeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: study_storeInclude<ExtArgs> | null
  }


  /**
   * Model study_floor
   */

  export type AggregateStudy_floor = {
    _count: Study_floorCountAggregateOutputType | null
    _avg: Study_floorAvgAggregateOutputType | null
    _sum: Study_floorSumAggregateOutputType | null
    _min: Study_floorMinAggregateOutputType | null
    _max: Study_floorMaxAggregateOutputType | null
  }

  export type Study_floorAvgAggregateOutputType = {
    floorNumber: number | null
  }

  export type Study_floorSumAggregateOutputType = {
    floorNumber: number | null
  }

  export type Study_floorMinAggregateOutputType = {
    uid: string | null
    createAt: Date | null
    updateAt: Date | null
    floorNumber: number | null
    storeId: string | null
  }

  export type Study_floorMaxAggregateOutputType = {
    uid: string | null
    createAt: Date | null
    updateAt: Date | null
    floorNumber: number | null
    storeId: string | null
  }

  export type Study_floorCountAggregateOutputType = {
    uid: number
    createAt: number
    updateAt: number
    floorNumber: number
    storeId: number
    _all: number
  }


  export type Study_floorAvgAggregateInputType = {
    floorNumber?: true
  }

  export type Study_floorSumAggregateInputType = {
    floorNumber?: true
  }

  export type Study_floorMinAggregateInputType = {
    uid?: true
    createAt?: true
    updateAt?: true
    floorNumber?: true
    storeId?: true
  }

  export type Study_floorMaxAggregateInputType = {
    uid?: true
    createAt?: true
    updateAt?: true
    floorNumber?: true
    storeId?: true
  }

  export type Study_floorCountAggregateInputType = {
    uid?: true
    createAt?: true
    updateAt?: true
    floorNumber?: true
    storeId?: true
    _all?: true
  }

  export type Study_floorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which study_floor to aggregate.
     */
    where?: study_floorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of study_floors to fetch.
     */
    orderBy?: study_floorOrderByWithRelationInput | study_floorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: study_floorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` study_floors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` study_floors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned study_floors
    **/
    _count?: true | Study_floorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Study_floorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Study_floorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Study_floorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Study_floorMaxAggregateInputType
  }

  export type GetStudy_floorAggregateType<T extends Study_floorAggregateArgs> = {
        [P in keyof T & keyof AggregateStudy_floor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudy_floor[P]>
      : GetScalarType<T[P], AggregateStudy_floor[P]>
  }




  export type study_floorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: study_floorWhereInput
    orderBy?: study_floorOrderByWithAggregationInput | study_floorOrderByWithAggregationInput[]
    by: Study_floorScalarFieldEnum[] | Study_floorScalarFieldEnum
    having?: study_floorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Study_floorCountAggregateInputType | true
    _avg?: Study_floorAvgAggregateInputType
    _sum?: Study_floorSumAggregateInputType
    _min?: Study_floorMinAggregateInputType
    _max?: Study_floorMaxAggregateInputType
  }

  export type Study_floorGroupByOutputType = {
    uid: string
    createAt: Date
    updateAt: Date
    floorNumber: number
    storeId: string
    _count: Study_floorCountAggregateOutputType | null
    _avg: Study_floorAvgAggregateOutputType | null
    _sum: Study_floorSumAggregateOutputType | null
    _min: Study_floorMinAggregateOutputType | null
    _max: Study_floorMaxAggregateOutputType | null
  }

  type GetStudy_floorGroupByPayload<T extends study_floorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Study_floorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Study_floorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Study_floorGroupByOutputType[P]>
            : GetScalarType<T[P], Study_floorGroupByOutputType[P]>
        }
      >
    >


  export type study_floorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    uid?: boolean
    createAt?: boolean
    updateAt?: boolean
    floorNumber?: boolean
    storeId?: boolean
    store?: boolean | study_storeDefaultArgs<ExtArgs>
    studyRooms?: boolean | study_floor$studyRoomsArgs<ExtArgs>
    _count?: boolean | Study_floorCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["study_floor"]>



  export type study_floorSelectScalar = {
    uid?: boolean
    createAt?: boolean
    updateAt?: boolean
    floorNumber?: boolean
    storeId?: boolean
  }

  export type study_floorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"uid" | "createAt" | "updateAt" | "floorNumber" | "storeId", ExtArgs["result"]["study_floor"]>
  export type study_floorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    store?: boolean | study_storeDefaultArgs<ExtArgs>
    studyRooms?: boolean | study_floor$studyRoomsArgs<ExtArgs>
    _count?: boolean | Study_floorCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $study_floorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "study_floor"
    objects: {
      store: Prisma.$study_storePayload<ExtArgs>
      studyRooms: Prisma.$study_roomPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      uid: string
      createAt: Date
      updateAt: Date
      floorNumber: number
      storeId: string
    }, ExtArgs["result"]["study_floor"]>
    composites: {}
  }

  type study_floorGetPayload<S extends boolean | null | undefined | study_floorDefaultArgs> = $Result.GetResult<Prisma.$study_floorPayload, S>

  type study_floorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<study_floorFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Study_floorCountAggregateInputType | true
    }

  export interface study_floorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['study_floor'], meta: { name: 'study_floor' } }
    /**
     * Find zero or one Study_floor that matches the filter.
     * @param {study_floorFindUniqueArgs} args - Arguments to find a Study_floor
     * @example
     * // Get one Study_floor
     * const study_floor = await prisma.study_floor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends study_floorFindUniqueArgs>(args: SelectSubset<T, study_floorFindUniqueArgs<ExtArgs>>): Prisma__study_floorClient<$Result.GetResult<Prisma.$study_floorPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Study_floor that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {study_floorFindUniqueOrThrowArgs} args - Arguments to find a Study_floor
     * @example
     * // Get one Study_floor
     * const study_floor = await prisma.study_floor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends study_floorFindUniqueOrThrowArgs>(args: SelectSubset<T, study_floorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__study_floorClient<$Result.GetResult<Prisma.$study_floorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Study_floor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {study_floorFindFirstArgs} args - Arguments to find a Study_floor
     * @example
     * // Get one Study_floor
     * const study_floor = await prisma.study_floor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends study_floorFindFirstArgs>(args?: SelectSubset<T, study_floorFindFirstArgs<ExtArgs>>): Prisma__study_floorClient<$Result.GetResult<Prisma.$study_floorPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Study_floor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {study_floorFindFirstOrThrowArgs} args - Arguments to find a Study_floor
     * @example
     * // Get one Study_floor
     * const study_floor = await prisma.study_floor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends study_floorFindFirstOrThrowArgs>(args?: SelectSubset<T, study_floorFindFirstOrThrowArgs<ExtArgs>>): Prisma__study_floorClient<$Result.GetResult<Prisma.$study_floorPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Study_floors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {study_floorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Study_floors
     * const study_floors = await prisma.study_floor.findMany()
     * 
     * // Get first 10 Study_floors
     * const study_floors = await prisma.study_floor.findMany({ take: 10 })
     * 
     * // Only select the `uid`
     * const study_floorWithUidOnly = await prisma.study_floor.findMany({ select: { uid: true } })
     * 
     */
    findMany<T extends study_floorFindManyArgs>(args?: SelectSubset<T, study_floorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$study_floorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Study_floor.
     * @param {study_floorCreateArgs} args - Arguments to create a Study_floor.
     * @example
     * // Create one Study_floor
     * const Study_floor = await prisma.study_floor.create({
     *   data: {
     *     // ... data to create a Study_floor
     *   }
     * })
     * 
     */
    create<T extends study_floorCreateArgs>(args: SelectSubset<T, study_floorCreateArgs<ExtArgs>>): Prisma__study_floorClient<$Result.GetResult<Prisma.$study_floorPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Study_floors.
     * @param {study_floorCreateManyArgs} args - Arguments to create many Study_floors.
     * @example
     * // Create many Study_floors
     * const study_floor = await prisma.study_floor.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends study_floorCreateManyArgs>(args?: SelectSubset<T, study_floorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Study_floor.
     * @param {study_floorDeleteArgs} args - Arguments to delete one Study_floor.
     * @example
     * // Delete one Study_floor
     * const Study_floor = await prisma.study_floor.delete({
     *   where: {
     *     // ... filter to delete one Study_floor
     *   }
     * })
     * 
     */
    delete<T extends study_floorDeleteArgs>(args: SelectSubset<T, study_floorDeleteArgs<ExtArgs>>): Prisma__study_floorClient<$Result.GetResult<Prisma.$study_floorPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Study_floor.
     * @param {study_floorUpdateArgs} args - Arguments to update one Study_floor.
     * @example
     * // Update one Study_floor
     * const study_floor = await prisma.study_floor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends study_floorUpdateArgs>(args: SelectSubset<T, study_floorUpdateArgs<ExtArgs>>): Prisma__study_floorClient<$Result.GetResult<Prisma.$study_floorPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Study_floors.
     * @param {study_floorDeleteManyArgs} args - Arguments to filter Study_floors to delete.
     * @example
     * // Delete a few Study_floors
     * const { count } = await prisma.study_floor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends study_floorDeleteManyArgs>(args?: SelectSubset<T, study_floorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Study_floors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {study_floorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Study_floors
     * const study_floor = await prisma.study_floor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends study_floorUpdateManyArgs>(args: SelectSubset<T, study_floorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Study_floor.
     * @param {study_floorUpsertArgs} args - Arguments to update or create a Study_floor.
     * @example
     * // Update or create a Study_floor
     * const study_floor = await prisma.study_floor.upsert({
     *   create: {
     *     // ... data to create a Study_floor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Study_floor we want to update
     *   }
     * })
     */
    upsert<T extends study_floorUpsertArgs>(args: SelectSubset<T, study_floorUpsertArgs<ExtArgs>>): Prisma__study_floorClient<$Result.GetResult<Prisma.$study_floorPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Study_floors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {study_floorCountArgs} args - Arguments to filter Study_floors to count.
     * @example
     * // Count the number of Study_floors
     * const count = await prisma.study_floor.count({
     *   where: {
     *     // ... the filter for the Study_floors we want to count
     *   }
     * })
    **/
    count<T extends study_floorCountArgs>(
      args?: Subset<T, study_floorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Study_floorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Study_floor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Study_floorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Study_floorAggregateArgs>(args: Subset<T, Study_floorAggregateArgs>): Prisma.PrismaPromise<GetStudy_floorAggregateType<T>>

    /**
     * Group by Study_floor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {study_floorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends study_floorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: study_floorGroupByArgs['orderBy'] }
        : { orderBy?: study_floorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, study_floorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudy_floorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the study_floor model
   */
  readonly fields: study_floorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for study_floor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__study_floorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    store<T extends study_storeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, study_storeDefaultArgs<ExtArgs>>): Prisma__study_storeClient<$Result.GetResult<Prisma.$study_storePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    studyRooms<T extends study_floor$studyRoomsArgs<ExtArgs> = {}>(args?: Subset<T, study_floor$studyRoomsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$study_roomPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the study_floor model
   */
  interface study_floorFieldRefs {
    readonly uid: FieldRef<"study_floor", 'String'>
    readonly createAt: FieldRef<"study_floor", 'DateTime'>
    readonly updateAt: FieldRef<"study_floor", 'DateTime'>
    readonly floorNumber: FieldRef<"study_floor", 'Int'>
    readonly storeId: FieldRef<"study_floor", 'String'>
  }
    

  // Custom InputTypes
  /**
   * study_floor findUnique
   */
  export type study_floorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the study_floor
     */
    select?: study_floorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the study_floor
     */
    omit?: study_floorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: study_floorInclude<ExtArgs> | null
    /**
     * Filter, which study_floor to fetch.
     */
    where: study_floorWhereUniqueInput
  }

  /**
   * study_floor findUniqueOrThrow
   */
  export type study_floorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the study_floor
     */
    select?: study_floorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the study_floor
     */
    omit?: study_floorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: study_floorInclude<ExtArgs> | null
    /**
     * Filter, which study_floor to fetch.
     */
    where: study_floorWhereUniqueInput
  }

  /**
   * study_floor findFirst
   */
  export type study_floorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the study_floor
     */
    select?: study_floorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the study_floor
     */
    omit?: study_floorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: study_floorInclude<ExtArgs> | null
    /**
     * Filter, which study_floor to fetch.
     */
    where?: study_floorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of study_floors to fetch.
     */
    orderBy?: study_floorOrderByWithRelationInput | study_floorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for study_floors.
     */
    cursor?: study_floorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` study_floors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` study_floors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of study_floors.
     */
    distinct?: Study_floorScalarFieldEnum | Study_floorScalarFieldEnum[]
  }

  /**
   * study_floor findFirstOrThrow
   */
  export type study_floorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the study_floor
     */
    select?: study_floorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the study_floor
     */
    omit?: study_floorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: study_floorInclude<ExtArgs> | null
    /**
     * Filter, which study_floor to fetch.
     */
    where?: study_floorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of study_floors to fetch.
     */
    orderBy?: study_floorOrderByWithRelationInput | study_floorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for study_floors.
     */
    cursor?: study_floorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` study_floors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` study_floors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of study_floors.
     */
    distinct?: Study_floorScalarFieldEnum | Study_floorScalarFieldEnum[]
  }

  /**
   * study_floor findMany
   */
  export type study_floorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the study_floor
     */
    select?: study_floorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the study_floor
     */
    omit?: study_floorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: study_floorInclude<ExtArgs> | null
    /**
     * Filter, which study_floors to fetch.
     */
    where?: study_floorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of study_floors to fetch.
     */
    orderBy?: study_floorOrderByWithRelationInput | study_floorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing study_floors.
     */
    cursor?: study_floorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` study_floors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` study_floors.
     */
    skip?: number
    distinct?: Study_floorScalarFieldEnum | Study_floorScalarFieldEnum[]
  }

  /**
   * study_floor create
   */
  export type study_floorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the study_floor
     */
    select?: study_floorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the study_floor
     */
    omit?: study_floorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: study_floorInclude<ExtArgs> | null
    /**
     * The data needed to create a study_floor.
     */
    data: XOR<study_floorCreateInput, study_floorUncheckedCreateInput>
  }

  /**
   * study_floor createMany
   */
  export type study_floorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many study_floors.
     */
    data: study_floorCreateManyInput | study_floorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * study_floor update
   */
  export type study_floorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the study_floor
     */
    select?: study_floorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the study_floor
     */
    omit?: study_floorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: study_floorInclude<ExtArgs> | null
    /**
     * The data needed to update a study_floor.
     */
    data: XOR<study_floorUpdateInput, study_floorUncheckedUpdateInput>
    /**
     * Choose, which study_floor to update.
     */
    where: study_floorWhereUniqueInput
  }

  /**
   * study_floor updateMany
   */
  export type study_floorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update study_floors.
     */
    data: XOR<study_floorUpdateManyMutationInput, study_floorUncheckedUpdateManyInput>
    /**
     * Filter which study_floors to update
     */
    where?: study_floorWhereInput
    /**
     * Limit how many study_floors to update.
     */
    limit?: number
  }

  /**
   * study_floor upsert
   */
  export type study_floorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the study_floor
     */
    select?: study_floorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the study_floor
     */
    omit?: study_floorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: study_floorInclude<ExtArgs> | null
    /**
     * The filter to search for the study_floor to update in case it exists.
     */
    where: study_floorWhereUniqueInput
    /**
     * In case the study_floor found by the `where` argument doesn't exist, create a new study_floor with this data.
     */
    create: XOR<study_floorCreateInput, study_floorUncheckedCreateInput>
    /**
     * In case the study_floor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<study_floorUpdateInput, study_floorUncheckedUpdateInput>
  }

  /**
   * study_floor delete
   */
  export type study_floorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the study_floor
     */
    select?: study_floorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the study_floor
     */
    omit?: study_floorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: study_floorInclude<ExtArgs> | null
    /**
     * Filter which study_floor to delete.
     */
    where: study_floorWhereUniqueInput
  }

  /**
   * study_floor deleteMany
   */
  export type study_floorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which study_floors to delete
     */
    where?: study_floorWhereInput
    /**
     * Limit how many study_floors to delete.
     */
    limit?: number
  }

  /**
   * study_floor.studyRooms
   */
  export type study_floor$studyRoomsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the study_room
     */
    select?: study_roomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the study_room
     */
    omit?: study_roomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: study_roomInclude<ExtArgs> | null
    where?: study_roomWhereInput
    orderBy?: study_roomOrderByWithRelationInput | study_roomOrderByWithRelationInput[]
    cursor?: study_roomWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Study_roomScalarFieldEnum | Study_roomScalarFieldEnum[]
  }

  /**
   * study_floor without action
   */
  export type study_floorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the study_floor
     */
    select?: study_floorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the study_floor
     */
    omit?: study_floorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: study_floorInclude<ExtArgs> | null
  }


  /**
   * Model study_room
   */

  export type AggregateStudy_room = {
    _count: Study_roomCountAggregateOutputType | null
    _avg: Study_roomAvgAggregateOutputType | null
    _sum: Study_roomSumAggregateOutputType | null
    _min: Study_roomMinAggregateOutputType | null
    _max: Study_roomMaxAggregateOutputType | null
  }

  export type Study_roomAvgAggregateOutputType = {
    capacity: number | null
  }

  export type Study_roomSumAggregateOutputType = {
    capacity: number | null
  }

  export type Study_roomMinAggregateOutputType = {
    uid: string | null
    createAt: Date | null
    updateAt: Date | null
    name: string | null
    floorId: string | null
    capacity: number | null
    status: boolean | null
  }

  export type Study_roomMaxAggregateOutputType = {
    uid: string | null
    createAt: Date | null
    updateAt: Date | null
    name: string | null
    floorId: string | null
    capacity: number | null
    status: boolean | null
  }

  export type Study_roomCountAggregateOutputType = {
    uid: number
    createAt: number
    updateAt: number
    name: number
    floorId: number
    capacity: number
    status: number
    _all: number
  }


  export type Study_roomAvgAggregateInputType = {
    capacity?: true
  }

  export type Study_roomSumAggregateInputType = {
    capacity?: true
  }

  export type Study_roomMinAggregateInputType = {
    uid?: true
    createAt?: true
    updateAt?: true
    name?: true
    floorId?: true
    capacity?: true
    status?: true
  }

  export type Study_roomMaxAggregateInputType = {
    uid?: true
    createAt?: true
    updateAt?: true
    name?: true
    floorId?: true
    capacity?: true
    status?: true
  }

  export type Study_roomCountAggregateInputType = {
    uid?: true
    createAt?: true
    updateAt?: true
    name?: true
    floorId?: true
    capacity?: true
    status?: true
    _all?: true
  }

  export type Study_roomAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which study_room to aggregate.
     */
    where?: study_roomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of study_rooms to fetch.
     */
    orderBy?: study_roomOrderByWithRelationInput | study_roomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: study_roomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` study_rooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` study_rooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned study_rooms
    **/
    _count?: true | Study_roomCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Study_roomAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Study_roomSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Study_roomMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Study_roomMaxAggregateInputType
  }

  export type GetStudy_roomAggregateType<T extends Study_roomAggregateArgs> = {
        [P in keyof T & keyof AggregateStudy_room]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudy_room[P]>
      : GetScalarType<T[P], AggregateStudy_room[P]>
  }




  export type study_roomGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: study_roomWhereInput
    orderBy?: study_roomOrderByWithAggregationInput | study_roomOrderByWithAggregationInput[]
    by: Study_roomScalarFieldEnum[] | Study_roomScalarFieldEnum
    having?: study_roomScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Study_roomCountAggregateInputType | true
    _avg?: Study_roomAvgAggregateInputType
    _sum?: Study_roomSumAggregateInputType
    _min?: Study_roomMinAggregateInputType
    _max?: Study_roomMaxAggregateInputType
  }

  export type Study_roomGroupByOutputType = {
    uid: string
    createAt: Date
    updateAt: Date
    name: string
    floorId: string
    capacity: number
    status: boolean
    _count: Study_roomCountAggregateOutputType | null
    _avg: Study_roomAvgAggregateOutputType | null
    _sum: Study_roomSumAggregateOutputType | null
    _min: Study_roomMinAggregateOutputType | null
    _max: Study_roomMaxAggregateOutputType | null
  }

  type GetStudy_roomGroupByPayload<T extends study_roomGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Study_roomGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Study_roomGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Study_roomGroupByOutputType[P]>
            : GetScalarType<T[P], Study_roomGroupByOutputType[P]>
        }
      >
    >


  export type study_roomSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    uid?: boolean
    createAt?: boolean
    updateAt?: boolean
    name?: boolean
    floorId?: boolean
    capacity?: boolean
    status?: boolean
    floor?: boolean | study_floorDefaultArgs<ExtArgs>
    seats?: boolean | study_room$seatsArgs<ExtArgs>
    _count?: boolean | Study_roomCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["study_room"]>



  export type study_roomSelectScalar = {
    uid?: boolean
    createAt?: boolean
    updateAt?: boolean
    name?: boolean
    floorId?: boolean
    capacity?: boolean
    status?: boolean
  }

  export type study_roomOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"uid" | "createAt" | "updateAt" | "name" | "floorId" | "capacity" | "status", ExtArgs["result"]["study_room"]>
  export type study_roomInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    floor?: boolean | study_floorDefaultArgs<ExtArgs>
    seats?: boolean | study_room$seatsArgs<ExtArgs>
    _count?: boolean | Study_roomCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $study_roomPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "study_room"
    objects: {
      floor: Prisma.$study_floorPayload<ExtArgs>
      seats: Prisma.$study_seatPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      uid: string
      createAt: Date
      updateAt: Date
      name: string
      floorId: string
      capacity: number
      status: boolean
    }, ExtArgs["result"]["study_room"]>
    composites: {}
  }

  type study_roomGetPayload<S extends boolean | null | undefined | study_roomDefaultArgs> = $Result.GetResult<Prisma.$study_roomPayload, S>

  type study_roomCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<study_roomFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Study_roomCountAggregateInputType | true
    }

  export interface study_roomDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['study_room'], meta: { name: 'study_room' } }
    /**
     * Find zero or one Study_room that matches the filter.
     * @param {study_roomFindUniqueArgs} args - Arguments to find a Study_room
     * @example
     * // Get one Study_room
     * const study_room = await prisma.study_room.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends study_roomFindUniqueArgs>(args: SelectSubset<T, study_roomFindUniqueArgs<ExtArgs>>): Prisma__study_roomClient<$Result.GetResult<Prisma.$study_roomPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Study_room that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {study_roomFindUniqueOrThrowArgs} args - Arguments to find a Study_room
     * @example
     * // Get one Study_room
     * const study_room = await prisma.study_room.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends study_roomFindUniqueOrThrowArgs>(args: SelectSubset<T, study_roomFindUniqueOrThrowArgs<ExtArgs>>): Prisma__study_roomClient<$Result.GetResult<Prisma.$study_roomPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Study_room that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {study_roomFindFirstArgs} args - Arguments to find a Study_room
     * @example
     * // Get one Study_room
     * const study_room = await prisma.study_room.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends study_roomFindFirstArgs>(args?: SelectSubset<T, study_roomFindFirstArgs<ExtArgs>>): Prisma__study_roomClient<$Result.GetResult<Prisma.$study_roomPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Study_room that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {study_roomFindFirstOrThrowArgs} args - Arguments to find a Study_room
     * @example
     * // Get one Study_room
     * const study_room = await prisma.study_room.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends study_roomFindFirstOrThrowArgs>(args?: SelectSubset<T, study_roomFindFirstOrThrowArgs<ExtArgs>>): Prisma__study_roomClient<$Result.GetResult<Prisma.$study_roomPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Study_rooms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {study_roomFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Study_rooms
     * const study_rooms = await prisma.study_room.findMany()
     * 
     * // Get first 10 Study_rooms
     * const study_rooms = await prisma.study_room.findMany({ take: 10 })
     * 
     * // Only select the `uid`
     * const study_roomWithUidOnly = await prisma.study_room.findMany({ select: { uid: true } })
     * 
     */
    findMany<T extends study_roomFindManyArgs>(args?: SelectSubset<T, study_roomFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$study_roomPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Study_room.
     * @param {study_roomCreateArgs} args - Arguments to create a Study_room.
     * @example
     * // Create one Study_room
     * const Study_room = await prisma.study_room.create({
     *   data: {
     *     // ... data to create a Study_room
     *   }
     * })
     * 
     */
    create<T extends study_roomCreateArgs>(args: SelectSubset<T, study_roomCreateArgs<ExtArgs>>): Prisma__study_roomClient<$Result.GetResult<Prisma.$study_roomPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Study_rooms.
     * @param {study_roomCreateManyArgs} args - Arguments to create many Study_rooms.
     * @example
     * // Create many Study_rooms
     * const study_room = await prisma.study_room.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends study_roomCreateManyArgs>(args?: SelectSubset<T, study_roomCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Study_room.
     * @param {study_roomDeleteArgs} args - Arguments to delete one Study_room.
     * @example
     * // Delete one Study_room
     * const Study_room = await prisma.study_room.delete({
     *   where: {
     *     // ... filter to delete one Study_room
     *   }
     * })
     * 
     */
    delete<T extends study_roomDeleteArgs>(args: SelectSubset<T, study_roomDeleteArgs<ExtArgs>>): Prisma__study_roomClient<$Result.GetResult<Prisma.$study_roomPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Study_room.
     * @param {study_roomUpdateArgs} args - Arguments to update one Study_room.
     * @example
     * // Update one Study_room
     * const study_room = await prisma.study_room.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends study_roomUpdateArgs>(args: SelectSubset<T, study_roomUpdateArgs<ExtArgs>>): Prisma__study_roomClient<$Result.GetResult<Prisma.$study_roomPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Study_rooms.
     * @param {study_roomDeleteManyArgs} args - Arguments to filter Study_rooms to delete.
     * @example
     * // Delete a few Study_rooms
     * const { count } = await prisma.study_room.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends study_roomDeleteManyArgs>(args?: SelectSubset<T, study_roomDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Study_rooms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {study_roomUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Study_rooms
     * const study_room = await prisma.study_room.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends study_roomUpdateManyArgs>(args: SelectSubset<T, study_roomUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Study_room.
     * @param {study_roomUpsertArgs} args - Arguments to update or create a Study_room.
     * @example
     * // Update or create a Study_room
     * const study_room = await prisma.study_room.upsert({
     *   create: {
     *     // ... data to create a Study_room
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Study_room we want to update
     *   }
     * })
     */
    upsert<T extends study_roomUpsertArgs>(args: SelectSubset<T, study_roomUpsertArgs<ExtArgs>>): Prisma__study_roomClient<$Result.GetResult<Prisma.$study_roomPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Study_rooms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {study_roomCountArgs} args - Arguments to filter Study_rooms to count.
     * @example
     * // Count the number of Study_rooms
     * const count = await prisma.study_room.count({
     *   where: {
     *     // ... the filter for the Study_rooms we want to count
     *   }
     * })
    **/
    count<T extends study_roomCountArgs>(
      args?: Subset<T, study_roomCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Study_roomCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Study_room.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Study_roomAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Study_roomAggregateArgs>(args: Subset<T, Study_roomAggregateArgs>): Prisma.PrismaPromise<GetStudy_roomAggregateType<T>>

    /**
     * Group by Study_room.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {study_roomGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends study_roomGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: study_roomGroupByArgs['orderBy'] }
        : { orderBy?: study_roomGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, study_roomGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudy_roomGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the study_room model
   */
  readonly fields: study_roomFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for study_room.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__study_roomClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    floor<T extends study_floorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, study_floorDefaultArgs<ExtArgs>>): Prisma__study_floorClient<$Result.GetResult<Prisma.$study_floorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    seats<T extends study_room$seatsArgs<ExtArgs> = {}>(args?: Subset<T, study_room$seatsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$study_seatPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the study_room model
   */
  interface study_roomFieldRefs {
    readonly uid: FieldRef<"study_room", 'String'>
    readonly createAt: FieldRef<"study_room", 'DateTime'>
    readonly updateAt: FieldRef<"study_room", 'DateTime'>
    readonly name: FieldRef<"study_room", 'String'>
    readonly floorId: FieldRef<"study_room", 'String'>
    readonly capacity: FieldRef<"study_room", 'Int'>
    readonly status: FieldRef<"study_room", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * study_room findUnique
   */
  export type study_roomFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the study_room
     */
    select?: study_roomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the study_room
     */
    omit?: study_roomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: study_roomInclude<ExtArgs> | null
    /**
     * Filter, which study_room to fetch.
     */
    where: study_roomWhereUniqueInput
  }

  /**
   * study_room findUniqueOrThrow
   */
  export type study_roomFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the study_room
     */
    select?: study_roomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the study_room
     */
    omit?: study_roomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: study_roomInclude<ExtArgs> | null
    /**
     * Filter, which study_room to fetch.
     */
    where: study_roomWhereUniqueInput
  }

  /**
   * study_room findFirst
   */
  export type study_roomFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the study_room
     */
    select?: study_roomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the study_room
     */
    omit?: study_roomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: study_roomInclude<ExtArgs> | null
    /**
     * Filter, which study_room to fetch.
     */
    where?: study_roomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of study_rooms to fetch.
     */
    orderBy?: study_roomOrderByWithRelationInput | study_roomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for study_rooms.
     */
    cursor?: study_roomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` study_rooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` study_rooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of study_rooms.
     */
    distinct?: Study_roomScalarFieldEnum | Study_roomScalarFieldEnum[]
  }

  /**
   * study_room findFirstOrThrow
   */
  export type study_roomFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the study_room
     */
    select?: study_roomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the study_room
     */
    omit?: study_roomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: study_roomInclude<ExtArgs> | null
    /**
     * Filter, which study_room to fetch.
     */
    where?: study_roomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of study_rooms to fetch.
     */
    orderBy?: study_roomOrderByWithRelationInput | study_roomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for study_rooms.
     */
    cursor?: study_roomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` study_rooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` study_rooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of study_rooms.
     */
    distinct?: Study_roomScalarFieldEnum | Study_roomScalarFieldEnum[]
  }

  /**
   * study_room findMany
   */
  export type study_roomFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the study_room
     */
    select?: study_roomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the study_room
     */
    omit?: study_roomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: study_roomInclude<ExtArgs> | null
    /**
     * Filter, which study_rooms to fetch.
     */
    where?: study_roomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of study_rooms to fetch.
     */
    orderBy?: study_roomOrderByWithRelationInput | study_roomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing study_rooms.
     */
    cursor?: study_roomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` study_rooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` study_rooms.
     */
    skip?: number
    distinct?: Study_roomScalarFieldEnum | Study_roomScalarFieldEnum[]
  }

  /**
   * study_room create
   */
  export type study_roomCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the study_room
     */
    select?: study_roomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the study_room
     */
    omit?: study_roomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: study_roomInclude<ExtArgs> | null
    /**
     * The data needed to create a study_room.
     */
    data: XOR<study_roomCreateInput, study_roomUncheckedCreateInput>
  }

  /**
   * study_room createMany
   */
  export type study_roomCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many study_rooms.
     */
    data: study_roomCreateManyInput | study_roomCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * study_room update
   */
  export type study_roomUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the study_room
     */
    select?: study_roomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the study_room
     */
    omit?: study_roomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: study_roomInclude<ExtArgs> | null
    /**
     * The data needed to update a study_room.
     */
    data: XOR<study_roomUpdateInput, study_roomUncheckedUpdateInput>
    /**
     * Choose, which study_room to update.
     */
    where: study_roomWhereUniqueInput
  }

  /**
   * study_room updateMany
   */
  export type study_roomUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update study_rooms.
     */
    data: XOR<study_roomUpdateManyMutationInput, study_roomUncheckedUpdateManyInput>
    /**
     * Filter which study_rooms to update
     */
    where?: study_roomWhereInput
    /**
     * Limit how many study_rooms to update.
     */
    limit?: number
  }

  /**
   * study_room upsert
   */
  export type study_roomUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the study_room
     */
    select?: study_roomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the study_room
     */
    omit?: study_roomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: study_roomInclude<ExtArgs> | null
    /**
     * The filter to search for the study_room to update in case it exists.
     */
    where: study_roomWhereUniqueInput
    /**
     * In case the study_room found by the `where` argument doesn't exist, create a new study_room with this data.
     */
    create: XOR<study_roomCreateInput, study_roomUncheckedCreateInput>
    /**
     * In case the study_room was found with the provided `where` argument, update it with this data.
     */
    update: XOR<study_roomUpdateInput, study_roomUncheckedUpdateInput>
  }

  /**
   * study_room delete
   */
  export type study_roomDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the study_room
     */
    select?: study_roomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the study_room
     */
    omit?: study_roomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: study_roomInclude<ExtArgs> | null
    /**
     * Filter which study_room to delete.
     */
    where: study_roomWhereUniqueInput
  }

  /**
   * study_room deleteMany
   */
  export type study_roomDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which study_rooms to delete
     */
    where?: study_roomWhereInput
    /**
     * Limit how many study_rooms to delete.
     */
    limit?: number
  }

  /**
   * study_room.seats
   */
  export type study_room$seatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the study_seat
     */
    select?: study_seatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the study_seat
     */
    omit?: study_seatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: study_seatInclude<ExtArgs> | null
    where?: study_seatWhereInput
    orderBy?: study_seatOrderByWithRelationInput | study_seatOrderByWithRelationInput[]
    cursor?: study_seatWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Study_seatScalarFieldEnum | Study_seatScalarFieldEnum[]
  }

  /**
   * study_room without action
   */
  export type study_roomDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the study_room
     */
    select?: study_roomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the study_room
     */
    omit?: study_roomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: study_roomInclude<ExtArgs> | null
  }


  /**
   * Model study_seat
   */

  export type AggregateStudy_seat = {
    _count: Study_seatCountAggregateOutputType | null
    _min: Study_seatMinAggregateOutputType | null
    _max: Study_seatMaxAggregateOutputType | null
  }

  export type Study_seatMinAggregateOutputType = {
    uid: string | null
    createAt: Date | null
    updateAt: Date | null
    seatNumber: string | null
    roomId: string | null
    status: boolean | null
  }

  export type Study_seatMaxAggregateOutputType = {
    uid: string | null
    createAt: Date | null
    updateAt: Date | null
    seatNumber: string | null
    roomId: string | null
    status: boolean | null
  }

  export type Study_seatCountAggregateOutputType = {
    uid: number
    createAt: number
    updateAt: number
    seatNumber: number
    roomId: number
    status: number
    _all: number
  }


  export type Study_seatMinAggregateInputType = {
    uid?: true
    createAt?: true
    updateAt?: true
    seatNumber?: true
    roomId?: true
    status?: true
  }

  export type Study_seatMaxAggregateInputType = {
    uid?: true
    createAt?: true
    updateAt?: true
    seatNumber?: true
    roomId?: true
    status?: true
  }

  export type Study_seatCountAggregateInputType = {
    uid?: true
    createAt?: true
    updateAt?: true
    seatNumber?: true
    roomId?: true
    status?: true
    _all?: true
  }

  export type Study_seatAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which study_seat to aggregate.
     */
    where?: study_seatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of study_seats to fetch.
     */
    orderBy?: study_seatOrderByWithRelationInput | study_seatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: study_seatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` study_seats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` study_seats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned study_seats
    **/
    _count?: true | Study_seatCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Study_seatMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Study_seatMaxAggregateInputType
  }

  export type GetStudy_seatAggregateType<T extends Study_seatAggregateArgs> = {
        [P in keyof T & keyof AggregateStudy_seat]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudy_seat[P]>
      : GetScalarType<T[P], AggregateStudy_seat[P]>
  }




  export type study_seatGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: study_seatWhereInput
    orderBy?: study_seatOrderByWithAggregationInput | study_seatOrderByWithAggregationInput[]
    by: Study_seatScalarFieldEnum[] | Study_seatScalarFieldEnum
    having?: study_seatScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Study_seatCountAggregateInputType | true
    _min?: Study_seatMinAggregateInputType
    _max?: Study_seatMaxAggregateInputType
  }

  export type Study_seatGroupByOutputType = {
    uid: string
    createAt: Date
    updateAt: Date
    seatNumber: string
    roomId: string
    status: boolean
    _count: Study_seatCountAggregateOutputType | null
    _min: Study_seatMinAggregateOutputType | null
    _max: Study_seatMaxAggregateOutputType | null
  }

  type GetStudy_seatGroupByPayload<T extends study_seatGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Study_seatGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Study_seatGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Study_seatGroupByOutputType[P]>
            : GetScalarType<T[P], Study_seatGroupByOutputType[P]>
        }
      >
    >


  export type study_seatSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    uid?: boolean
    createAt?: boolean
    updateAt?: boolean
    seatNumber?: boolean
    roomId?: boolean
    status?: boolean
    room?: boolean | study_roomDefaultArgs<ExtArgs>
    reservations?: boolean | study_seat$reservationsArgs<ExtArgs>
    _count?: boolean | Study_seatCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["study_seat"]>



  export type study_seatSelectScalar = {
    uid?: boolean
    createAt?: boolean
    updateAt?: boolean
    seatNumber?: boolean
    roomId?: boolean
    status?: boolean
  }

  export type study_seatOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"uid" | "createAt" | "updateAt" | "seatNumber" | "roomId" | "status", ExtArgs["result"]["study_seat"]>
  export type study_seatInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    room?: boolean | study_roomDefaultArgs<ExtArgs>
    reservations?: boolean | study_seat$reservationsArgs<ExtArgs>
    _count?: boolean | Study_seatCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $study_seatPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "study_seat"
    objects: {
      room: Prisma.$study_roomPayload<ExtArgs>
      reservations: Prisma.$study_reservationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      uid: string
      createAt: Date
      updateAt: Date
      seatNumber: string
      roomId: string
      status: boolean
    }, ExtArgs["result"]["study_seat"]>
    composites: {}
  }

  type study_seatGetPayload<S extends boolean | null | undefined | study_seatDefaultArgs> = $Result.GetResult<Prisma.$study_seatPayload, S>

  type study_seatCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<study_seatFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Study_seatCountAggregateInputType | true
    }

  export interface study_seatDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['study_seat'], meta: { name: 'study_seat' } }
    /**
     * Find zero or one Study_seat that matches the filter.
     * @param {study_seatFindUniqueArgs} args - Arguments to find a Study_seat
     * @example
     * // Get one Study_seat
     * const study_seat = await prisma.study_seat.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends study_seatFindUniqueArgs>(args: SelectSubset<T, study_seatFindUniqueArgs<ExtArgs>>): Prisma__study_seatClient<$Result.GetResult<Prisma.$study_seatPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Study_seat that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {study_seatFindUniqueOrThrowArgs} args - Arguments to find a Study_seat
     * @example
     * // Get one Study_seat
     * const study_seat = await prisma.study_seat.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends study_seatFindUniqueOrThrowArgs>(args: SelectSubset<T, study_seatFindUniqueOrThrowArgs<ExtArgs>>): Prisma__study_seatClient<$Result.GetResult<Prisma.$study_seatPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Study_seat that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {study_seatFindFirstArgs} args - Arguments to find a Study_seat
     * @example
     * // Get one Study_seat
     * const study_seat = await prisma.study_seat.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends study_seatFindFirstArgs>(args?: SelectSubset<T, study_seatFindFirstArgs<ExtArgs>>): Prisma__study_seatClient<$Result.GetResult<Prisma.$study_seatPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Study_seat that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {study_seatFindFirstOrThrowArgs} args - Arguments to find a Study_seat
     * @example
     * // Get one Study_seat
     * const study_seat = await prisma.study_seat.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends study_seatFindFirstOrThrowArgs>(args?: SelectSubset<T, study_seatFindFirstOrThrowArgs<ExtArgs>>): Prisma__study_seatClient<$Result.GetResult<Prisma.$study_seatPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Study_seats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {study_seatFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Study_seats
     * const study_seats = await prisma.study_seat.findMany()
     * 
     * // Get first 10 Study_seats
     * const study_seats = await prisma.study_seat.findMany({ take: 10 })
     * 
     * // Only select the `uid`
     * const study_seatWithUidOnly = await prisma.study_seat.findMany({ select: { uid: true } })
     * 
     */
    findMany<T extends study_seatFindManyArgs>(args?: SelectSubset<T, study_seatFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$study_seatPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Study_seat.
     * @param {study_seatCreateArgs} args - Arguments to create a Study_seat.
     * @example
     * // Create one Study_seat
     * const Study_seat = await prisma.study_seat.create({
     *   data: {
     *     // ... data to create a Study_seat
     *   }
     * })
     * 
     */
    create<T extends study_seatCreateArgs>(args: SelectSubset<T, study_seatCreateArgs<ExtArgs>>): Prisma__study_seatClient<$Result.GetResult<Prisma.$study_seatPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Study_seats.
     * @param {study_seatCreateManyArgs} args - Arguments to create many Study_seats.
     * @example
     * // Create many Study_seats
     * const study_seat = await prisma.study_seat.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends study_seatCreateManyArgs>(args?: SelectSubset<T, study_seatCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Study_seat.
     * @param {study_seatDeleteArgs} args - Arguments to delete one Study_seat.
     * @example
     * // Delete one Study_seat
     * const Study_seat = await prisma.study_seat.delete({
     *   where: {
     *     // ... filter to delete one Study_seat
     *   }
     * })
     * 
     */
    delete<T extends study_seatDeleteArgs>(args: SelectSubset<T, study_seatDeleteArgs<ExtArgs>>): Prisma__study_seatClient<$Result.GetResult<Prisma.$study_seatPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Study_seat.
     * @param {study_seatUpdateArgs} args - Arguments to update one Study_seat.
     * @example
     * // Update one Study_seat
     * const study_seat = await prisma.study_seat.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends study_seatUpdateArgs>(args: SelectSubset<T, study_seatUpdateArgs<ExtArgs>>): Prisma__study_seatClient<$Result.GetResult<Prisma.$study_seatPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Study_seats.
     * @param {study_seatDeleteManyArgs} args - Arguments to filter Study_seats to delete.
     * @example
     * // Delete a few Study_seats
     * const { count } = await prisma.study_seat.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends study_seatDeleteManyArgs>(args?: SelectSubset<T, study_seatDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Study_seats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {study_seatUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Study_seats
     * const study_seat = await prisma.study_seat.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends study_seatUpdateManyArgs>(args: SelectSubset<T, study_seatUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Study_seat.
     * @param {study_seatUpsertArgs} args - Arguments to update or create a Study_seat.
     * @example
     * // Update or create a Study_seat
     * const study_seat = await prisma.study_seat.upsert({
     *   create: {
     *     // ... data to create a Study_seat
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Study_seat we want to update
     *   }
     * })
     */
    upsert<T extends study_seatUpsertArgs>(args: SelectSubset<T, study_seatUpsertArgs<ExtArgs>>): Prisma__study_seatClient<$Result.GetResult<Prisma.$study_seatPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Study_seats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {study_seatCountArgs} args - Arguments to filter Study_seats to count.
     * @example
     * // Count the number of Study_seats
     * const count = await prisma.study_seat.count({
     *   where: {
     *     // ... the filter for the Study_seats we want to count
     *   }
     * })
    **/
    count<T extends study_seatCountArgs>(
      args?: Subset<T, study_seatCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Study_seatCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Study_seat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Study_seatAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Study_seatAggregateArgs>(args: Subset<T, Study_seatAggregateArgs>): Prisma.PrismaPromise<GetStudy_seatAggregateType<T>>

    /**
     * Group by Study_seat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {study_seatGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends study_seatGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: study_seatGroupByArgs['orderBy'] }
        : { orderBy?: study_seatGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, study_seatGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudy_seatGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the study_seat model
   */
  readonly fields: study_seatFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for study_seat.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__study_seatClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    room<T extends study_roomDefaultArgs<ExtArgs> = {}>(args?: Subset<T, study_roomDefaultArgs<ExtArgs>>): Prisma__study_roomClient<$Result.GetResult<Prisma.$study_roomPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    reservations<T extends study_seat$reservationsArgs<ExtArgs> = {}>(args?: Subset<T, study_seat$reservationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$study_reservationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the study_seat model
   */
  interface study_seatFieldRefs {
    readonly uid: FieldRef<"study_seat", 'String'>
    readonly createAt: FieldRef<"study_seat", 'DateTime'>
    readonly updateAt: FieldRef<"study_seat", 'DateTime'>
    readonly seatNumber: FieldRef<"study_seat", 'String'>
    readonly roomId: FieldRef<"study_seat", 'String'>
    readonly status: FieldRef<"study_seat", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * study_seat findUnique
   */
  export type study_seatFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the study_seat
     */
    select?: study_seatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the study_seat
     */
    omit?: study_seatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: study_seatInclude<ExtArgs> | null
    /**
     * Filter, which study_seat to fetch.
     */
    where: study_seatWhereUniqueInput
  }

  /**
   * study_seat findUniqueOrThrow
   */
  export type study_seatFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the study_seat
     */
    select?: study_seatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the study_seat
     */
    omit?: study_seatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: study_seatInclude<ExtArgs> | null
    /**
     * Filter, which study_seat to fetch.
     */
    where: study_seatWhereUniqueInput
  }

  /**
   * study_seat findFirst
   */
  export type study_seatFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the study_seat
     */
    select?: study_seatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the study_seat
     */
    omit?: study_seatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: study_seatInclude<ExtArgs> | null
    /**
     * Filter, which study_seat to fetch.
     */
    where?: study_seatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of study_seats to fetch.
     */
    orderBy?: study_seatOrderByWithRelationInput | study_seatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for study_seats.
     */
    cursor?: study_seatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` study_seats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` study_seats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of study_seats.
     */
    distinct?: Study_seatScalarFieldEnum | Study_seatScalarFieldEnum[]
  }

  /**
   * study_seat findFirstOrThrow
   */
  export type study_seatFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the study_seat
     */
    select?: study_seatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the study_seat
     */
    omit?: study_seatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: study_seatInclude<ExtArgs> | null
    /**
     * Filter, which study_seat to fetch.
     */
    where?: study_seatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of study_seats to fetch.
     */
    orderBy?: study_seatOrderByWithRelationInput | study_seatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for study_seats.
     */
    cursor?: study_seatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` study_seats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` study_seats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of study_seats.
     */
    distinct?: Study_seatScalarFieldEnum | Study_seatScalarFieldEnum[]
  }

  /**
   * study_seat findMany
   */
  export type study_seatFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the study_seat
     */
    select?: study_seatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the study_seat
     */
    omit?: study_seatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: study_seatInclude<ExtArgs> | null
    /**
     * Filter, which study_seats to fetch.
     */
    where?: study_seatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of study_seats to fetch.
     */
    orderBy?: study_seatOrderByWithRelationInput | study_seatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing study_seats.
     */
    cursor?: study_seatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` study_seats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` study_seats.
     */
    skip?: number
    distinct?: Study_seatScalarFieldEnum | Study_seatScalarFieldEnum[]
  }

  /**
   * study_seat create
   */
  export type study_seatCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the study_seat
     */
    select?: study_seatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the study_seat
     */
    omit?: study_seatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: study_seatInclude<ExtArgs> | null
    /**
     * The data needed to create a study_seat.
     */
    data: XOR<study_seatCreateInput, study_seatUncheckedCreateInput>
  }

  /**
   * study_seat createMany
   */
  export type study_seatCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many study_seats.
     */
    data: study_seatCreateManyInput | study_seatCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * study_seat update
   */
  export type study_seatUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the study_seat
     */
    select?: study_seatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the study_seat
     */
    omit?: study_seatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: study_seatInclude<ExtArgs> | null
    /**
     * The data needed to update a study_seat.
     */
    data: XOR<study_seatUpdateInput, study_seatUncheckedUpdateInput>
    /**
     * Choose, which study_seat to update.
     */
    where: study_seatWhereUniqueInput
  }

  /**
   * study_seat updateMany
   */
  export type study_seatUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update study_seats.
     */
    data: XOR<study_seatUpdateManyMutationInput, study_seatUncheckedUpdateManyInput>
    /**
     * Filter which study_seats to update
     */
    where?: study_seatWhereInput
    /**
     * Limit how many study_seats to update.
     */
    limit?: number
  }

  /**
   * study_seat upsert
   */
  export type study_seatUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the study_seat
     */
    select?: study_seatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the study_seat
     */
    omit?: study_seatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: study_seatInclude<ExtArgs> | null
    /**
     * The filter to search for the study_seat to update in case it exists.
     */
    where: study_seatWhereUniqueInput
    /**
     * In case the study_seat found by the `where` argument doesn't exist, create a new study_seat with this data.
     */
    create: XOR<study_seatCreateInput, study_seatUncheckedCreateInput>
    /**
     * In case the study_seat was found with the provided `where` argument, update it with this data.
     */
    update: XOR<study_seatUpdateInput, study_seatUncheckedUpdateInput>
  }

  /**
   * study_seat delete
   */
  export type study_seatDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the study_seat
     */
    select?: study_seatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the study_seat
     */
    omit?: study_seatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: study_seatInclude<ExtArgs> | null
    /**
     * Filter which study_seat to delete.
     */
    where: study_seatWhereUniqueInput
  }

  /**
   * study_seat deleteMany
   */
  export type study_seatDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which study_seats to delete
     */
    where?: study_seatWhereInput
    /**
     * Limit how many study_seats to delete.
     */
    limit?: number
  }

  /**
   * study_seat.reservations
   */
  export type study_seat$reservationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the study_reservation
     */
    select?: study_reservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the study_reservation
     */
    omit?: study_reservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: study_reservationInclude<ExtArgs> | null
    where?: study_reservationWhereInput
    orderBy?: study_reservationOrderByWithRelationInput | study_reservationOrderByWithRelationInput[]
    cursor?: study_reservationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Study_reservationScalarFieldEnum | Study_reservationScalarFieldEnum[]
  }

  /**
   * study_seat without action
   */
  export type study_seatDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the study_seat
     */
    select?: study_seatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the study_seat
     */
    omit?: study_seatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: study_seatInclude<ExtArgs> | null
  }


  /**
   * Model study_reservation
   */

  export type AggregateStudy_reservation = {
    _count: Study_reservationCountAggregateOutputType | null
    _min: Study_reservationMinAggregateOutputType | null
    _max: Study_reservationMaxAggregateOutputType | null
  }

  export type Study_reservationMinAggregateOutputType = {
    uid: string | null
    createAt: Date | null
    updateAt: Date | null
    userId: string | null
    seatId: string | null
    startTime: Date | null
    endTime: Date | null
    status: string | null
  }

  export type Study_reservationMaxAggregateOutputType = {
    uid: string | null
    createAt: Date | null
    updateAt: Date | null
    userId: string | null
    seatId: string | null
    startTime: Date | null
    endTime: Date | null
    status: string | null
  }

  export type Study_reservationCountAggregateOutputType = {
    uid: number
    createAt: number
    updateAt: number
    userId: number
    seatId: number
    startTime: number
    endTime: number
    status: number
    _all: number
  }


  export type Study_reservationMinAggregateInputType = {
    uid?: true
    createAt?: true
    updateAt?: true
    userId?: true
    seatId?: true
    startTime?: true
    endTime?: true
    status?: true
  }

  export type Study_reservationMaxAggregateInputType = {
    uid?: true
    createAt?: true
    updateAt?: true
    userId?: true
    seatId?: true
    startTime?: true
    endTime?: true
    status?: true
  }

  export type Study_reservationCountAggregateInputType = {
    uid?: true
    createAt?: true
    updateAt?: true
    userId?: true
    seatId?: true
    startTime?: true
    endTime?: true
    status?: true
    _all?: true
  }

  export type Study_reservationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which study_reservation to aggregate.
     */
    where?: study_reservationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of study_reservations to fetch.
     */
    orderBy?: study_reservationOrderByWithRelationInput | study_reservationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: study_reservationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` study_reservations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` study_reservations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned study_reservations
    **/
    _count?: true | Study_reservationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Study_reservationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Study_reservationMaxAggregateInputType
  }

  export type GetStudy_reservationAggregateType<T extends Study_reservationAggregateArgs> = {
        [P in keyof T & keyof AggregateStudy_reservation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudy_reservation[P]>
      : GetScalarType<T[P], AggregateStudy_reservation[P]>
  }




  export type study_reservationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: study_reservationWhereInput
    orderBy?: study_reservationOrderByWithAggregationInput | study_reservationOrderByWithAggregationInput[]
    by: Study_reservationScalarFieldEnum[] | Study_reservationScalarFieldEnum
    having?: study_reservationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Study_reservationCountAggregateInputType | true
    _min?: Study_reservationMinAggregateInputType
    _max?: Study_reservationMaxAggregateInputType
  }

  export type Study_reservationGroupByOutputType = {
    uid: string
    createAt: Date
    updateAt: Date
    userId: string
    seatId: string
    startTime: Date
    endTime: Date
    status: string
    _count: Study_reservationCountAggregateOutputType | null
    _min: Study_reservationMinAggregateOutputType | null
    _max: Study_reservationMaxAggregateOutputType | null
  }

  type GetStudy_reservationGroupByPayload<T extends study_reservationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Study_reservationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Study_reservationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Study_reservationGroupByOutputType[P]>
            : GetScalarType<T[P], Study_reservationGroupByOutputType[P]>
        }
      >
    >


  export type study_reservationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    uid?: boolean
    createAt?: boolean
    updateAt?: boolean
    userId?: boolean
    seatId?: boolean
    startTime?: boolean
    endTime?: boolean
    status?: boolean
    user?: boolean | study_userDefaultArgs<ExtArgs>
    seat?: boolean | study_seatDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["study_reservation"]>



  export type study_reservationSelectScalar = {
    uid?: boolean
    createAt?: boolean
    updateAt?: boolean
    userId?: boolean
    seatId?: boolean
    startTime?: boolean
    endTime?: boolean
    status?: boolean
  }

  export type study_reservationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"uid" | "createAt" | "updateAt" | "userId" | "seatId" | "startTime" | "endTime" | "status", ExtArgs["result"]["study_reservation"]>
  export type study_reservationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | study_userDefaultArgs<ExtArgs>
    seat?: boolean | study_seatDefaultArgs<ExtArgs>
  }

  export type $study_reservationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "study_reservation"
    objects: {
      user: Prisma.$study_userPayload<ExtArgs>
      seat: Prisma.$study_seatPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      uid: string
      createAt: Date
      updateAt: Date
      userId: string
      seatId: string
      startTime: Date
      endTime: Date
      status: string
    }, ExtArgs["result"]["study_reservation"]>
    composites: {}
  }

  type study_reservationGetPayload<S extends boolean | null | undefined | study_reservationDefaultArgs> = $Result.GetResult<Prisma.$study_reservationPayload, S>

  type study_reservationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<study_reservationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Study_reservationCountAggregateInputType | true
    }

  export interface study_reservationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['study_reservation'], meta: { name: 'study_reservation' } }
    /**
     * Find zero or one Study_reservation that matches the filter.
     * @param {study_reservationFindUniqueArgs} args - Arguments to find a Study_reservation
     * @example
     * // Get one Study_reservation
     * const study_reservation = await prisma.study_reservation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends study_reservationFindUniqueArgs>(args: SelectSubset<T, study_reservationFindUniqueArgs<ExtArgs>>): Prisma__study_reservationClient<$Result.GetResult<Prisma.$study_reservationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Study_reservation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {study_reservationFindUniqueOrThrowArgs} args - Arguments to find a Study_reservation
     * @example
     * // Get one Study_reservation
     * const study_reservation = await prisma.study_reservation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends study_reservationFindUniqueOrThrowArgs>(args: SelectSubset<T, study_reservationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__study_reservationClient<$Result.GetResult<Prisma.$study_reservationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Study_reservation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {study_reservationFindFirstArgs} args - Arguments to find a Study_reservation
     * @example
     * // Get one Study_reservation
     * const study_reservation = await prisma.study_reservation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends study_reservationFindFirstArgs>(args?: SelectSubset<T, study_reservationFindFirstArgs<ExtArgs>>): Prisma__study_reservationClient<$Result.GetResult<Prisma.$study_reservationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Study_reservation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {study_reservationFindFirstOrThrowArgs} args - Arguments to find a Study_reservation
     * @example
     * // Get one Study_reservation
     * const study_reservation = await prisma.study_reservation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends study_reservationFindFirstOrThrowArgs>(args?: SelectSubset<T, study_reservationFindFirstOrThrowArgs<ExtArgs>>): Prisma__study_reservationClient<$Result.GetResult<Prisma.$study_reservationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Study_reservations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {study_reservationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Study_reservations
     * const study_reservations = await prisma.study_reservation.findMany()
     * 
     * // Get first 10 Study_reservations
     * const study_reservations = await prisma.study_reservation.findMany({ take: 10 })
     * 
     * // Only select the `uid`
     * const study_reservationWithUidOnly = await prisma.study_reservation.findMany({ select: { uid: true } })
     * 
     */
    findMany<T extends study_reservationFindManyArgs>(args?: SelectSubset<T, study_reservationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$study_reservationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Study_reservation.
     * @param {study_reservationCreateArgs} args - Arguments to create a Study_reservation.
     * @example
     * // Create one Study_reservation
     * const Study_reservation = await prisma.study_reservation.create({
     *   data: {
     *     // ... data to create a Study_reservation
     *   }
     * })
     * 
     */
    create<T extends study_reservationCreateArgs>(args: SelectSubset<T, study_reservationCreateArgs<ExtArgs>>): Prisma__study_reservationClient<$Result.GetResult<Prisma.$study_reservationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Study_reservations.
     * @param {study_reservationCreateManyArgs} args - Arguments to create many Study_reservations.
     * @example
     * // Create many Study_reservations
     * const study_reservation = await prisma.study_reservation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends study_reservationCreateManyArgs>(args?: SelectSubset<T, study_reservationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Study_reservation.
     * @param {study_reservationDeleteArgs} args - Arguments to delete one Study_reservation.
     * @example
     * // Delete one Study_reservation
     * const Study_reservation = await prisma.study_reservation.delete({
     *   where: {
     *     // ... filter to delete one Study_reservation
     *   }
     * })
     * 
     */
    delete<T extends study_reservationDeleteArgs>(args: SelectSubset<T, study_reservationDeleteArgs<ExtArgs>>): Prisma__study_reservationClient<$Result.GetResult<Prisma.$study_reservationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Study_reservation.
     * @param {study_reservationUpdateArgs} args - Arguments to update one Study_reservation.
     * @example
     * // Update one Study_reservation
     * const study_reservation = await prisma.study_reservation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends study_reservationUpdateArgs>(args: SelectSubset<T, study_reservationUpdateArgs<ExtArgs>>): Prisma__study_reservationClient<$Result.GetResult<Prisma.$study_reservationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Study_reservations.
     * @param {study_reservationDeleteManyArgs} args - Arguments to filter Study_reservations to delete.
     * @example
     * // Delete a few Study_reservations
     * const { count } = await prisma.study_reservation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends study_reservationDeleteManyArgs>(args?: SelectSubset<T, study_reservationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Study_reservations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {study_reservationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Study_reservations
     * const study_reservation = await prisma.study_reservation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends study_reservationUpdateManyArgs>(args: SelectSubset<T, study_reservationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Study_reservation.
     * @param {study_reservationUpsertArgs} args - Arguments to update or create a Study_reservation.
     * @example
     * // Update or create a Study_reservation
     * const study_reservation = await prisma.study_reservation.upsert({
     *   create: {
     *     // ... data to create a Study_reservation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Study_reservation we want to update
     *   }
     * })
     */
    upsert<T extends study_reservationUpsertArgs>(args: SelectSubset<T, study_reservationUpsertArgs<ExtArgs>>): Prisma__study_reservationClient<$Result.GetResult<Prisma.$study_reservationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Study_reservations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {study_reservationCountArgs} args - Arguments to filter Study_reservations to count.
     * @example
     * // Count the number of Study_reservations
     * const count = await prisma.study_reservation.count({
     *   where: {
     *     // ... the filter for the Study_reservations we want to count
     *   }
     * })
    **/
    count<T extends study_reservationCountArgs>(
      args?: Subset<T, study_reservationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Study_reservationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Study_reservation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Study_reservationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Study_reservationAggregateArgs>(args: Subset<T, Study_reservationAggregateArgs>): Prisma.PrismaPromise<GetStudy_reservationAggregateType<T>>

    /**
     * Group by Study_reservation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {study_reservationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends study_reservationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: study_reservationGroupByArgs['orderBy'] }
        : { orderBy?: study_reservationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, study_reservationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudy_reservationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the study_reservation model
   */
  readonly fields: study_reservationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for study_reservation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__study_reservationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends study_userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, study_userDefaultArgs<ExtArgs>>): Prisma__study_userClient<$Result.GetResult<Prisma.$study_userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    seat<T extends study_seatDefaultArgs<ExtArgs> = {}>(args?: Subset<T, study_seatDefaultArgs<ExtArgs>>): Prisma__study_seatClient<$Result.GetResult<Prisma.$study_seatPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the study_reservation model
   */
  interface study_reservationFieldRefs {
    readonly uid: FieldRef<"study_reservation", 'String'>
    readonly createAt: FieldRef<"study_reservation", 'DateTime'>
    readonly updateAt: FieldRef<"study_reservation", 'DateTime'>
    readonly userId: FieldRef<"study_reservation", 'String'>
    readonly seatId: FieldRef<"study_reservation", 'String'>
    readonly startTime: FieldRef<"study_reservation", 'DateTime'>
    readonly endTime: FieldRef<"study_reservation", 'DateTime'>
    readonly status: FieldRef<"study_reservation", 'String'>
  }
    

  // Custom InputTypes
  /**
   * study_reservation findUnique
   */
  export type study_reservationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the study_reservation
     */
    select?: study_reservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the study_reservation
     */
    omit?: study_reservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: study_reservationInclude<ExtArgs> | null
    /**
     * Filter, which study_reservation to fetch.
     */
    where: study_reservationWhereUniqueInput
  }

  /**
   * study_reservation findUniqueOrThrow
   */
  export type study_reservationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the study_reservation
     */
    select?: study_reservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the study_reservation
     */
    omit?: study_reservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: study_reservationInclude<ExtArgs> | null
    /**
     * Filter, which study_reservation to fetch.
     */
    where: study_reservationWhereUniqueInput
  }

  /**
   * study_reservation findFirst
   */
  export type study_reservationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the study_reservation
     */
    select?: study_reservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the study_reservation
     */
    omit?: study_reservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: study_reservationInclude<ExtArgs> | null
    /**
     * Filter, which study_reservation to fetch.
     */
    where?: study_reservationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of study_reservations to fetch.
     */
    orderBy?: study_reservationOrderByWithRelationInput | study_reservationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for study_reservations.
     */
    cursor?: study_reservationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` study_reservations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` study_reservations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of study_reservations.
     */
    distinct?: Study_reservationScalarFieldEnum | Study_reservationScalarFieldEnum[]
  }

  /**
   * study_reservation findFirstOrThrow
   */
  export type study_reservationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the study_reservation
     */
    select?: study_reservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the study_reservation
     */
    omit?: study_reservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: study_reservationInclude<ExtArgs> | null
    /**
     * Filter, which study_reservation to fetch.
     */
    where?: study_reservationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of study_reservations to fetch.
     */
    orderBy?: study_reservationOrderByWithRelationInput | study_reservationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for study_reservations.
     */
    cursor?: study_reservationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` study_reservations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` study_reservations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of study_reservations.
     */
    distinct?: Study_reservationScalarFieldEnum | Study_reservationScalarFieldEnum[]
  }

  /**
   * study_reservation findMany
   */
  export type study_reservationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the study_reservation
     */
    select?: study_reservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the study_reservation
     */
    omit?: study_reservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: study_reservationInclude<ExtArgs> | null
    /**
     * Filter, which study_reservations to fetch.
     */
    where?: study_reservationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of study_reservations to fetch.
     */
    orderBy?: study_reservationOrderByWithRelationInput | study_reservationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing study_reservations.
     */
    cursor?: study_reservationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` study_reservations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` study_reservations.
     */
    skip?: number
    distinct?: Study_reservationScalarFieldEnum | Study_reservationScalarFieldEnum[]
  }

  /**
   * study_reservation create
   */
  export type study_reservationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the study_reservation
     */
    select?: study_reservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the study_reservation
     */
    omit?: study_reservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: study_reservationInclude<ExtArgs> | null
    /**
     * The data needed to create a study_reservation.
     */
    data: XOR<study_reservationCreateInput, study_reservationUncheckedCreateInput>
  }

  /**
   * study_reservation createMany
   */
  export type study_reservationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many study_reservations.
     */
    data: study_reservationCreateManyInput | study_reservationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * study_reservation update
   */
  export type study_reservationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the study_reservation
     */
    select?: study_reservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the study_reservation
     */
    omit?: study_reservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: study_reservationInclude<ExtArgs> | null
    /**
     * The data needed to update a study_reservation.
     */
    data: XOR<study_reservationUpdateInput, study_reservationUncheckedUpdateInput>
    /**
     * Choose, which study_reservation to update.
     */
    where: study_reservationWhereUniqueInput
  }

  /**
   * study_reservation updateMany
   */
  export type study_reservationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update study_reservations.
     */
    data: XOR<study_reservationUpdateManyMutationInput, study_reservationUncheckedUpdateManyInput>
    /**
     * Filter which study_reservations to update
     */
    where?: study_reservationWhereInput
    /**
     * Limit how many study_reservations to update.
     */
    limit?: number
  }

  /**
   * study_reservation upsert
   */
  export type study_reservationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the study_reservation
     */
    select?: study_reservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the study_reservation
     */
    omit?: study_reservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: study_reservationInclude<ExtArgs> | null
    /**
     * The filter to search for the study_reservation to update in case it exists.
     */
    where: study_reservationWhereUniqueInput
    /**
     * In case the study_reservation found by the `where` argument doesn't exist, create a new study_reservation with this data.
     */
    create: XOR<study_reservationCreateInput, study_reservationUncheckedCreateInput>
    /**
     * In case the study_reservation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<study_reservationUpdateInput, study_reservationUncheckedUpdateInput>
  }

  /**
   * study_reservation delete
   */
  export type study_reservationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the study_reservation
     */
    select?: study_reservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the study_reservation
     */
    omit?: study_reservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: study_reservationInclude<ExtArgs> | null
    /**
     * Filter which study_reservation to delete.
     */
    where: study_reservationWhereUniqueInput
  }

  /**
   * study_reservation deleteMany
   */
  export type study_reservationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which study_reservations to delete
     */
    where?: study_reservationWhereInput
    /**
     * Limit how many study_reservations to delete.
     */
    limit?: number
  }

  /**
   * study_reservation without action
   */
  export type study_reservationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the study_reservation
     */
    select?: study_reservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the study_reservation
     */
    omit?: study_reservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: study_reservationInclude<ExtArgs> | null
  }


  /**
   * Model study_message
   */

  export type AggregateStudy_message = {
    _count: Study_messageCountAggregateOutputType | null
    _min: Study_messageMinAggregateOutputType | null
    _max: Study_messageMaxAggregateOutputType | null
  }

  export type Study_messageMinAggregateOutputType = {
    uid: string | null
    createAt: Date | null
    updateAt: Date | null
    userId: string | null
    content: string | null
    reply: string | null
    status: boolean | null
  }

  export type Study_messageMaxAggregateOutputType = {
    uid: string | null
    createAt: Date | null
    updateAt: Date | null
    userId: string | null
    content: string | null
    reply: string | null
    status: boolean | null
  }

  export type Study_messageCountAggregateOutputType = {
    uid: number
    createAt: number
    updateAt: number
    userId: number
    content: number
    reply: number
    status: number
    _all: number
  }


  export type Study_messageMinAggregateInputType = {
    uid?: true
    createAt?: true
    updateAt?: true
    userId?: true
    content?: true
    reply?: true
    status?: true
  }

  export type Study_messageMaxAggregateInputType = {
    uid?: true
    createAt?: true
    updateAt?: true
    userId?: true
    content?: true
    reply?: true
    status?: true
  }

  export type Study_messageCountAggregateInputType = {
    uid?: true
    createAt?: true
    updateAt?: true
    userId?: true
    content?: true
    reply?: true
    status?: true
    _all?: true
  }

  export type Study_messageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which study_message to aggregate.
     */
    where?: study_messageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of study_messages to fetch.
     */
    orderBy?: study_messageOrderByWithRelationInput | study_messageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: study_messageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` study_messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` study_messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned study_messages
    **/
    _count?: true | Study_messageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Study_messageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Study_messageMaxAggregateInputType
  }

  export type GetStudy_messageAggregateType<T extends Study_messageAggregateArgs> = {
        [P in keyof T & keyof AggregateStudy_message]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudy_message[P]>
      : GetScalarType<T[P], AggregateStudy_message[P]>
  }




  export type study_messageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: study_messageWhereInput
    orderBy?: study_messageOrderByWithAggregationInput | study_messageOrderByWithAggregationInput[]
    by: Study_messageScalarFieldEnum[] | Study_messageScalarFieldEnum
    having?: study_messageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Study_messageCountAggregateInputType | true
    _min?: Study_messageMinAggregateInputType
    _max?: Study_messageMaxAggregateInputType
  }

  export type Study_messageGroupByOutputType = {
    uid: string
    createAt: Date
    updateAt: Date
    userId: string
    content: string
    reply: string | null
    status: boolean
    _count: Study_messageCountAggregateOutputType | null
    _min: Study_messageMinAggregateOutputType | null
    _max: Study_messageMaxAggregateOutputType | null
  }

  type GetStudy_messageGroupByPayload<T extends study_messageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Study_messageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Study_messageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Study_messageGroupByOutputType[P]>
            : GetScalarType<T[P], Study_messageGroupByOutputType[P]>
        }
      >
    >


  export type study_messageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    uid?: boolean
    createAt?: boolean
    updateAt?: boolean
    userId?: boolean
    content?: boolean
    reply?: boolean
    status?: boolean
    user?: boolean | study_userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["study_message"]>



  export type study_messageSelectScalar = {
    uid?: boolean
    createAt?: boolean
    updateAt?: boolean
    userId?: boolean
    content?: boolean
    reply?: boolean
    status?: boolean
  }

  export type study_messageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"uid" | "createAt" | "updateAt" | "userId" | "content" | "reply" | "status", ExtArgs["result"]["study_message"]>
  export type study_messageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | study_userDefaultArgs<ExtArgs>
  }

  export type $study_messagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "study_message"
    objects: {
      user: Prisma.$study_userPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      uid: string
      createAt: Date
      updateAt: Date
      userId: string
      content: string
      reply: string | null
      status: boolean
    }, ExtArgs["result"]["study_message"]>
    composites: {}
  }

  type study_messageGetPayload<S extends boolean | null | undefined | study_messageDefaultArgs> = $Result.GetResult<Prisma.$study_messagePayload, S>

  type study_messageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<study_messageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Study_messageCountAggregateInputType | true
    }

  export interface study_messageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['study_message'], meta: { name: 'study_message' } }
    /**
     * Find zero or one Study_message that matches the filter.
     * @param {study_messageFindUniqueArgs} args - Arguments to find a Study_message
     * @example
     * // Get one Study_message
     * const study_message = await prisma.study_message.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends study_messageFindUniqueArgs>(args: SelectSubset<T, study_messageFindUniqueArgs<ExtArgs>>): Prisma__study_messageClient<$Result.GetResult<Prisma.$study_messagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Study_message that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {study_messageFindUniqueOrThrowArgs} args - Arguments to find a Study_message
     * @example
     * // Get one Study_message
     * const study_message = await prisma.study_message.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends study_messageFindUniqueOrThrowArgs>(args: SelectSubset<T, study_messageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__study_messageClient<$Result.GetResult<Prisma.$study_messagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Study_message that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {study_messageFindFirstArgs} args - Arguments to find a Study_message
     * @example
     * // Get one Study_message
     * const study_message = await prisma.study_message.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends study_messageFindFirstArgs>(args?: SelectSubset<T, study_messageFindFirstArgs<ExtArgs>>): Prisma__study_messageClient<$Result.GetResult<Prisma.$study_messagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Study_message that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {study_messageFindFirstOrThrowArgs} args - Arguments to find a Study_message
     * @example
     * // Get one Study_message
     * const study_message = await prisma.study_message.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends study_messageFindFirstOrThrowArgs>(args?: SelectSubset<T, study_messageFindFirstOrThrowArgs<ExtArgs>>): Prisma__study_messageClient<$Result.GetResult<Prisma.$study_messagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Study_messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {study_messageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Study_messages
     * const study_messages = await prisma.study_message.findMany()
     * 
     * // Get first 10 Study_messages
     * const study_messages = await prisma.study_message.findMany({ take: 10 })
     * 
     * // Only select the `uid`
     * const study_messageWithUidOnly = await prisma.study_message.findMany({ select: { uid: true } })
     * 
     */
    findMany<T extends study_messageFindManyArgs>(args?: SelectSubset<T, study_messageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$study_messagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Study_message.
     * @param {study_messageCreateArgs} args - Arguments to create a Study_message.
     * @example
     * // Create one Study_message
     * const Study_message = await prisma.study_message.create({
     *   data: {
     *     // ... data to create a Study_message
     *   }
     * })
     * 
     */
    create<T extends study_messageCreateArgs>(args: SelectSubset<T, study_messageCreateArgs<ExtArgs>>): Prisma__study_messageClient<$Result.GetResult<Prisma.$study_messagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Study_messages.
     * @param {study_messageCreateManyArgs} args - Arguments to create many Study_messages.
     * @example
     * // Create many Study_messages
     * const study_message = await prisma.study_message.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends study_messageCreateManyArgs>(args?: SelectSubset<T, study_messageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Study_message.
     * @param {study_messageDeleteArgs} args - Arguments to delete one Study_message.
     * @example
     * // Delete one Study_message
     * const Study_message = await prisma.study_message.delete({
     *   where: {
     *     // ... filter to delete one Study_message
     *   }
     * })
     * 
     */
    delete<T extends study_messageDeleteArgs>(args: SelectSubset<T, study_messageDeleteArgs<ExtArgs>>): Prisma__study_messageClient<$Result.GetResult<Prisma.$study_messagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Study_message.
     * @param {study_messageUpdateArgs} args - Arguments to update one Study_message.
     * @example
     * // Update one Study_message
     * const study_message = await prisma.study_message.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends study_messageUpdateArgs>(args: SelectSubset<T, study_messageUpdateArgs<ExtArgs>>): Prisma__study_messageClient<$Result.GetResult<Prisma.$study_messagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Study_messages.
     * @param {study_messageDeleteManyArgs} args - Arguments to filter Study_messages to delete.
     * @example
     * // Delete a few Study_messages
     * const { count } = await prisma.study_message.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends study_messageDeleteManyArgs>(args?: SelectSubset<T, study_messageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Study_messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {study_messageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Study_messages
     * const study_message = await prisma.study_message.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends study_messageUpdateManyArgs>(args: SelectSubset<T, study_messageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Study_message.
     * @param {study_messageUpsertArgs} args - Arguments to update or create a Study_message.
     * @example
     * // Update or create a Study_message
     * const study_message = await prisma.study_message.upsert({
     *   create: {
     *     // ... data to create a Study_message
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Study_message we want to update
     *   }
     * })
     */
    upsert<T extends study_messageUpsertArgs>(args: SelectSubset<T, study_messageUpsertArgs<ExtArgs>>): Prisma__study_messageClient<$Result.GetResult<Prisma.$study_messagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Study_messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {study_messageCountArgs} args - Arguments to filter Study_messages to count.
     * @example
     * // Count the number of Study_messages
     * const count = await prisma.study_message.count({
     *   where: {
     *     // ... the filter for the Study_messages we want to count
     *   }
     * })
    **/
    count<T extends study_messageCountArgs>(
      args?: Subset<T, study_messageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Study_messageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Study_message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Study_messageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Study_messageAggregateArgs>(args: Subset<T, Study_messageAggregateArgs>): Prisma.PrismaPromise<GetStudy_messageAggregateType<T>>

    /**
     * Group by Study_message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {study_messageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends study_messageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: study_messageGroupByArgs['orderBy'] }
        : { orderBy?: study_messageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, study_messageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudy_messageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the study_message model
   */
  readonly fields: study_messageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for study_message.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__study_messageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends study_userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, study_userDefaultArgs<ExtArgs>>): Prisma__study_userClient<$Result.GetResult<Prisma.$study_userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the study_message model
   */
  interface study_messageFieldRefs {
    readonly uid: FieldRef<"study_message", 'String'>
    readonly createAt: FieldRef<"study_message", 'DateTime'>
    readonly updateAt: FieldRef<"study_message", 'DateTime'>
    readonly userId: FieldRef<"study_message", 'String'>
    readonly content: FieldRef<"study_message", 'String'>
    readonly reply: FieldRef<"study_message", 'String'>
    readonly status: FieldRef<"study_message", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * study_message findUnique
   */
  export type study_messageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the study_message
     */
    select?: study_messageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the study_message
     */
    omit?: study_messageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: study_messageInclude<ExtArgs> | null
    /**
     * Filter, which study_message to fetch.
     */
    where: study_messageWhereUniqueInput
  }

  /**
   * study_message findUniqueOrThrow
   */
  export type study_messageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the study_message
     */
    select?: study_messageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the study_message
     */
    omit?: study_messageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: study_messageInclude<ExtArgs> | null
    /**
     * Filter, which study_message to fetch.
     */
    where: study_messageWhereUniqueInput
  }

  /**
   * study_message findFirst
   */
  export type study_messageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the study_message
     */
    select?: study_messageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the study_message
     */
    omit?: study_messageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: study_messageInclude<ExtArgs> | null
    /**
     * Filter, which study_message to fetch.
     */
    where?: study_messageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of study_messages to fetch.
     */
    orderBy?: study_messageOrderByWithRelationInput | study_messageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for study_messages.
     */
    cursor?: study_messageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` study_messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` study_messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of study_messages.
     */
    distinct?: Study_messageScalarFieldEnum | Study_messageScalarFieldEnum[]
  }

  /**
   * study_message findFirstOrThrow
   */
  export type study_messageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the study_message
     */
    select?: study_messageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the study_message
     */
    omit?: study_messageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: study_messageInclude<ExtArgs> | null
    /**
     * Filter, which study_message to fetch.
     */
    where?: study_messageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of study_messages to fetch.
     */
    orderBy?: study_messageOrderByWithRelationInput | study_messageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for study_messages.
     */
    cursor?: study_messageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` study_messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` study_messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of study_messages.
     */
    distinct?: Study_messageScalarFieldEnum | Study_messageScalarFieldEnum[]
  }

  /**
   * study_message findMany
   */
  export type study_messageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the study_message
     */
    select?: study_messageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the study_message
     */
    omit?: study_messageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: study_messageInclude<ExtArgs> | null
    /**
     * Filter, which study_messages to fetch.
     */
    where?: study_messageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of study_messages to fetch.
     */
    orderBy?: study_messageOrderByWithRelationInput | study_messageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing study_messages.
     */
    cursor?: study_messageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` study_messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` study_messages.
     */
    skip?: number
    distinct?: Study_messageScalarFieldEnum | Study_messageScalarFieldEnum[]
  }

  /**
   * study_message create
   */
  export type study_messageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the study_message
     */
    select?: study_messageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the study_message
     */
    omit?: study_messageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: study_messageInclude<ExtArgs> | null
    /**
     * The data needed to create a study_message.
     */
    data: XOR<study_messageCreateInput, study_messageUncheckedCreateInput>
  }

  /**
   * study_message createMany
   */
  export type study_messageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many study_messages.
     */
    data: study_messageCreateManyInput | study_messageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * study_message update
   */
  export type study_messageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the study_message
     */
    select?: study_messageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the study_message
     */
    omit?: study_messageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: study_messageInclude<ExtArgs> | null
    /**
     * The data needed to update a study_message.
     */
    data: XOR<study_messageUpdateInput, study_messageUncheckedUpdateInput>
    /**
     * Choose, which study_message to update.
     */
    where: study_messageWhereUniqueInput
  }

  /**
   * study_message updateMany
   */
  export type study_messageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update study_messages.
     */
    data: XOR<study_messageUpdateManyMutationInput, study_messageUncheckedUpdateManyInput>
    /**
     * Filter which study_messages to update
     */
    where?: study_messageWhereInput
    /**
     * Limit how many study_messages to update.
     */
    limit?: number
  }

  /**
   * study_message upsert
   */
  export type study_messageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the study_message
     */
    select?: study_messageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the study_message
     */
    omit?: study_messageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: study_messageInclude<ExtArgs> | null
    /**
     * The filter to search for the study_message to update in case it exists.
     */
    where: study_messageWhereUniqueInput
    /**
     * In case the study_message found by the `where` argument doesn't exist, create a new study_message with this data.
     */
    create: XOR<study_messageCreateInput, study_messageUncheckedCreateInput>
    /**
     * In case the study_message was found with the provided `where` argument, update it with this data.
     */
    update: XOR<study_messageUpdateInput, study_messageUncheckedUpdateInput>
  }

  /**
   * study_message delete
   */
  export type study_messageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the study_message
     */
    select?: study_messageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the study_message
     */
    omit?: study_messageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: study_messageInclude<ExtArgs> | null
    /**
     * Filter which study_message to delete.
     */
    where: study_messageWhereUniqueInput
  }

  /**
   * study_message deleteMany
   */
  export type study_messageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which study_messages to delete
     */
    where?: study_messageWhereInput
    /**
     * Limit how many study_messages to delete.
     */
    limit?: number
  }

  /**
   * study_message without action
   */
  export type study_messageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the study_message
     */
    select?: study_messageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the study_message
     */
    omit?: study_messageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: study_messageInclude<ExtArgs> | null
  }


  /**
   * Model study_announcement
   */

  export type AggregateStudy_announcement = {
    _count: Study_announcementCountAggregateOutputType | null
    _min: Study_announcementMinAggregateOutputType | null
    _max: Study_announcementMaxAggregateOutputType | null
  }

  export type Study_announcementMinAggregateOutputType = {
    uid: string | null
    createAt: Date | null
    updateAt: Date | null
    title: string | null
    content: string | null
    status: boolean | null
  }

  export type Study_announcementMaxAggregateOutputType = {
    uid: string | null
    createAt: Date | null
    updateAt: Date | null
    title: string | null
    content: string | null
    status: boolean | null
  }

  export type Study_announcementCountAggregateOutputType = {
    uid: number
    createAt: number
    updateAt: number
    title: number
    content: number
    status: number
    _all: number
  }


  export type Study_announcementMinAggregateInputType = {
    uid?: true
    createAt?: true
    updateAt?: true
    title?: true
    content?: true
    status?: true
  }

  export type Study_announcementMaxAggregateInputType = {
    uid?: true
    createAt?: true
    updateAt?: true
    title?: true
    content?: true
    status?: true
  }

  export type Study_announcementCountAggregateInputType = {
    uid?: true
    createAt?: true
    updateAt?: true
    title?: true
    content?: true
    status?: true
    _all?: true
  }

  export type Study_announcementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which study_announcement to aggregate.
     */
    where?: study_announcementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of study_announcements to fetch.
     */
    orderBy?: study_announcementOrderByWithRelationInput | study_announcementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: study_announcementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` study_announcements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` study_announcements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned study_announcements
    **/
    _count?: true | Study_announcementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Study_announcementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Study_announcementMaxAggregateInputType
  }

  export type GetStudy_announcementAggregateType<T extends Study_announcementAggregateArgs> = {
        [P in keyof T & keyof AggregateStudy_announcement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudy_announcement[P]>
      : GetScalarType<T[P], AggregateStudy_announcement[P]>
  }




  export type study_announcementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: study_announcementWhereInput
    orderBy?: study_announcementOrderByWithAggregationInput | study_announcementOrderByWithAggregationInput[]
    by: Study_announcementScalarFieldEnum[] | Study_announcementScalarFieldEnum
    having?: study_announcementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Study_announcementCountAggregateInputType | true
    _min?: Study_announcementMinAggregateInputType
    _max?: Study_announcementMaxAggregateInputType
  }

  export type Study_announcementGroupByOutputType = {
    uid: string
    createAt: Date
    updateAt: Date
    title: string
    content: string
    status: boolean
    _count: Study_announcementCountAggregateOutputType | null
    _min: Study_announcementMinAggregateOutputType | null
    _max: Study_announcementMaxAggregateOutputType | null
  }

  type GetStudy_announcementGroupByPayload<T extends study_announcementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Study_announcementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Study_announcementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Study_announcementGroupByOutputType[P]>
            : GetScalarType<T[P], Study_announcementGroupByOutputType[P]>
        }
      >
    >


  export type study_announcementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    uid?: boolean
    createAt?: boolean
    updateAt?: boolean
    title?: boolean
    content?: boolean
    status?: boolean
  }, ExtArgs["result"]["study_announcement"]>



  export type study_announcementSelectScalar = {
    uid?: boolean
    createAt?: boolean
    updateAt?: boolean
    title?: boolean
    content?: boolean
    status?: boolean
  }

  export type study_announcementOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"uid" | "createAt" | "updateAt" | "title" | "content" | "status", ExtArgs["result"]["study_announcement"]>

  export type $study_announcementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "study_announcement"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      uid: string
      createAt: Date
      updateAt: Date
      title: string
      content: string
      status: boolean
    }, ExtArgs["result"]["study_announcement"]>
    composites: {}
  }

  type study_announcementGetPayload<S extends boolean | null | undefined | study_announcementDefaultArgs> = $Result.GetResult<Prisma.$study_announcementPayload, S>

  type study_announcementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<study_announcementFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Study_announcementCountAggregateInputType | true
    }

  export interface study_announcementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['study_announcement'], meta: { name: 'study_announcement' } }
    /**
     * Find zero or one Study_announcement that matches the filter.
     * @param {study_announcementFindUniqueArgs} args - Arguments to find a Study_announcement
     * @example
     * // Get one Study_announcement
     * const study_announcement = await prisma.study_announcement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends study_announcementFindUniqueArgs>(args: SelectSubset<T, study_announcementFindUniqueArgs<ExtArgs>>): Prisma__study_announcementClient<$Result.GetResult<Prisma.$study_announcementPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Study_announcement that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {study_announcementFindUniqueOrThrowArgs} args - Arguments to find a Study_announcement
     * @example
     * // Get one Study_announcement
     * const study_announcement = await prisma.study_announcement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends study_announcementFindUniqueOrThrowArgs>(args: SelectSubset<T, study_announcementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__study_announcementClient<$Result.GetResult<Prisma.$study_announcementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Study_announcement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {study_announcementFindFirstArgs} args - Arguments to find a Study_announcement
     * @example
     * // Get one Study_announcement
     * const study_announcement = await prisma.study_announcement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends study_announcementFindFirstArgs>(args?: SelectSubset<T, study_announcementFindFirstArgs<ExtArgs>>): Prisma__study_announcementClient<$Result.GetResult<Prisma.$study_announcementPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Study_announcement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {study_announcementFindFirstOrThrowArgs} args - Arguments to find a Study_announcement
     * @example
     * // Get one Study_announcement
     * const study_announcement = await prisma.study_announcement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends study_announcementFindFirstOrThrowArgs>(args?: SelectSubset<T, study_announcementFindFirstOrThrowArgs<ExtArgs>>): Prisma__study_announcementClient<$Result.GetResult<Prisma.$study_announcementPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Study_announcements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {study_announcementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Study_announcements
     * const study_announcements = await prisma.study_announcement.findMany()
     * 
     * // Get first 10 Study_announcements
     * const study_announcements = await prisma.study_announcement.findMany({ take: 10 })
     * 
     * // Only select the `uid`
     * const study_announcementWithUidOnly = await prisma.study_announcement.findMany({ select: { uid: true } })
     * 
     */
    findMany<T extends study_announcementFindManyArgs>(args?: SelectSubset<T, study_announcementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$study_announcementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Study_announcement.
     * @param {study_announcementCreateArgs} args - Arguments to create a Study_announcement.
     * @example
     * // Create one Study_announcement
     * const Study_announcement = await prisma.study_announcement.create({
     *   data: {
     *     // ... data to create a Study_announcement
     *   }
     * })
     * 
     */
    create<T extends study_announcementCreateArgs>(args: SelectSubset<T, study_announcementCreateArgs<ExtArgs>>): Prisma__study_announcementClient<$Result.GetResult<Prisma.$study_announcementPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Study_announcements.
     * @param {study_announcementCreateManyArgs} args - Arguments to create many Study_announcements.
     * @example
     * // Create many Study_announcements
     * const study_announcement = await prisma.study_announcement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends study_announcementCreateManyArgs>(args?: SelectSubset<T, study_announcementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Study_announcement.
     * @param {study_announcementDeleteArgs} args - Arguments to delete one Study_announcement.
     * @example
     * // Delete one Study_announcement
     * const Study_announcement = await prisma.study_announcement.delete({
     *   where: {
     *     // ... filter to delete one Study_announcement
     *   }
     * })
     * 
     */
    delete<T extends study_announcementDeleteArgs>(args: SelectSubset<T, study_announcementDeleteArgs<ExtArgs>>): Prisma__study_announcementClient<$Result.GetResult<Prisma.$study_announcementPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Study_announcement.
     * @param {study_announcementUpdateArgs} args - Arguments to update one Study_announcement.
     * @example
     * // Update one Study_announcement
     * const study_announcement = await prisma.study_announcement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends study_announcementUpdateArgs>(args: SelectSubset<T, study_announcementUpdateArgs<ExtArgs>>): Prisma__study_announcementClient<$Result.GetResult<Prisma.$study_announcementPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Study_announcements.
     * @param {study_announcementDeleteManyArgs} args - Arguments to filter Study_announcements to delete.
     * @example
     * // Delete a few Study_announcements
     * const { count } = await prisma.study_announcement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends study_announcementDeleteManyArgs>(args?: SelectSubset<T, study_announcementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Study_announcements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {study_announcementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Study_announcements
     * const study_announcement = await prisma.study_announcement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends study_announcementUpdateManyArgs>(args: SelectSubset<T, study_announcementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Study_announcement.
     * @param {study_announcementUpsertArgs} args - Arguments to update or create a Study_announcement.
     * @example
     * // Update or create a Study_announcement
     * const study_announcement = await prisma.study_announcement.upsert({
     *   create: {
     *     // ... data to create a Study_announcement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Study_announcement we want to update
     *   }
     * })
     */
    upsert<T extends study_announcementUpsertArgs>(args: SelectSubset<T, study_announcementUpsertArgs<ExtArgs>>): Prisma__study_announcementClient<$Result.GetResult<Prisma.$study_announcementPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Study_announcements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {study_announcementCountArgs} args - Arguments to filter Study_announcements to count.
     * @example
     * // Count the number of Study_announcements
     * const count = await prisma.study_announcement.count({
     *   where: {
     *     // ... the filter for the Study_announcements we want to count
     *   }
     * })
    **/
    count<T extends study_announcementCountArgs>(
      args?: Subset<T, study_announcementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Study_announcementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Study_announcement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Study_announcementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Study_announcementAggregateArgs>(args: Subset<T, Study_announcementAggregateArgs>): Prisma.PrismaPromise<GetStudy_announcementAggregateType<T>>

    /**
     * Group by Study_announcement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {study_announcementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends study_announcementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: study_announcementGroupByArgs['orderBy'] }
        : { orderBy?: study_announcementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, study_announcementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudy_announcementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the study_announcement model
   */
  readonly fields: study_announcementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for study_announcement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__study_announcementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the study_announcement model
   */
  interface study_announcementFieldRefs {
    readonly uid: FieldRef<"study_announcement", 'String'>
    readonly createAt: FieldRef<"study_announcement", 'DateTime'>
    readonly updateAt: FieldRef<"study_announcement", 'DateTime'>
    readonly title: FieldRef<"study_announcement", 'String'>
    readonly content: FieldRef<"study_announcement", 'String'>
    readonly status: FieldRef<"study_announcement", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * study_announcement findUnique
   */
  export type study_announcementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the study_announcement
     */
    select?: study_announcementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the study_announcement
     */
    omit?: study_announcementOmit<ExtArgs> | null
    /**
     * Filter, which study_announcement to fetch.
     */
    where: study_announcementWhereUniqueInput
  }

  /**
   * study_announcement findUniqueOrThrow
   */
  export type study_announcementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the study_announcement
     */
    select?: study_announcementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the study_announcement
     */
    omit?: study_announcementOmit<ExtArgs> | null
    /**
     * Filter, which study_announcement to fetch.
     */
    where: study_announcementWhereUniqueInput
  }

  /**
   * study_announcement findFirst
   */
  export type study_announcementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the study_announcement
     */
    select?: study_announcementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the study_announcement
     */
    omit?: study_announcementOmit<ExtArgs> | null
    /**
     * Filter, which study_announcement to fetch.
     */
    where?: study_announcementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of study_announcements to fetch.
     */
    orderBy?: study_announcementOrderByWithRelationInput | study_announcementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for study_announcements.
     */
    cursor?: study_announcementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` study_announcements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` study_announcements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of study_announcements.
     */
    distinct?: Study_announcementScalarFieldEnum | Study_announcementScalarFieldEnum[]
  }

  /**
   * study_announcement findFirstOrThrow
   */
  export type study_announcementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the study_announcement
     */
    select?: study_announcementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the study_announcement
     */
    omit?: study_announcementOmit<ExtArgs> | null
    /**
     * Filter, which study_announcement to fetch.
     */
    where?: study_announcementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of study_announcements to fetch.
     */
    orderBy?: study_announcementOrderByWithRelationInput | study_announcementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for study_announcements.
     */
    cursor?: study_announcementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` study_announcements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` study_announcements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of study_announcements.
     */
    distinct?: Study_announcementScalarFieldEnum | Study_announcementScalarFieldEnum[]
  }

  /**
   * study_announcement findMany
   */
  export type study_announcementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the study_announcement
     */
    select?: study_announcementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the study_announcement
     */
    omit?: study_announcementOmit<ExtArgs> | null
    /**
     * Filter, which study_announcements to fetch.
     */
    where?: study_announcementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of study_announcements to fetch.
     */
    orderBy?: study_announcementOrderByWithRelationInput | study_announcementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing study_announcements.
     */
    cursor?: study_announcementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` study_announcements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` study_announcements.
     */
    skip?: number
    distinct?: Study_announcementScalarFieldEnum | Study_announcementScalarFieldEnum[]
  }

  /**
   * study_announcement create
   */
  export type study_announcementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the study_announcement
     */
    select?: study_announcementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the study_announcement
     */
    omit?: study_announcementOmit<ExtArgs> | null
    /**
     * The data needed to create a study_announcement.
     */
    data: XOR<study_announcementCreateInput, study_announcementUncheckedCreateInput>
  }

  /**
   * study_announcement createMany
   */
  export type study_announcementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many study_announcements.
     */
    data: study_announcementCreateManyInput | study_announcementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * study_announcement update
   */
  export type study_announcementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the study_announcement
     */
    select?: study_announcementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the study_announcement
     */
    omit?: study_announcementOmit<ExtArgs> | null
    /**
     * The data needed to update a study_announcement.
     */
    data: XOR<study_announcementUpdateInput, study_announcementUncheckedUpdateInput>
    /**
     * Choose, which study_announcement to update.
     */
    where: study_announcementWhereUniqueInput
  }

  /**
   * study_announcement updateMany
   */
  export type study_announcementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update study_announcements.
     */
    data: XOR<study_announcementUpdateManyMutationInput, study_announcementUncheckedUpdateManyInput>
    /**
     * Filter which study_announcements to update
     */
    where?: study_announcementWhereInput
    /**
     * Limit how many study_announcements to update.
     */
    limit?: number
  }

  /**
   * study_announcement upsert
   */
  export type study_announcementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the study_announcement
     */
    select?: study_announcementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the study_announcement
     */
    omit?: study_announcementOmit<ExtArgs> | null
    /**
     * The filter to search for the study_announcement to update in case it exists.
     */
    where: study_announcementWhereUniqueInput
    /**
     * In case the study_announcement found by the `where` argument doesn't exist, create a new study_announcement with this data.
     */
    create: XOR<study_announcementCreateInput, study_announcementUncheckedCreateInput>
    /**
     * In case the study_announcement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<study_announcementUpdateInput, study_announcementUncheckedUpdateInput>
  }

  /**
   * study_announcement delete
   */
  export type study_announcementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the study_announcement
     */
    select?: study_announcementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the study_announcement
     */
    omit?: study_announcementOmit<ExtArgs> | null
    /**
     * Filter which study_announcement to delete.
     */
    where: study_announcementWhereUniqueInput
  }

  /**
   * study_announcement deleteMany
   */
  export type study_announcementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which study_announcements to delete
     */
    where?: study_announcementWhereInput
    /**
     * Limit how many study_announcements to delete.
     */
    limit?: number
  }

  /**
   * study_announcement without action
   */
  export type study_announcementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the study_announcement
     */
    select?: study_announcementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the study_announcement
     */
    omit?: study_announcementOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const Sys_userScalarFieldEnum: {
    uid: 'uid',
    createAt: 'createAt',
    updateAt: 'updateAt',
    name: 'name',
    password: 'password',
    salt: 'salt',
    roleId: 'roleId'
  };

  export type Sys_userScalarFieldEnum = (typeof Sys_userScalarFieldEnum)[keyof typeof Sys_userScalarFieldEnum]


  export const Sys_accountScalarFieldEnum: {
    createAt: 'createAt',
    updateAt: 'updateAt',
    provider: 'provider',
    provider_id: 'provider_id',
    userId: 'userId'
  };

  export type Sys_accountScalarFieldEnum = (typeof Sys_accountScalarFieldEnum)[keyof typeof Sys_accountScalarFieldEnum]


  export const Sys_menuScalarFieldEnum: {
    uid: 'uid',
    createAt: 'createAt',
    updateAt: 'updateAt',
    name: 'name',
    path: 'path',
    powers: 'powers',
    comment: 'comment',
    parentId: 'parentId'
  };

  export type Sys_menuScalarFieldEnum = (typeof Sys_menuScalarFieldEnum)[keyof typeof Sys_menuScalarFieldEnum]


  export const Sys_user_ban_menuScalarFieldEnum: {
    userId: 'userId',
    menuId: 'menuId'
  };

  export type Sys_user_ban_menuScalarFieldEnum = (typeof Sys_user_ban_menuScalarFieldEnum)[keyof typeof Sys_user_ban_menuScalarFieldEnum]


  export const Sys_menu_on_roleScalarFieldEnum: {
    roleId: 'roleId',
    menuId: 'menuId',
    power: 'power'
  };

  export type Sys_menu_on_roleScalarFieldEnum = (typeof Sys_menu_on_roleScalarFieldEnum)[keyof typeof Sys_menu_on_roleScalarFieldEnum]


  export const Sys_roleScalarFieldEnum: {
    uid: 'uid',
    createAt: 'createAt',
    updateAt: 'updateAt',
    name: 'name',
    status: 'status',
    comment: 'comment'
  };

  export type Sys_roleScalarFieldEnum = (typeof Sys_roleScalarFieldEnum)[keyof typeof Sys_roleScalarFieldEnum]


  export const Blog_userScalarFieldEnum: {
    uid: 'uid',
    createAt: 'createAt',
    updateAt: 'updateAt',
    name: 'name'
  };

  export type Blog_userScalarFieldEnum = (typeof Blog_userScalarFieldEnum)[keyof typeof Blog_userScalarFieldEnum]


  export const Blog_categoriesScalarFieldEnum: {
    uid: 'uid',
    createAt: 'createAt',
    updateAt: 'updateAt',
    name: 'name'
  };

  export type Blog_categoriesScalarFieldEnum = (typeof Blog_categoriesScalarFieldEnum)[keyof typeof Blog_categoriesScalarFieldEnum]


  export const Blog_postsScalarFieldEnum: {
    uid: 'uid',
    createAt: 'createAt',
    updateAt: 'updateAt',
    title: 'title',
    content: 'content',
    userId: 'userId',
    categoriesId: 'categoriesId'
  };

  export type Blog_postsScalarFieldEnum = (typeof Blog_postsScalarFieldEnum)[keyof typeof Blog_postsScalarFieldEnum]


  export const Blog_noticeScalarFieldEnum: {
    uid: 'uid',
    createAt: 'createAt',
    updateAt: 'updateAt'
  };

  export type Blog_noticeScalarFieldEnum = (typeof Blog_noticeScalarFieldEnum)[keyof typeof Blog_noticeScalarFieldEnum]


  export const Blog_posts_on_tagsScalarFieldEnum: {
    postsId: 'postsId',
    tagId: 'tagId'
  };

  export type Blog_posts_on_tagsScalarFieldEnum = (typeof Blog_posts_on_tagsScalarFieldEnum)[keyof typeof Blog_posts_on_tagsScalarFieldEnum]


  export const Blog_tagScalarFieldEnum: {
    uid: 'uid',
    createAt: 'createAt',
    updateAt: 'updateAt',
    name: 'name'
  };

  export type Blog_tagScalarFieldEnum = (typeof Blog_tagScalarFieldEnum)[keyof typeof Blog_tagScalarFieldEnum]


  export const File_userScalarFieldEnum: {
    uid: 'uid',
    createAt: 'createAt',
    updateAt: 'updateAt',
    name: 'name',
    is_admin: 'is_admin'
  };

  export type File_userScalarFieldEnum = (typeof File_userScalarFieldEnum)[keyof typeof File_userScalarFieldEnum]


  export const File_keysScalarFieldEnum: {
    api_key: 'api_key',
    api_secret: 'api_secret',
    userId: 'userId'
  };

  export type File_keysScalarFieldEnum = (typeof File_keysScalarFieldEnum)[keyof typeof File_keysScalarFieldEnum]


  export const File_configScalarFieldEnum: {
    uid: 'uid',
    userId: 'userId'
  };

  export type File_configScalarFieldEnum = (typeof File_configScalarFieldEnum)[keyof typeof File_configScalarFieldEnum]


  export const File_user_on_mediaScalarFieldEnum: {
    userId: 'userId',
    mediaId: 'mediaId',
    comment: 'comment'
  };

  export type File_user_on_mediaScalarFieldEnum = (typeof File_user_on_mediaScalarFieldEnum)[keyof typeof File_user_on_mediaScalarFieldEnum]


  export const File_blockScalarFieldEnum: {
    uid: 'uid',
    createAt: 'createAt',
    updateAt: 'updateAt',
    mediaId: 'mediaId',
    hash_key: 'hash_key',
    size: 'size'
  };

  export type File_blockScalarFieldEnum = (typeof File_blockScalarFieldEnum)[keyof typeof File_blockScalarFieldEnum]


  export const File_mediaScalarFieldEnum: {
    uid: 'uid',
    createAt: 'createAt',
    updateAt: 'updateAt',
    type: 'type',
    name: 'name',
    hash_key: 'hash_key',
    size: 'size',
    disable: 'disable',
    comment: 'comment'
  };

  export type File_mediaScalarFieldEnum = (typeof File_mediaScalarFieldEnum)[keyof typeof File_mediaScalarFieldEnum]


  export const File_media_on_folderScalarFieldEnum: {
    mediaId: 'mediaId',
    folderId: 'folderId'
  };

  export type File_media_on_folderScalarFieldEnum = (typeof File_media_on_folderScalarFieldEnum)[keyof typeof File_media_on_folderScalarFieldEnum]


  export const File_folderScalarFieldEnum: {
    uid: 'uid',
    createAt: 'createAt',
    updateAt: 'updateAt',
    name: 'name',
    userId: 'userId',
    parentId: 'parentId'
  };

  export type File_folderScalarFieldEnum = (typeof File_folderScalarFieldEnum)[keyof typeof File_folderScalarFieldEnum]


  export const Book_userScalarFieldEnum: {
    id: 'id',
    createAt: 'createAt',
    updateAt: 'updateAt',
    name: 'name',
    email: 'email',
    password: 'password',
    role: 'role',
    book_roleId: 'book_roleId'
  };

  export type Book_userScalarFieldEnum = (typeof Book_userScalarFieldEnum)[keyof typeof Book_userScalarFieldEnum]


  export const Book_bookScalarFieldEnum: {
    id: 'id',
    createAt: 'createAt',
    updateAt: 'updateAt',
    title: 'title',
    author: 'author',
    isbn: 'isbn',
    description: 'description',
    publication: 'publication',
    categoryId: 'categoryId',
    available: 'available'
  };

  export type Book_bookScalarFieldEnum = (typeof Book_bookScalarFieldEnum)[keyof typeof Book_bookScalarFieldEnum]


  export const Book_categoryScalarFieldEnum: {
    id: 'id',
    createAt: 'createAt',
    updateAt: 'updateAt',
    categoryName: 'categoryName'
  };

  export type Book_categoryScalarFieldEnum = (typeof Book_categoryScalarFieldEnum)[keyof typeof Book_categoryScalarFieldEnum]


  export const Book_borrowedScalarFieldEnum: {
    id: 'id',
    borrowDate: 'borrowDate',
    returnDate: 'returnDate',
    dueDate: 'dueDate',
    userId: 'userId',
    bookId: 'bookId',
    returned: 'returned'
  };

  export type Book_borrowedScalarFieldEnum = (typeof Book_borrowedScalarFieldEnum)[keyof typeof Book_borrowedScalarFieldEnum]


  export const Book_borrow_historyScalarFieldEnum: {
    id: 'id',
    borrowDate: 'borrowDate',
    returnDate: 'returnDate',
    userId: 'userId',
    bookId: 'bookId',
    returned: 'returned'
  };

  export type Book_borrow_historyScalarFieldEnum = (typeof Book_borrow_historyScalarFieldEnum)[keyof typeof Book_borrow_historyScalarFieldEnum]


  export const Book_ratingScalarFieldEnum: {
    id: 'id',
    createAt: 'createAt',
    updateAt: 'updateAt',
    rating: 'rating',
    review: 'review',
    userId: 'userId',
    bookId: 'bookId'
  };

  export type Book_ratingScalarFieldEnum = (typeof Book_ratingScalarFieldEnum)[keyof typeof Book_ratingScalarFieldEnum]


  export const Study_userScalarFieldEnum: {
    uid: 'uid',
    createAt: 'createAt',
    updateAt: 'updateAt',
    name: 'name',
    account: 'account',
    password: 'password',
    isAdmin: 'isAdmin'
  };

  export type Study_userScalarFieldEnum = (typeof Study_userScalarFieldEnum)[keyof typeof Study_userScalarFieldEnum]


  export const Study_storeScalarFieldEnum: {
    uid: 'uid',
    createAt: 'createAt',
    updateAt: 'updateAt',
    name: 'name',
    local: 'local',
    address: 'address',
    status: 'status',
    remark: 'remark'
  };

  export type Study_storeScalarFieldEnum = (typeof Study_storeScalarFieldEnum)[keyof typeof Study_storeScalarFieldEnum]


  export const Study_floorScalarFieldEnum: {
    uid: 'uid',
    createAt: 'createAt',
    updateAt: 'updateAt',
    floorNumber: 'floorNumber',
    storeId: 'storeId'
  };

  export type Study_floorScalarFieldEnum = (typeof Study_floorScalarFieldEnum)[keyof typeof Study_floorScalarFieldEnum]


  export const Study_roomScalarFieldEnum: {
    uid: 'uid',
    createAt: 'createAt',
    updateAt: 'updateAt',
    name: 'name',
    floorId: 'floorId',
    capacity: 'capacity',
    status: 'status'
  };

  export type Study_roomScalarFieldEnum = (typeof Study_roomScalarFieldEnum)[keyof typeof Study_roomScalarFieldEnum]


  export const Study_seatScalarFieldEnum: {
    uid: 'uid',
    createAt: 'createAt',
    updateAt: 'updateAt',
    seatNumber: 'seatNumber',
    roomId: 'roomId',
    status: 'status'
  };

  export type Study_seatScalarFieldEnum = (typeof Study_seatScalarFieldEnum)[keyof typeof Study_seatScalarFieldEnum]


  export const Study_reservationScalarFieldEnum: {
    uid: 'uid',
    createAt: 'createAt',
    updateAt: 'updateAt',
    userId: 'userId',
    seatId: 'seatId',
    startTime: 'startTime',
    endTime: 'endTime',
    status: 'status'
  };

  export type Study_reservationScalarFieldEnum = (typeof Study_reservationScalarFieldEnum)[keyof typeof Study_reservationScalarFieldEnum]


  export const Study_messageScalarFieldEnum: {
    uid: 'uid',
    createAt: 'createAt',
    updateAt: 'updateAt',
    userId: 'userId',
    content: 'content',
    reply: 'reply',
    status: 'status'
  };

  export type Study_messageScalarFieldEnum = (typeof Study_messageScalarFieldEnum)[keyof typeof Study_messageScalarFieldEnum]


  export const Study_announcementScalarFieldEnum: {
    uid: 'uid',
    createAt: 'createAt',
    updateAt: 'updateAt',
    title: 'title',
    content: 'content',
    status: 'status'
  };

  export type Study_announcementScalarFieldEnum = (typeof Study_announcementScalarFieldEnum)[keyof typeof Study_announcementScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const sys_userOrderByRelevanceFieldEnum: {
    uid: 'uid',
    name: 'name',
    password: 'password',
    salt: 'salt',
    roleId: 'roleId'
  };

  export type sys_userOrderByRelevanceFieldEnum = (typeof sys_userOrderByRelevanceFieldEnum)[keyof typeof sys_userOrderByRelevanceFieldEnum]


  export const sys_accountOrderByRelevanceFieldEnum: {
    provider_id: 'provider_id',
    userId: 'userId'
  };

  export type sys_accountOrderByRelevanceFieldEnum = (typeof sys_accountOrderByRelevanceFieldEnum)[keyof typeof sys_accountOrderByRelevanceFieldEnum]


  export const sys_menuOrderByRelevanceFieldEnum: {
    uid: 'uid',
    name: 'name',
    path: 'path',
    comment: 'comment',
    parentId: 'parentId'
  };

  export type sys_menuOrderByRelevanceFieldEnum = (typeof sys_menuOrderByRelevanceFieldEnum)[keyof typeof sys_menuOrderByRelevanceFieldEnum]


  export const sys_user_ban_menuOrderByRelevanceFieldEnum: {
    userId: 'userId',
    menuId: 'menuId'
  };

  export type sys_user_ban_menuOrderByRelevanceFieldEnum = (typeof sys_user_ban_menuOrderByRelevanceFieldEnum)[keyof typeof sys_user_ban_menuOrderByRelevanceFieldEnum]


  export const sys_menu_on_roleOrderByRelevanceFieldEnum: {
    roleId: 'roleId',
    menuId: 'menuId'
  };

  export type sys_menu_on_roleOrderByRelevanceFieldEnum = (typeof sys_menu_on_roleOrderByRelevanceFieldEnum)[keyof typeof sys_menu_on_roleOrderByRelevanceFieldEnum]


  export const sys_roleOrderByRelevanceFieldEnum: {
    uid: 'uid',
    name: 'name',
    comment: 'comment'
  };

  export type sys_roleOrderByRelevanceFieldEnum = (typeof sys_roleOrderByRelevanceFieldEnum)[keyof typeof sys_roleOrderByRelevanceFieldEnum]


  export const blog_userOrderByRelevanceFieldEnum: {
    uid: 'uid',
    name: 'name'
  };

  export type blog_userOrderByRelevanceFieldEnum = (typeof blog_userOrderByRelevanceFieldEnum)[keyof typeof blog_userOrderByRelevanceFieldEnum]


  export const blog_categoriesOrderByRelevanceFieldEnum: {
    uid: 'uid',
    name: 'name'
  };

  export type blog_categoriesOrderByRelevanceFieldEnum = (typeof blog_categoriesOrderByRelevanceFieldEnum)[keyof typeof blog_categoriesOrderByRelevanceFieldEnum]


  export const blog_postsOrderByRelevanceFieldEnum: {
    uid: 'uid',
    title: 'title',
    content: 'content',
    userId: 'userId',
    categoriesId: 'categoriesId'
  };

  export type blog_postsOrderByRelevanceFieldEnum = (typeof blog_postsOrderByRelevanceFieldEnum)[keyof typeof blog_postsOrderByRelevanceFieldEnum]


  export const blog_noticeOrderByRelevanceFieldEnum: {
    uid: 'uid'
  };

  export type blog_noticeOrderByRelevanceFieldEnum = (typeof blog_noticeOrderByRelevanceFieldEnum)[keyof typeof blog_noticeOrderByRelevanceFieldEnum]


  export const blog_posts_on_tagsOrderByRelevanceFieldEnum: {
    postsId: 'postsId',
    tagId: 'tagId'
  };

  export type blog_posts_on_tagsOrderByRelevanceFieldEnum = (typeof blog_posts_on_tagsOrderByRelevanceFieldEnum)[keyof typeof blog_posts_on_tagsOrderByRelevanceFieldEnum]


  export const blog_tagOrderByRelevanceFieldEnum: {
    uid: 'uid',
    name: 'name'
  };

  export type blog_tagOrderByRelevanceFieldEnum = (typeof blog_tagOrderByRelevanceFieldEnum)[keyof typeof blog_tagOrderByRelevanceFieldEnum]


  export const file_userOrderByRelevanceFieldEnum: {
    uid: 'uid',
    name: 'name'
  };

  export type file_userOrderByRelevanceFieldEnum = (typeof file_userOrderByRelevanceFieldEnum)[keyof typeof file_userOrderByRelevanceFieldEnum]


  export const file_keysOrderByRelevanceFieldEnum: {
    api_key: 'api_key',
    api_secret: 'api_secret',
    userId: 'userId'
  };

  export type file_keysOrderByRelevanceFieldEnum = (typeof file_keysOrderByRelevanceFieldEnum)[keyof typeof file_keysOrderByRelevanceFieldEnum]


  export const file_configOrderByRelevanceFieldEnum: {
    uid: 'uid',
    userId: 'userId'
  };

  export type file_configOrderByRelevanceFieldEnum = (typeof file_configOrderByRelevanceFieldEnum)[keyof typeof file_configOrderByRelevanceFieldEnum]


  export const file_user_on_mediaOrderByRelevanceFieldEnum: {
    userId: 'userId',
    mediaId: 'mediaId',
    comment: 'comment'
  };

  export type file_user_on_mediaOrderByRelevanceFieldEnum = (typeof file_user_on_mediaOrderByRelevanceFieldEnum)[keyof typeof file_user_on_mediaOrderByRelevanceFieldEnum]


  export const file_blockOrderByRelevanceFieldEnum: {
    uid: 'uid',
    mediaId: 'mediaId',
    hash_key: 'hash_key'
  };

  export type file_blockOrderByRelevanceFieldEnum = (typeof file_blockOrderByRelevanceFieldEnum)[keyof typeof file_blockOrderByRelevanceFieldEnum]


  export const file_mediaOrderByRelevanceFieldEnum: {
    uid: 'uid',
    name: 'name',
    hash_key: 'hash_key',
    comment: 'comment'
  };

  export type file_mediaOrderByRelevanceFieldEnum = (typeof file_mediaOrderByRelevanceFieldEnum)[keyof typeof file_mediaOrderByRelevanceFieldEnum]


  export const file_media_on_folderOrderByRelevanceFieldEnum: {
    mediaId: 'mediaId',
    folderId: 'folderId'
  };

  export type file_media_on_folderOrderByRelevanceFieldEnum = (typeof file_media_on_folderOrderByRelevanceFieldEnum)[keyof typeof file_media_on_folderOrderByRelevanceFieldEnum]


  export const file_folderOrderByRelevanceFieldEnum: {
    uid: 'uid',
    name: 'name',
    userId: 'userId',
    parentId: 'parentId'
  };

  export type file_folderOrderByRelevanceFieldEnum = (typeof file_folderOrderByRelevanceFieldEnum)[keyof typeof file_folderOrderByRelevanceFieldEnum]


  export const book_userOrderByRelevanceFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    password: 'password',
    book_roleId: 'book_roleId'
  };

  export type book_userOrderByRelevanceFieldEnum = (typeof book_userOrderByRelevanceFieldEnum)[keyof typeof book_userOrderByRelevanceFieldEnum]


  export const book_bookOrderByRelevanceFieldEnum: {
    id: 'id',
    title: 'title',
    author: 'author',
    isbn: 'isbn',
    description: 'description',
    categoryId: 'categoryId'
  };

  export type book_bookOrderByRelevanceFieldEnum = (typeof book_bookOrderByRelevanceFieldEnum)[keyof typeof book_bookOrderByRelevanceFieldEnum]


  export const book_categoryOrderByRelevanceFieldEnum: {
    id: 'id',
    categoryName: 'categoryName'
  };

  export type book_categoryOrderByRelevanceFieldEnum = (typeof book_categoryOrderByRelevanceFieldEnum)[keyof typeof book_categoryOrderByRelevanceFieldEnum]


  export const book_borrowedOrderByRelevanceFieldEnum: {
    id: 'id',
    userId: 'userId',
    bookId: 'bookId'
  };

  export type book_borrowedOrderByRelevanceFieldEnum = (typeof book_borrowedOrderByRelevanceFieldEnum)[keyof typeof book_borrowedOrderByRelevanceFieldEnum]


  export const book_borrow_historyOrderByRelevanceFieldEnum: {
    id: 'id',
    userId: 'userId',
    bookId: 'bookId'
  };

  export type book_borrow_historyOrderByRelevanceFieldEnum = (typeof book_borrow_historyOrderByRelevanceFieldEnum)[keyof typeof book_borrow_historyOrderByRelevanceFieldEnum]


  export const book_ratingOrderByRelevanceFieldEnum: {
    id: 'id',
    review: 'review',
    userId: 'userId',
    bookId: 'bookId'
  };

  export type book_ratingOrderByRelevanceFieldEnum = (typeof book_ratingOrderByRelevanceFieldEnum)[keyof typeof book_ratingOrderByRelevanceFieldEnum]


  export const study_userOrderByRelevanceFieldEnum: {
    uid: 'uid',
    name: 'name',
    account: 'account',
    password: 'password'
  };

  export type study_userOrderByRelevanceFieldEnum = (typeof study_userOrderByRelevanceFieldEnum)[keyof typeof study_userOrderByRelevanceFieldEnum]


  export const study_storeOrderByRelevanceFieldEnum: {
    uid: 'uid',
    name: 'name',
    local: 'local',
    address: 'address',
    remark: 'remark'
  };

  export type study_storeOrderByRelevanceFieldEnum = (typeof study_storeOrderByRelevanceFieldEnum)[keyof typeof study_storeOrderByRelevanceFieldEnum]


  export const study_floorOrderByRelevanceFieldEnum: {
    uid: 'uid',
    storeId: 'storeId'
  };

  export type study_floorOrderByRelevanceFieldEnum = (typeof study_floorOrderByRelevanceFieldEnum)[keyof typeof study_floorOrderByRelevanceFieldEnum]


  export const study_roomOrderByRelevanceFieldEnum: {
    uid: 'uid',
    name: 'name',
    floorId: 'floorId'
  };

  export type study_roomOrderByRelevanceFieldEnum = (typeof study_roomOrderByRelevanceFieldEnum)[keyof typeof study_roomOrderByRelevanceFieldEnum]


  export const study_seatOrderByRelevanceFieldEnum: {
    uid: 'uid',
    seatNumber: 'seatNumber',
    roomId: 'roomId'
  };

  export type study_seatOrderByRelevanceFieldEnum = (typeof study_seatOrderByRelevanceFieldEnum)[keyof typeof study_seatOrderByRelevanceFieldEnum]


  export const study_reservationOrderByRelevanceFieldEnum: {
    uid: 'uid',
    userId: 'userId',
    seatId: 'seatId',
    status: 'status'
  };

  export type study_reservationOrderByRelevanceFieldEnum = (typeof study_reservationOrderByRelevanceFieldEnum)[keyof typeof study_reservationOrderByRelevanceFieldEnum]


  export const study_messageOrderByRelevanceFieldEnum: {
    uid: 'uid',
    userId: 'userId',
    content: 'content',
    reply: 'reply'
  };

  export type study_messageOrderByRelevanceFieldEnum = (typeof study_messageOrderByRelevanceFieldEnum)[keyof typeof study_messageOrderByRelevanceFieldEnum]


  export const study_announcementOrderByRelevanceFieldEnum: {
    uid: 'uid',
    title: 'title',
    content: 'content'
  };

  export type study_announcementOrderByRelevanceFieldEnum = (typeof study_announcementOrderByRelevanceFieldEnum)[keyof typeof study_announcementOrderByRelevanceFieldEnum]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'sys_account_provider'
   */
  export type Enumsys_account_providerFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'sys_account_provider'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'file_type'
   */
  export type Enumfile_typeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'file_type'>
    


  /**
   * Reference to a field of type 'book_role'
   */
  export type Enumbook_roleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'book_role'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type sys_userWhereInput = {
    AND?: sys_userWhereInput | sys_userWhereInput[]
    OR?: sys_userWhereInput[]
    NOT?: sys_userWhereInput | sys_userWhereInput[]
    uid?: StringFilter<"sys_user"> | string
    createAt?: DateTimeFilter<"sys_user"> | Date | string
    updateAt?: DateTimeFilter<"sys_user"> | Date | string
    name?: StringFilter<"sys_user"> | string
    password?: StringFilter<"sys_user"> | string
    salt?: StringFilter<"sys_user"> | string
    roleId?: StringNullableFilter<"sys_user"> | string | null
    accounts?: Sys_accountListRelationFilter
    role?: XOR<Sys_roleNullableScalarRelationFilter, sys_roleWhereInput> | null
    ban_menus?: Sys_user_ban_menuListRelationFilter
  }

  export type sys_userOrderByWithRelationInput = {
    uid?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    name?: SortOrder
    password?: SortOrder
    salt?: SortOrder
    roleId?: SortOrderInput | SortOrder
    accounts?: sys_accountOrderByRelationAggregateInput
    role?: sys_roleOrderByWithRelationInput
    ban_menus?: sys_user_ban_menuOrderByRelationAggregateInput
    _relevance?: sys_userOrderByRelevanceInput
  }

  export type sys_userWhereUniqueInput = Prisma.AtLeast<{
    uid?: string
    AND?: sys_userWhereInput | sys_userWhereInput[]
    OR?: sys_userWhereInput[]
    NOT?: sys_userWhereInput | sys_userWhereInput[]
    createAt?: DateTimeFilter<"sys_user"> | Date | string
    updateAt?: DateTimeFilter<"sys_user"> | Date | string
    name?: StringFilter<"sys_user"> | string
    password?: StringFilter<"sys_user"> | string
    salt?: StringFilter<"sys_user"> | string
    roleId?: StringNullableFilter<"sys_user"> | string | null
    accounts?: Sys_accountListRelationFilter
    role?: XOR<Sys_roleNullableScalarRelationFilter, sys_roleWhereInput> | null
    ban_menus?: Sys_user_ban_menuListRelationFilter
  }, "uid">

  export type sys_userOrderByWithAggregationInput = {
    uid?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    name?: SortOrder
    password?: SortOrder
    salt?: SortOrder
    roleId?: SortOrderInput | SortOrder
    _count?: sys_userCountOrderByAggregateInput
    _max?: sys_userMaxOrderByAggregateInput
    _min?: sys_userMinOrderByAggregateInput
  }

  export type sys_userScalarWhereWithAggregatesInput = {
    AND?: sys_userScalarWhereWithAggregatesInput | sys_userScalarWhereWithAggregatesInput[]
    OR?: sys_userScalarWhereWithAggregatesInput[]
    NOT?: sys_userScalarWhereWithAggregatesInput | sys_userScalarWhereWithAggregatesInput[]
    uid?: StringWithAggregatesFilter<"sys_user"> | string
    createAt?: DateTimeWithAggregatesFilter<"sys_user"> | Date | string
    updateAt?: DateTimeWithAggregatesFilter<"sys_user"> | Date | string
    name?: StringWithAggregatesFilter<"sys_user"> | string
    password?: StringWithAggregatesFilter<"sys_user"> | string
    salt?: StringWithAggregatesFilter<"sys_user"> | string
    roleId?: StringNullableWithAggregatesFilter<"sys_user"> | string | null
  }

  export type sys_accountWhereInput = {
    AND?: sys_accountWhereInput | sys_accountWhereInput[]
    OR?: sys_accountWhereInput[]
    NOT?: sys_accountWhereInput | sys_accountWhereInput[]
    createAt?: DateTimeFilter<"sys_account"> | Date | string
    updateAt?: DateTimeFilter<"sys_account"> | Date | string
    provider?: Enumsys_account_providerFilter<"sys_account"> | $Enums.sys_account_provider
    provider_id?: StringFilter<"sys_account"> | string
    userId?: StringNullableFilter<"sys_account"> | string | null
    user?: XOR<Sys_userNullableScalarRelationFilter, sys_userWhereInput> | null
  }

  export type sys_accountOrderByWithRelationInput = {
    createAt?: SortOrder
    updateAt?: SortOrder
    provider?: SortOrder
    provider_id?: SortOrder
    userId?: SortOrderInput | SortOrder
    user?: sys_userOrderByWithRelationInput
    _relevance?: sys_accountOrderByRelevanceInput
  }

  export type sys_accountWhereUniqueInput = Prisma.AtLeast<{
    provider_provider_id?: sys_accountProviderProvider_idCompoundUniqueInput
    AND?: sys_accountWhereInput | sys_accountWhereInput[]
    OR?: sys_accountWhereInput[]
    NOT?: sys_accountWhereInput | sys_accountWhereInput[]
    createAt?: DateTimeFilter<"sys_account"> | Date | string
    updateAt?: DateTimeFilter<"sys_account"> | Date | string
    provider?: Enumsys_account_providerFilter<"sys_account"> | $Enums.sys_account_provider
    provider_id?: StringFilter<"sys_account"> | string
    userId?: StringNullableFilter<"sys_account"> | string | null
    user?: XOR<Sys_userNullableScalarRelationFilter, sys_userWhereInput> | null
  }, "provider_provider_id">

  export type sys_accountOrderByWithAggregationInput = {
    createAt?: SortOrder
    updateAt?: SortOrder
    provider?: SortOrder
    provider_id?: SortOrder
    userId?: SortOrderInput | SortOrder
    _count?: sys_accountCountOrderByAggregateInput
    _max?: sys_accountMaxOrderByAggregateInput
    _min?: sys_accountMinOrderByAggregateInput
  }

  export type sys_accountScalarWhereWithAggregatesInput = {
    AND?: sys_accountScalarWhereWithAggregatesInput | sys_accountScalarWhereWithAggregatesInput[]
    OR?: sys_accountScalarWhereWithAggregatesInput[]
    NOT?: sys_accountScalarWhereWithAggregatesInput | sys_accountScalarWhereWithAggregatesInput[]
    createAt?: DateTimeWithAggregatesFilter<"sys_account"> | Date | string
    updateAt?: DateTimeWithAggregatesFilter<"sys_account"> | Date | string
    provider?: Enumsys_account_providerWithAggregatesFilter<"sys_account"> | $Enums.sys_account_provider
    provider_id?: StringWithAggregatesFilter<"sys_account"> | string
    userId?: StringNullableWithAggregatesFilter<"sys_account"> | string | null
  }

  export type sys_menuWhereInput = {
    AND?: sys_menuWhereInput | sys_menuWhereInput[]
    OR?: sys_menuWhereInput[]
    NOT?: sys_menuWhereInput | sys_menuWhereInput[]
    uid?: StringFilter<"sys_menu"> | string
    createAt?: DateTimeFilter<"sys_menu"> | Date | string
    updateAt?: DateTimeFilter<"sys_menu"> | Date | string
    name?: StringFilter<"sys_menu"> | string
    path?: StringFilter<"sys_menu"> | string
    powers?: IntFilter<"sys_menu"> | number
    comment?: StringNullableFilter<"sys_menu"> | string | null
    parentId?: StringNullableFilter<"sys_menu"> | string | null
    parent?: XOR<Sys_menuNullableScalarRelationFilter, sys_menuWhereInput> | null
    children?: Sys_menuListRelationFilter
    roles?: Sys_menu_on_roleListRelationFilter
    user_bans?: Sys_user_ban_menuListRelationFilter
  }

  export type sys_menuOrderByWithRelationInput = {
    uid?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    name?: SortOrder
    path?: SortOrder
    powers?: SortOrder
    comment?: SortOrderInput | SortOrder
    parentId?: SortOrderInput | SortOrder
    parent?: sys_menuOrderByWithRelationInput
    children?: sys_menuOrderByRelationAggregateInput
    roles?: sys_menu_on_roleOrderByRelationAggregateInput
    user_bans?: sys_user_ban_menuOrderByRelationAggregateInput
    _relevance?: sys_menuOrderByRelevanceInput
  }

  export type sys_menuWhereUniqueInput = Prisma.AtLeast<{
    uid?: string
    path?: string
    AND?: sys_menuWhereInput | sys_menuWhereInput[]
    OR?: sys_menuWhereInput[]
    NOT?: sys_menuWhereInput | sys_menuWhereInput[]
    createAt?: DateTimeFilter<"sys_menu"> | Date | string
    updateAt?: DateTimeFilter<"sys_menu"> | Date | string
    name?: StringFilter<"sys_menu"> | string
    powers?: IntFilter<"sys_menu"> | number
    comment?: StringNullableFilter<"sys_menu"> | string | null
    parentId?: StringNullableFilter<"sys_menu"> | string | null
    parent?: XOR<Sys_menuNullableScalarRelationFilter, sys_menuWhereInput> | null
    children?: Sys_menuListRelationFilter
    roles?: Sys_menu_on_roleListRelationFilter
    user_bans?: Sys_user_ban_menuListRelationFilter
  }, "uid" | "path">

  export type sys_menuOrderByWithAggregationInput = {
    uid?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    name?: SortOrder
    path?: SortOrder
    powers?: SortOrder
    comment?: SortOrderInput | SortOrder
    parentId?: SortOrderInput | SortOrder
    _count?: sys_menuCountOrderByAggregateInput
    _avg?: sys_menuAvgOrderByAggregateInput
    _max?: sys_menuMaxOrderByAggregateInput
    _min?: sys_menuMinOrderByAggregateInput
    _sum?: sys_menuSumOrderByAggregateInput
  }

  export type sys_menuScalarWhereWithAggregatesInput = {
    AND?: sys_menuScalarWhereWithAggregatesInput | sys_menuScalarWhereWithAggregatesInput[]
    OR?: sys_menuScalarWhereWithAggregatesInput[]
    NOT?: sys_menuScalarWhereWithAggregatesInput | sys_menuScalarWhereWithAggregatesInput[]
    uid?: StringWithAggregatesFilter<"sys_menu"> | string
    createAt?: DateTimeWithAggregatesFilter<"sys_menu"> | Date | string
    updateAt?: DateTimeWithAggregatesFilter<"sys_menu"> | Date | string
    name?: StringWithAggregatesFilter<"sys_menu"> | string
    path?: StringWithAggregatesFilter<"sys_menu"> | string
    powers?: IntWithAggregatesFilter<"sys_menu"> | number
    comment?: StringNullableWithAggregatesFilter<"sys_menu"> | string | null
    parentId?: StringNullableWithAggregatesFilter<"sys_menu"> | string | null
  }

  export type sys_user_ban_menuWhereInput = {
    AND?: sys_user_ban_menuWhereInput | sys_user_ban_menuWhereInput[]
    OR?: sys_user_ban_menuWhereInput[]
    NOT?: sys_user_ban_menuWhereInput | sys_user_ban_menuWhereInput[]
    userId?: StringFilter<"sys_user_ban_menu"> | string
    menuId?: StringFilter<"sys_user_ban_menu"> | string
    user?: XOR<Sys_userScalarRelationFilter, sys_userWhereInput>
    menu?: XOR<Sys_menuScalarRelationFilter, sys_menuWhereInput>
  }

  export type sys_user_ban_menuOrderByWithRelationInput = {
    userId?: SortOrder
    menuId?: SortOrder
    user?: sys_userOrderByWithRelationInput
    menu?: sys_menuOrderByWithRelationInput
    _relevance?: sys_user_ban_menuOrderByRelevanceInput
  }

  export type sys_user_ban_menuWhereUniqueInput = Prisma.AtLeast<{
    userId_menuId?: sys_user_ban_menuUserIdMenuIdCompoundUniqueInput
    AND?: sys_user_ban_menuWhereInput | sys_user_ban_menuWhereInput[]
    OR?: sys_user_ban_menuWhereInput[]
    NOT?: sys_user_ban_menuWhereInput | sys_user_ban_menuWhereInput[]
    userId?: StringFilter<"sys_user_ban_menu"> | string
    menuId?: StringFilter<"sys_user_ban_menu"> | string
    user?: XOR<Sys_userScalarRelationFilter, sys_userWhereInput>
    menu?: XOR<Sys_menuScalarRelationFilter, sys_menuWhereInput>
  }, "userId_menuId">

  export type sys_user_ban_menuOrderByWithAggregationInput = {
    userId?: SortOrder
    menuId?: SortOrder
    _count?: sys_user_ban_menuCountOrderByAggregateInput
    _max?: sys_user_ban_menuMaxOrderByAggregateInput
    _min?: sys_user_ban_menuMinOrderByAggregateInput
  }

  export type sys_user_ban_menuScalarWhereWithAggregatesInput = {
    AND?: sys_user_ban_menuScalarWhereWithAggregatesInput | sys_user_ban_menuScalarWhereWithAggregatesInput[]
    OR?: sys_user_ban_menuScalarWhereWithAggregatesInput[]
    NOT?: sys_user_ban_menuScalarWhereWithAggregatesInput | sys_user_ban_menuScalarWhereWithAggregatesInput[]
    userId?: StringWithAggregatesFilter<"sys_user_ban_menu"> | string
    menuId?: StringWithAggregatesFilter<"sys_user_ban_menu"> | string
  }

  export type sys_menu_on_roleWhereInput = {
    AND?: sys_menu_on_roleWhereInput | sys_menu_on_roleWhereInput[]
    OR?: sys_menu_on_roleWhereInput[]
    NOT?: sys_menu_on_roleWhereInput | sys_menu_on_roleWhereInput[]
    roleId?: StringFilter<"sys_menu_on_role"> | string
    menuId?: StringFilter<"sys_menu_on_role"> | string
    power?: BigIntFilter<"sys_menu_on_role"> | bigint | number
    menu?: XOR<Sys_menuScalarRelationFilter, sys_menuWhereInput>
    role?: XOR<Sys_roleScalarRelationFilter, sys_roleWhereInput>
  }

  export type sys_menu_on_roleOrderByWithRelationInput = {
    roleId?: SortOrder
    menuId?: SortOrder
    power?: SortOrder
    menu?: sys_menuOrderByWithRelationInput
    role?: sys_roleOrderByWithRelationInput
    _relevance?: sys_menu_on_roleOrderByRelevanceInput
  }

  export type sys_menu_on_roleWhereUniqueInput = Prisma.AtLeast<{
    roleId_menuId?: sys_menu_on_roleRoleIdMenuIdCompoundUniqueInput
    AND?: sys_menu_on_roleWhereInput | sys_menu_on_roleWhereInput[]
    OR?: sys_menu_on_roleWhereInput[]
    NOT?: sys_menu_on_roleWhereInput | sys_menu_on_roleWhereInput[]
    roleId?: StringFilter<"sys_menu_on_role"> | string
    menuId?: StringFilter<"sys_menu_on_role"> | string
    power?: BigIntFilter<"sys_menu_on_role"> | bigint | number
    menu?: XOR<Sys_menuScalarRelationFilter, sys_menuWhereInput>
    role?: XOR<Sys_roleScalarRelationFilter, sys_roleWhereInput>
  }, "roleId_menuId">

  export type sys_menu_on_roleOrderByWithAggregationInput = {
    roleId?: SortOrder
    menuId?: SortOrder
    power?: SortOrder
    _count?: sys_menu_on_roleCountOrderByAggregateInput
    _avg?: sys_menu_on_roleAvgOrderByAggregateInput
    _max?: sys_menu_on_roleMaxOrderByAggregateInput
    _min?: sys_menu_on_roleMinOrderByAggregateInput
    _sum?: sys_menu_on_roleSumOrderByAggregateInput
  }

  export type sys_menu_on_roleScalarWhereWithAggregatesInput = {
    AND?: sys_menu_on_roleScalarWhereWithAggregatesInput | sys_menu_on_roleScalarWhereWithAggregatesInput[]
    OR?: sys_menu_on_roleScalarWhereWithAggregatesInput[]
    NOT?: sys_menu_on_roleScalarWhereWithAggregatesInput | sys_menu_on_roleScalarWhereWithAggregatesInput[]
    roleId?: StringWithAggregatesFilter<"sys_menu_on_role"> | string
    menuId?: StringWithAggregatesFilter<"sys_menu_on_role"> | string
    power?: BigIntWithAggregatesFilter<"sys_menu_on_role"> | bigint | number
  }

  export type sys_roleWhereInput = {
    AND?: sys_roleWhereInput | sys_roleWhereInput[]
    OR?: sys_roleWhereInput[]
    NOT?: sys_roleWhereInput | sys_roleWhereInput[]
    uid?: StringFilter<"sys_role"> | string
    createAt?: DateTimeFilter<"sys_role"> | Date | string
    updateAt?: DateTimeFilter<"sys_role"> | Date | string
    name?: StringFilter<"sys_role"> | string
    status?: BoolFilter<"sys_role"> | boolean
    comment?: StringNullableFilter<"sys_role"> | string | null
    menus?: Sys_menu_on_roleListRelationFilter
    users?: Sys_userListRelationFilter
  }

  export type sys_roleOrderByWithRelationInput = {
    uid?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    name?: SortOrder
    status?: SortOrder
    comment?: SortOrderInput | SortOrder
    menus?: sys_menu_on_roleOrderByRelationAggregateInput
    users?: sys_userOrderByRelationAggregateInput
    _relevance?: sys_roleOrderByRelevanceInput
  }

  export type sys_roleWhereUniqueInput = Prisma.AtLeast<{
    uid?: string
    name?: string
    AND?: sys_roleWhereInput | sys_roleWhereInput[]
    OR?: sys_roleWhereInput[]
    NOT?: sys_roleWhereInput | sys_roleWhereInput[]
    createAt?: DateTimeFilter<"sys_role"> | Date | string
    updateAt?: DateTimeFilter<"sys_role"> | Date | string
    status?: BoolFilter<"sys_role"> | boolean
    comment?: StringNullableFilter<"sys_role"> | string | null
    menus?: Sys_menu_on_roleListRelationFilter
    users?: Sys_userListRelationFilter
  }, "uid" | "name">

  export type sys_roleOrderByWithAggregationInput = {
    uid?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    name?: SortOrder
    status?: SortOrder
    comment?: SortOrderInput | SortOrder
    _count?: sys_roleCountOrderByAggregateInput
    _max?: sys_roleMaxOrderByAggregateInput
    _min?: sys_roleMinOrderByAggregateInput
  }

  export type sys_roleScalarWhereWithAggregatesInput = {
    AND?: sys_roleScalarWhereWithAggregatesInput | sys_roleScalarWhereWithAggregatesInput[]
    OR?: sys_roleScalarWhereWithAggregatesInput[]
    NOT?: sys_roleScalarWhereWithAggregatesInput | sys_roleScalarWhereWithAggregatesInput[]
    uid?: StringWithAggregatesFilter<"sys_role"> | string
    createAt?: DateTimeWithAggregatesFilter<"sys_role"> | Date | string
    updateAt?: DateTimeWithAggregatesFilter<"sys_role"> | Date | string
    name?: StringWithAggregatesFilter<"sys_role"> | string
    status?: BoolWithAggregatesFilter<"sys_role"> | boolean
    comment?: StringNullableWithAggregatesFilter<"sys_role"> | string | null
  }

  export type blog_userWhereInput = {
    AND?: blog_userWhereInput | blog_userWhereInput[]
    OR?: blog_userWhereInput[]
    NOT?: blog_userWhereInput | blog_userWhereInput[]
    uid?: StringFilter<"blog_user"> | string
    createAt?: DateTimeFilter<"blog_user"> | Date | string
    updateAt?: DateTimeFilter<"blog_user"> | Date | string
    name?: StringFilter<"blog_user"> | string
    posts?: Blog_postsListRelationFilter
  }

  export type blog_userOrderByWithRelationInput = {
    uid?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    name?: SortOrder
    posts?: blog_postsOrderByRelationAggregateInput
    _relevance?: blog_userOrderByRelevanceInput
  }

  export type blog_userWhereUniqueInput = Prisma.AtLeast<{
    uid?: string
    AND?: blog_userWhereInput | blog_userWhereInput[]
    OR?: blog_userWhereInput[]
    NOT?: blog_userWhereInput | blog_userWhereInput[]
    createAt?: DateTimeFilter<"blog_user"> | Date | string
    updateAt?: DateTimeFilter<"blog_user"> | Date | string
    name?: StringFilter<"blog_user"> | string
    posts?: Blog_postsListRelationFilter
  }, "uid">

  export type blog_userOrderByWithAggregationInput = {
    uid?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    name?: SortOrder
    _count?: blog_userCountOrderByAggregateInput
    _max?: blog_userMaxOrderByAggregateInput
    _min?: blog_userMinOrderByAggregateInput
  }

  export type blog_userScalarWhereWithAggregatesInput = {
    AND?: blog_userScalarWhereWithAggregatesInput | blog_userScalarWhereWithAggregatesInput[]
    OR?: blog_userScalarWhereWithAggregatesInput[]
    NOT?: blog_userScalarWhereWithAggregatesInput | blog_userScalarWhereWithAggregatesInput[]
    uid?: StringWithAggregatesFilter<"blog_user"> | string
    createAt?: DateTimeWithAggregatesFilter<"blog_user"> | Date | string
    updateAt?: DateTimeWithAggregatesFilter<"blog_user"> | Date | string
    name?: StringWithAggregatesFilter<"blog_user"> | string
  }

  export type blog_categoriesWhereInput = {
    AND?: blog_categoriesWhereInput | blog_categoriesWhereInput[]
    OR?: blog_categoriesWhereInput[]
    NOT?: blog_categoriesWhereInput | blog_categoriesWhereInput[]
    uid?: StringFilter<"blog_categories"> | string
    createAt?: DateTimeFilter<"blog_categories"> | Date | string
    updateAt?: DateTimeFilter<"blog_categories"> | Date | string
    name?: StringFilter<"blog_categories"> | string
    posts?: Blog_postsListRelationFilter
  }

  export type blog_categoriesOrderByWithRelationInput = {
    uid?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    name?: SortOrder
    posts?: blog_postsOrderByRelationAggregateInput
    _relevance?: blog_categoriesOrderByRelevanceInput
  }

  export type blog_categoriesWhereUniqueInput = Prisma.AtLeast<{
    uid?: string
    AND?: blog_categoriesWhereInput | blog_categoriesWhereInput[]
    OR?: blog_categoriesWhereInput[]
    NOT?: blog_categoriesWhereInput | blog_categoriesWhereInput[]
    createAt?: DateTimeFilter<"blog_categories"> | Date | string
    updateAt?: DateTimeFilter<"blog_categories"> | Date | string
    name?: StringFilter<"blog_categories"> | string
    posts?: Blog_postsListRelationFilter
  }, "uid">

  export type blog_categoriesOrderByWithAggregationInput = {
    uid?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    name?: SortOrder
    _count?: blog_categoriesCountOrderByAggregateInput
    _max?: blog_categoriesMaxOrderByAggregateInput
    _min?: blog_categoriesMinOrderByAggregateInput
  }

  export type blog_categoriesScalarWhereWithAggregatesInput = {
    AND?: blog_categoriesScalarWhereWithAggregatesInput | blog_categoriesScalarWhereWithAggregatesInput[]
    OR?: blog_categoriesScalarWhereWithAggregatesInput[]
    NOT?: blog_categoriesScalarWhereWithAggregatesInput | blog_categoriesScalarWhereWithAggregatesInput[]
    uid?: StringWithAggregatesFilter<"blog_categories"> | string
    createAt?: DateTimeWithAggregatesFilter<"blog_categories"> | Date | string
    updateAt?: DateTimeWithAggregatesFilter<"blog_categories"> | Date | string
    name?: StringWithAggregatesFilter<"blog_categories"> | string
  }

  export type blog_postsWhereInput = {
    AND?: blog_postsWhereInput | blog_postsWhereInput[]
    OR?: blog_postsWhereInput[]
    NOT?: blog_postsWhereInput | blog_postsWhereInput[]
    uid?: StringFilter<"blog_posts"> | string
    createAt?: DateTimeFilter<"blog_posts"> | Date | string
    updateAt?: DateTimeFilter<"blog_posts"> | Date | string
    title?: StringFilter<"blog_posts"> | string
    content?: StringFilter<"blog_posts"> | string
    userId?: StringFilter<"blog_posts"> | string
    categoriesId?: StringNullableFilter<"blog_posts"> | string | null
    categories?: XOR<Blog_categoriesNullableScalarRelationFilter, blog_categoriesWhereInput> | null
    user?: XOR<Blog_userScalarRelationFilter, blog_userWhereInput>
    tags?: Blog_posts_on_tagsListRelationFilter
  }

  export type blog_postsOrderByWithRelationInput = {
    uid?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    title?: SortOrder
    content?: SortOrder
    userId?: SortOrder
    categoriesId?: SortOrderInput | SortOrder
    categories?: blog_categoriesOrderByWithRelationInput
    user?: blog_userOrderByWithRelationInput
    tags?: blog_posts_on_tagsOrderByRelationAggregateInput
    _relevance?: blog_postsOrderByRelevanceInput
  }

  export type blog_postsWhereUniqueInput = Prisma.AtLeast<{
    uid?: string
    AND?: blog_postsWhereInput | blog_postsWhereInput[]
    OR?: blog_postsWhereInput[]
    NOT?: blog_postsWhereInput | blog_postsWhereInput[]
    createAt?: DateTimeFilter<"blog_posts"> | Date | string
    updateAt?: DateTimeFilter<"blog_posts"> | Date | string
    title?: StringFilter<"blog_posts"> | string
    content?: StringFilter<"blog_posts"> | string
    userId?: StringFilter<"blog_posts"> | string
    categoriesId?: StringNullableFilter<"blog_posts"> | string | null
    categories?: XOR<Blog_categoriesNullableScalarRelationFilter, blog_categoriesWhereInput> | null
    user?: XOR<Blog_userScalarRelationFilter, blog_userWhereInput>
    tags?: Blog_posts_on_tagsListRelationFilter
  }, "uid">

  export type blog_postsOrderByWithAggregationInput = {
    uid?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    title?: SortOrder
    content?: SortOrder
    userId?: SortOrder
    categoriesId?: SortOrderInput | SortOrder
    _count?: blog_postsCountOrderByAggregateInput
    _max?: blog_postsMaxOrderByAggregateInput
    _min?: blog_postsMinOrderByAggregateInput
  }

  export type blog_postsScalarWhereWithAggregatesInput = {
    AND?: blog_postsScalarWhereWithAggregatesInput | blog_postsScalarWhereWithAggregatesInput[]
    OR?: blog_postsScalarWhereWithAggregatesInput[]
    NOT?: blog_postsScalarWhereWithAggregatesInput | blog_postsScalarWhereWithAggregatesInput[]
    uid?: StringWithAggregatesFilter<"blog_posts"> | string
    createAt?: DateTimeWithAggregatesFilter<"blog_posts"> | Date | string
    updateAt?: DateTimeWithAggregatesFilter<"blog_posts"> | Date | string
    title?: StringWithAggregatesFilter<"blog_posts"> | string
    content?: StringWithAggregatesFilter<"blog_posts"> | string
    userId?: StringWithAggregatesFilter<"blog_posts"> | string
    categoriesId?: StringNullableWithAggregatesFilter<"blog_posts"> | string | null
  }

  export type blog_noticeWhereInput = {
    AND?: blog_noticeWhereInput | blog_noticeWhereInput[]
    OR?: blog_noticeWhereInput[]
    NOT?: blog_noticeWhereInput | blog_noticeWhereInput[]
    uid?: StringFilter<"blog_notice"> | string
    createAt?: DateTimeFilter<"blog_notice"> | Date | string
    updateAt?: DateTimeFilter<"blog_notice"> | Date | string
  }

  export type blog_noticeOrderByWithRelationInput = {
    uid?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    _relevance?: blog_noticeOrderByRelevanceInput
  }

  export type blog_noticeWhereUniqueInput = Prisma.AtLeast<{
    uid?: string
    AND?: blog_noticeWhereInput | blog_noticeWhereInput[]
    OR?: blog_noticeWhereInput[]
    NOT?: blog_noticeWhereInput | blog_noticeWhereInput[]
    createAt?: DateTimeFilter<"blog_notice"> | Date | string
    updateAt?: DateTimeFilter<"blog_notice"> | Date | string
  }, "uid">

  export type blog_noticeOrderByWithAggregationInput = {
    uid?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    _count?: blog_noticeCountOrderByAggregateInput
    _max?: blog_noticeMaxOrderByAggregateInput
    _min?: blog_noticeMinOrderByAggregateInput
  }

  export type blog_noticeScalarWhereWithAggregatesInput = {
    AND?: blog_noticeScalarWhereWithAggregatesInput | blog_noticeScalarWhereWithAggregatesInput[]
    OR?: blog_noticeScalarWhereWithAggregatesInput[]
    NOT?: blog_noticeScalarWhereWithAggregatesInput | blog_noticeScalarWhereWithAggregatesInput[]
    uid?: StringWithAggregatesFilter<"blog_notice"> | string
    createAt?: DateTimeWithAggregatesFilter<"blog_notice"> | Date | string
    updateAt?: DateTimeWithAggregatesFilter<"blog_notice"> | Date | string
  }

  export type blog_posts_on_tagsWhereInput = {
    AND?: blog_posts_on_tagsWhereInput | blog_posts_on_tagsWhereInput[]
    OR?: blog_posts_on_tagsWhereInput[]
    NOT?: blog_posts_on_tagsWhereInput | blog_posts_on_tagsWhereInput[]
    postsId?: StringFilter<"blog_posts_on_tags"> | string
    tagId?: StringFilter<"blog_posts_on_tags"> | string
    posts?: XOR<Blog_postsScalarRelationFilter, blog_postsWhereInput>
    tag?: XOR<Blog_tagScalarRelationFilter, blog_tagWhereInput>
  }

  export type blog_posts_on_tagsOrderByWithRelationInput = {
    postsId?: SortOrder
    tagId?: SortOrder
    posts?: blog_postsOrderByWithRelationInput
    tag?: blog_tagOrderByWithRelationInput
    _relevance?: blog_posts_on_tagsOrderByRelevanceInput
  }

  export type blog_posts_on_tagsWhereUniqueInput = Prisma.AtLeast<{
    postsId_tagId?: blog_posts_on_tagsPostsIdTagIdCompoundUniqueInput
    AND?: blog_posts_on_tagsWhereInput | blog_posts_on_tagsWhereInput[]
    OR?: blog_posts_on_tagsWhereInput[]
    NOT?: blog_posts_on_tagsWhereInput | blog_posts_on_tagsWhereInput[]
    postsId?: StringFilter<"blog_posts_on_tags"> | string
    tagId?: StringFilter<"blog_posts_on_tags"> | string
    posts?: XOR<Blog_postsScalarRelationFilter, blog_postsWhereInput>
    tag?: XOR<Blog_tagScalarRelationFilter, blog_tagWhereInput>
  }, "postsId_tagId">

  export type blog_posts_on_tagsOrderByWithAggregationInput = {
    postsId?: SortOrder
    tagId?: SortOrder
    _count?: blog_posts_on_tagsCountOrderByAggregateInput
    _max?: blog_posts_on_tagsMaxOrderByAggregateInput
    _min?: blog_posts_on_tagsMinOrderByAggregateInput
  }

  export type blog_posts_on_tagsScalarWhereWithAggregatesInput = {
    AND?: blog_posts_on_tagsScalarWhereWithAggregatesInput | blog_posts_on_tagsScalarWhereWithAggregatesInput[]
    OR?: blog_posts_on_tagsScalarWhereWithAggregatesInput[]
    NOT?: blog_posts_on_tagsScalarWhereWithAggregatesInput | blog_posts_on_tagsScalarWhereWithAggregatesInput[]
    postsId?: StringWithAggregatesFilter<"blog_posts_on_tags"> | string
    tagId?: StringWithAggregatesFilter<"blog_posts_on_tags"> | string
  }

  export type blog_tagWhereInput = {
    AND?: blog_tagWhereInput | blog_tagWhereInput[]
    OR?: blog_tagWhereInput[]
    NOT?: blog_tagWhereInput | blog_tagWhereInput[]
    uid?: StringFilter<"blog_tag"> | string
    createAt?: DateTimeFilter<"blog_tag"> | Date | string
    updateAt?: DateTimeFilter<"blog_tag"> | Date | string
    name?: StringFilter<"blog_tag"> | string
    blog_posts_on_tags?: Blog_posts_on_tagsListRelationFilter
  }

  export type blog_tagOrderByWithRelationInput = {
    uid?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    name?: SortOrder
    blog_posts_on_tags?: blog_posts_on_tagsOrderByRelationAggregateInput
    _relevance?: blog_tagOrderByRelevanceInput
  }

  export type blog_tagWhereUniqueInput = Prisma.AtLeast<{
    uid?: string
    AND?: blog_tagWhereInput | blog_tagWhereInput[]
    OR?: blog_tagWhereInput[]
    NOT?: blog_tagWhereInput | blog_tagWhereInput[]
    createAt?: DateTimeFilter<"blog_tag"> | Date | string
    updateAt?: DateTimeFilter<"blog_tag"> | Date | string
    name?: StringFilter<"blog_tag"> | string
    blog_posts_on_tags?: Blog_posts_on_tagsListRelationFilter
  }, "uid">

  export type blog_tagOrderByWithAggregationInput = {
    uid?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    name?: SortOrder
    _count?: blog_tagCountOrderByAggregateInput
    _max?: blog_tagMaxOrderByAggregateInput
    _min?: blog_tagMinOrderByAggregateInput
  }

  export type blog_tagScalarWhereWithAggregatesInput = {
    AND?: blog_tagScalarWhereWithAggregatesInput | blog_tagScalarWhereWithAggregatesInput[]
    OR?: blog_tagScalarWhereWithAggregatesInput[]
    NOT?: blog_tagScalarWhereWithAggregatesInput | blog_tagScalarWhereWithAggregatesInput[]
    uid?: StringWithAggregatesFilter<"blog_tag"> | string
    createAt?: DateTimeWithAggregatesFilter<"blog_tag"> | Date | string
    updateAt?: DateTimeWithAggregatesFilter<"blog_tag"> | Date | string
    name?: StringWithAggregatesFilter<"blog_tag"> | string
  }

  export type file_userWhereInput = {
    AND?: file_userWhereInput | file_userWhereInput[]
    OR?: file_userWhereInput[]
    NOT?: file_userWhereInput | file_userWhereInput[]
    uid?: StringFilter<"file_user"> | string
    createAt?: DateTimeFilter<"file_user"> | Date | string
    updateAt?: DateTimeFilter<"file_user"> | Date | string
    name?: StringFilter<"file_user"> | string
    is_admin?: BoolFilter<"file_user"> | boolean
    medias?: File_user_on_mediaListRelationFilter
    folders?: File_folderListRelationFilter
    file_config?: XOR<File_configNullableScalarRelationFilter, file_configWhereInput> | null
    keys?: File_keysListRelationFilter
  }

  export type file_userOrderByWithRelationInput = {
    uid?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    name?: SortOrder
    is_admin?: SortOrder
    medias?: file_user_on_mediaOrderByRelationAggregateInput
    folders?: file_folderOrderByRelationAggregateInput
    file_config?: file_configOrderByWithRelationInput
    keys?: file_keysOrderByRelationAggregateInput
    _relevance?: file_userOrderByRelevanceInput
  }

  export type file_userWhereUniqueInput = Prisma.AtLeast<{
    uid?: string
    AND?: file_userWhereInput | file_userWhereInput[]
    OR?: file_userWhereInput[]
    NOT?: file_userWhereInput | file_userWhereInput[]
    createAt?: DateTimeFilter<"file_user"> | Date | string
    updateAt?: DateTimeFilter<"file_user"> | Date | string
    name?: StringFilter<"file_user"> | string
    is_admin?: BoolFilter<"file_user"> | boolean
    medias?: File_user_on_mediaListRelationFilter
    folders?: File_folderListRelationFilter
    file_config?: XOR<File_configNullableScalarRelationFilter, file_configWhereInput> | null
    keys?: File_keysListRelationFilter
  }, "uid">

  export type file_userOrderByWithAggregationInput = {
    uid?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    name?: SortOrder
    is_admin?: SortOrder
    _count?: file_userCountOrderByAggregateInput
    _max?: file_userMaxOrderByAggregateInput
    _min?: file_userMinOrderByAggregateInput
  }

  export type file_userScalarWhereWithAggregatesInput = {
    AND?: file_userScalarWhereWithAggregatesInput | file_userScalarWhereWithAggregatesInput[]
    OR?: file_userScalarWhereWithAggregatesInput[]
    NOT?: file_userScalarWhereWithAggregatesInput | file_userScalarWhereWithAggregatesInput[]
    uid?: StringWithAggregatesFilter<"file_user"> | string
    createAt?: DateTimeWithAggregatesFilter<"file_user"> | Date | string
    updateAt?: DateTimeWithAggregatesFilter<"file_user"> | Date | string
    name?: StringWithAggregatesFilter<"file_user"> | string
    is_admin?: BoolWithAggregatesFilter<"file_user"> | boolean
  }

  export type file_keysWhereInput = {
    AND?: file_keysWhereInput | file_keysWhereInput[]
    OR?: file_keysWhereInput[]
    NOT?: file_keysWhereInput | file_keysWhereInput[]
    api_key?: StringFilter<"file_keys"> | string
    api_secret?: StringFilter<"file_keys"> | string
    userId?: StringFilter<"file_keys"> | string
    user?: XOR<File_userScalarRelationFilter, file_userWhereInput>
  }

  export type file_keysOrderByWithRelationInput = {
    api_key?: SortOrder
    api_secret?: SortOrder
    userId?: SortOrder
    user?: file_userOrderByWithRelationInput
    _relevance?: file_keysOrderByRelevanceInput
  }

  export type file_keysWhereUniqueInput = Prisma.AtLeast<{
    api_key?: string
    AND?: file_keysWhereInput | file_keysWhereInput[]
    OR?: file_keysWhereInput[]
    NOT?: file_keysWhereInput | file_keysWhereInput[]
    api_secret?: StringFilter<"file_keys"> | string
    userId?: StringFilter<"file_keys"> | string
    user?: XOR<File_userScalarRelationFilter, file_userWhereInput>
  }, "api_key">

  export type file_keysOrderByWithAggregationInput = {
    api_key?: SortOrder
    api_secret?: SortOrder
    userId?: SortOrder
    _count?: file_keysCountOrderByAggregateInput
    _max?: file_keysMaxOrderByAggregateInput
    _min?: file_keysMinOrderByAggregateInput
  }

  export type file_keysScalarWhereWithAggregatesInput = {
    AND?: file_keysScalarWhereWithAggregatesInput | file_keysScalarWhereWithAggregatesInput[]
    OR?: file_keysScalarWhereWithAggregatesInput[]
    NOT?: file_keysScalarWhereWithAggregatesInput | file_keysScalarWhereWithAggregatesInput[]
    api_key?: StringWithAggregatesFilter<"file_keys"> | string
    api_secret?: StringWithAggregatesFilter<"file_keys"> | string
    userId?: StringWithAggregatesFilter<"file_keys"> | string
  }

  export type file_configWhereInput = {
    AND?: file_configWhereInput | file_configWhereInput[]
    OR?: file_configWhereInput[]
    NOT?: file_configWhereInput | file_configWhereInput[]
    uid?: StringFilter<"file_config"> | string
    userId?: StringFilter<"file_config"> | string
    user?: XOR<File_userScalarRelationFilter, file_userWhereInput>
  }

  export type file_configOrderByWithRelationInput = {
    uid?: SortOrder
    userId?: SortOrder
    user?: file_userOrderByWithRelationInput
    _relevance?: file_configOrderByRelevanceInput
  }

  export type file_configWhereUniqueInput = Prisma.AtLeast<{
    uid?: string
    userId?: string
    AND?: file_configWhereInput | file_configWhereInput[]
    OR?: file_configWhereInput[]
    NOT?: file_configWhereInput | file_configWhereInput[]
    user?: XOR<File_userScalarRelationFilter, file_userWhereInput>
  }, "uid" | "userId">

  export type file_configOrderByWithAggregationInput = {
    uid?: SortOrder
    userId?: SortOrder
    _count?: file_configCountOrderByAggregateInput
    _max?: file_configMaxOrderByAggregateInput
    _min?: file_configMinOrderByAggregateInput
  }

  export type file_configScalarWhereWithAggregatesInput = {
    AND?: file_configScalarWhereWithAggregatesInput | file_configScalarWhereWithAggregatesInput[]
    OR?: file_configScalarWhereWithAggregatesInput[]
    NOT?: file_configScalarWhereWithAggregatesInput | file_configScalarWhereWithAggregatesInput[]
    uid?: StringWithAggregatesFilter<"file_config"> | string
    userId?: StringWithAggregatesFilter<"file_config"> | string
  }

  export type file_user_on_mediaWhereInput = {
    AND?: file_user_on_mediaWhereInput | file_user_on_mediaWhereInput[]
    OR?: file_user_on_mediaWhereInput[]
    NOT?: file_user_on_mediaWhereInput | file_user_on_mediaWhereInput[]
    userId?: StringFilter<"file_user_on_media"> | string
    mediaId?: StringFilter<"file_user_on_media"> | string
    comment?: StringNullableFilter<"file_user_on_media"> | string | null
    user?: XOR<File_userScalarRelationFilter, file_userWhereInput>
    media?: XOR<File_mediaScalarRelationFilter, file_mediaWhereInput>
  }

  export type file_user_on_mediaOrderByWithRelationInput = {
    userId?: SortOrder
    mediaId?: SortOrder
    comment?: SortOrderInput | SortOrder
    user?: file_userOrderByWithRelationInput
    media?: file_mediaOrderByWithRelationInput
    _relevance?: file_user_on_mediaOrderByRelevanceInput
  }

  export type file_user_on_mediaWhereUniqueInput = Prisma.AtLeast<{
    userId_mediaId?: file_user_on_mediaUserIdMediaIdCompoundUniqueInput
    AND?: file_user_on_mediaWhereInput | file_user_on_mediaWhereInput[]
    OR?: file_user_on_mediaWhereInput[]
    NOT?: file_user_on_mediaWhereInput | file_user_on_mediaWhereInput[]
    userId?: StringFilter<"file_user_on_media"> | string
    mediaId?: StringFilter<"file_user_on_media"> | string
    comment?: StringNullableFilter<"file_user_on_media"> | string | null
    user?: XOR<File_userScalarRelationFilter, file_userWhereInput>
    media?: XOR<File_mediaScalarRelationFilter, file_mediaWhereInput>
  }, "userId_mediaId">

  export type file_user_on_mediaOrderByWithAggregationInput = {
    userId?: SortOrder
    mediaId?: SortOrder
    comment?: SortOrderInput | SortOrder
    _count?: file_user_on_mediaCountOrderByAggregateInput
    _max?: file_user_on_mediaMaxOrderByAggregateInput
    _min?: file_user_on_mediaMinOrderByAggregateInput
  }

  export type file_user_on_mediaScalarWhereWithAggregatesInput = {
    AND?: file_user_on_mediaScalarWhereWithAggregatesInput | file_user_on_mediaScalarWhereWithAggregatesInput[]
    OR?: file_user_on_mediaScalarWhereWithAggregatesInput[]
    NOT?: file_user_on_mediaScalarWhereWithAggregatesInput | file_user_on_mediaScalarWhereWithAggregatesInput[]
    userId?: StringWithAggregatesFilter<"file_user_on_media"> | string
    mediaId?: StringWithAggregatesFilter<"file_user_on_media"> | string
    comment?: StringNullableWithAggregatesFilter<"file_user_on_media"> | string | null
  }

  export type file_blockWhereInput = {
    AND?: file_blockWhereInput | file_blockWhereInput[]
    OR?: file_blockWhereInput[]
    NOT?: file_blockWhereInput | file_blockWhereInput[]
    uid?: StringFilter<"file_block"> | string
    createAt?: DateTimeFilter<"file_block"> | Date | string
    updateAt?: DateTimeFilter<"file_block"> | Date | string
    mediaId?: StringFilter<"file_block"> | string
    hash_key?: StringFilter<"file_block"> | string
    size?: IntFilter<"file_block"> | number
    media?: XOR<File_mediaScalarRelationFilter, file_mediaWhereInput>
  }

  export type file_blockOrderByWithRelationInput = {
    uid?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    mediaId?: SortOrder
    hash_key?: SortOrder
    size?: SortOrder
    media?: file_mediaOrderByWithRelationInput
    _relevance?: file_blockOrderByRelevanceInput
  }

  export type file_blockWhereUniqueInput = Prisma.AtLeast<{
    uid?: string
    AND?: file_blockWhereInput | file_blockWhereInput[]
    OR?: file_blockWhereInput[]
    NOT?: file_blockWhereInput | file_blockWhereInput[]
    createAt?: DateTimeFilter<"file_block"> | Date | string
    updateAt?: DateTimeFilter<"file_block"> | Date | string
    mediaId?: StringFilter<"file_block"> | string
    hash_key?: StringFilter<"file_block"> | string
    size?: IntFilter<"file_block"> | number
    media?: XOR<File_mediaScalarRelationFilter, file_mediaWhereInput>
  }, "uid">

  export type file_blockOrderByWithAggregationInput = {
    uid?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    mediaId?: SortOrder
    hash_key?: SortOrder
    size?: SortOrder
    _count?: file_blockCountOrderByAggregateInput
    _avg?: file_blockAvgOrderByAggregateInput
    _max?: file_blockMaxOrderByAggregateInput
    _min?: file_blockMinOrderByAggregateInput
    _sum?: file_blockSumOrderByAggregateInput
  }

  export type file_blockScalarWhereWithAggregatesInput = {
    AND?: file_blockScalarWhereWithAggregatesInput | file_blockScalarWhereWithAggregatesInput[]
    OR?: file_blockScalarWhereWithAggregatesInput[]
    NOT?: file_blockScalarWhereWithAggregatesInput | file_blockScalarWhereWithAggregatesInput[]
    uid?: StringWithAggregatesFilter<"file_block"> | string
    createAt?: DateTimeWithAggregatesFilter<"file_block"> | Date | string
    updateAt?: DateTimeWithAggregatesFilter<"file_block"> | Date | string
    mediaId?: StringWithAggregatesFilter<"file_block"> | string
    hash_key?: StringWithAggregatesFilter<"file_block"> | string
    size?: IntWithAggregatesFilter<"file_block"> | number
  }

  export type file_mediaWhereInput = {
    AND?: file_mediaWhereInput | file_mediaWhereInput[]
    OR?: file_mediaWhereInput[]
    NOT?: file_mediaWhereInput | file_mediaWhereInput[]
    uid?: StringFilter<"file_media"> | string
    createAt?: DateTimeFilter<"file_media"> | Date | string
    updateAt?: DateTimeFilter<"file_media"> | Date | string
    type?: Enumfile_typeFilter<"file_media"> | $Enums.file_type
    name?: StringFilter<"file_media"> | string
    hash_key?: StringFilter<"file_media"> | string
    size?: IntFilter<"file_media"> | number
    disable?: BoolFilter<"file_media"> | boolean
    comment?: StringNullableFilter<"file_media"> | string | null
    blocks?: File_blockListRelationFilter
    users?: File_user_on_mediaListRelationFilter
    folders?: File_media_on_folderListRelationFilter
  }

  export type file_mediaOrderByWithRelationInput = {
    uid?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    type?: SortOrder
    name?: SortOrder
    hash_key?: SortOrder
    size?: SortOrder
    disable?: SortOrder
    comment?: SortOrderInput | SortOrder
    blocks?: file_blockOrderByRelationAggregateInput
    users?: file_user_on_mediaOrderByRelationAggregateInput
    folders?: file_media_on_folderOrderByRelationAggregateInput
    _relevance?: file_mediaOrderByRelevanceInput
  }

  export type file_mediaWhereUniqueInput = Prisma.AtLeast<{
    uid?: string
    hash_key?: string
    AND?: file_mediaWhereInput | file_mediaWhereInput[]
    OR?: file_mediaWhereInput[]
    NOT?: file_mediaWhereInput | file_mediaWhereInput[]
    createAt?: DateTimeFilter<"file_media"> | Date | string
    updateAt?: DateTimeFilter<"file_media"> | Date | string
    type?: Enumfile_typeFilter<"file_media"> | $Enums.file_type
    name?: StringFilter<"file_media"> | string
    size?: IntFilter<"file_media"> | number
    disable?: BoolFilter<"file_media"> | boolean
    comment?: StringNullableFilter<"file_media"> | string | null
    blocks?: File_blockListRelationFilter
    users?: File_user_on_mediaListRelationFilter
    folders?: File_media_on_folderListRelationFilter
  }, "uid" | "hash_key">

  export type file_mediaOrderByWithAggregationInput = {
    uid?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    type?: SortOrder
    name?: SortOrder
    hash_key?: SortOrder
    size?: SortOrder
    disable?: SortOrder
    comment?: SortOrderInput | SortOrder
    _count?: file_mediaCountOrderByAggregateInput
    _avg?: file_mediaAvgOrderByAggregateInput
    _max?: file_mediaMaxOrderByAggregateInput
    _min?: file_mediaMinOrderByAggregateInput
    _sum?: file_mediaSumOrderByAggregateInput
  }

  export type file_mediaScalarWhereWithAggregatesInput = {
    AND?: file_mediaScalarWhereWithAggregatesInput | file_mediaScalarWhereWithAggregatesInput[]
    OR?: file_mediaScalarWhereWithAggregatesInput[]
    NOT?: file_mediaScalarWhereWithAggregatesInput | file_mediaScalarWhereWithAggregatesInput[]
    uid?: StringWithAggregatesFilter<"file_media"> | string
    createAt?: DateTimeWithAggregatesFilter<"file_media"> | Date | string
    updateAt?: DateTimeWithAggregatesFilter<"file_media"> | Date | string
    type?: Enumfile_typeWithAggregatesFilter<"file_media"> | $Enums.file_type
    name?: StringWithAggregatesFilter<"file_media"> | string
    hash_key?: StringWithAggregatesFilter<"file_media"> | string
    size?: IntWithAggregatesFilter<"file_media"> | number
    disable?: BoolWithAggregatesFilter<"file_media"> | boolean
    comment?: StringNullableWithAggregatesFilter<"file_media"> | string | null
  }

  export type file_media_on_folderWhereInput = {
    AND?: file_media_on_folderWhereInput | file_media_on_folderWhereInput[]
    OR?: file_media_on_folderWhereInput[]
    NOT?: file_media_on_folderWhereInput | file_media_on_folderWhereInput[]
    mediaId?: StringFilter<"file_media_on_folder"> | string
    folderId?: StringFilter<"file_media_on_folder"> | string
    media?: XOR<File_mediaScalarRelationFilter, file_mediaWhereInput>
    folder?: XOR<File_folderScalarRelationFilter, file_folderWhereInput>
  }

  export type file_media_on_folderOrderByWithRelationInput = {
    mediaId?: SortOrder
    folderId?: SortOrder
    media?: file_mediaOrderByWithRelationInput
    folder?: file_folderOrderByWithRelationInput
    _relevance?: file_media_on_folderOrderByRelevanceInput
  }

  export type file_media_on_folderWhereUniqueInput = Prisma.AtLeast<{
    mediaId_folderId?: file_media_on_folderMediaIdFolderIdCompoundUniqueInput
    AND?: file_media_on_folderWhereInput | file_media_on_folderWhereInput[]
    OR?: file_media_on_folderWhereInput[]
    NOT?: file_media_on_folderWhereInput | file_media_on_folderWhereInput[]
    mediaId?: StringFilter<"file_media_on_folder"> | string
    folderId?: StringFilter<"file_media_on_folder"> | string
    media?: XOR<File_mediaScalarRelationFilter, file_mediaWhereInput>
    folder?: XOR<File_folderScalarRelationFilter, file_folderWhereInput>
  }, "mediaId_folderId">

  export type file_media_on_folderOrderByWithAggregationInput = {
    mediaId?: SortOrder
    folderId?: SortOrder
    _count?: file_media_on_folderCountOrderByAggregateInput
    _max?: file_media_on_folderMaxOrderByAggregateInput
    _min?: file_media_on_folderMinOrderByAggregateInput
  }

  export type file_media_on_folderScalarWhereWithAggregatesInput = {
    AND?: file_media_on_folderScalarWhereWithAggregatesInput | file_media_on_folderScalarWhereWithAggregatesInput[]
    OR?: file_media_on_folderScalarWhereWithAggregatesInput[]
    NOT?: file_media_on_folderScalarWhereWithAggregatesInput | file_media_on_folderScalarWhereWithAggregatesInput[]
    mediaId?: StringWithAggregatesFilter<"file_media_on_folder"> | string
    folderId?: StringWithAggregatesFilter<"file_media_on_folder"> | string
  }

  export type file_folderWhereInput = {
    AND?: file_folderWhereInput | file_folderWhereInput[]
    OR?: file_folderWhereInput[]
    NOT?: file_folderWhereInput | file_folderWhereInput[]
    uid?: StringFilter<"file_folder"> | string
    createAt?: DateTimeFilter<"file_folder"> | Date | string
    updateAt?: DateTimeFilter<"file_folder"> | Date | string
    name?: StringFilter<"file_folder"> | string
    userId?: StringFilter<"file_folder"> | string
    parentId?: StringNullableFilter<"file_folder"> | string | null
    user?: XOR<File_userScalarRelationFilter, file_userWhereInput>
    parent?: XOR<File_folderNullableScalarRelationFilter, file_folderWhereInput> | null
    children?: File_folderListRelationFilter
    medias?: File_media_on_folderListRelationFilter
  }

  export type file_folderOrderByWithRelationInput = {
    uid?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    name?: SortOrder
    userId?: SortOrder
    parentId?: SortOrderInput | SortOrder
    user?: file_userOrderByWithRelationInput
    parent?: file_folderOrderByWithRelationInput
    children?: file_folderOrderByRelationAggregateInput
    medias?: file_media_on_folderOrderByRelationAggregateInput
    _relevance?: file_folderOrderByRelevanceInput
  }

  export type file_folderWhereUniqueInput = Prisma.AtLeast<{
    uid?: string
    AND?: file_folderWhereInput | file_folderWhereInput[]
    OR?: file_folderWhereInput[]
    NOT?: file_folderWhereInput | file_folderWhereInput[]
    createAt?: DateTimeFilter<"file_folder"> | Date | string
    updateAt?: DateTimeFilter<"file_folder"> | Date | string
    name?: StringFilter<"file_folder"> | string
    userId?: StringFilter<"file_folder"> | string
    parentId?: StringNullableFilter<"file_folder"> | string | null
    user?: XOR<File_userScalarRelationFilter, file_userWhereInput>
    parent?: XOR<File_folderNullableScalarRelationFilter, file_folderWhereInput> | null
    children?: File_folderListRelationFilter
    medias?: File_media_on_folderListRelationFilter
  }, "uid">

  export type file_folderOrderByWithAggregationInput = {
    uid?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    name?: SortOrder
    userId?: SortOrder
    parentId?: SortOrderInput | SortOrder
    _count?: file_folderCountOrderByAggregateInput
    _max?: file_folderMaxOrderByAggregateInput
    _min?: file_folderMinOrderByAggregateInput
  }

  export type file_folderScalarWhereWithAggregatesInput = {
    AND?: file_folderScalarWhereWithAggregatesInput | file_folderScalarWhereWithAggregatesInput[]
    OR?: file_folderScalarWhereWithAggregatesInput[]
    NOT?: file_folderScalarWhereWithAggregatesInput | file_folderScalarWhereWithAggregatesInput[]
    uid?: StringWithAggregatesFilter<"file_folder"> | string
    createAt?: DateTimeWithAggregatesFilter<"file_folder"> | Date | string
    updateAt?: DateTimeWithAggregatesFilter<"file_folder"> | Date | string
    name?: StringWithAggregatesFilter<"file_folder"> | string
    userId?: StringWithAggregatesFilter<"file_folder"> | string
    parentId?: StringNullableWithAggregatesFilter<"file_folder"> | string | null
  }

  export type book_userWhereInput = {
    AND?: book_userWhereInput | book_userWhereInput[]
    OR?: book_userWhereInput[]
    NOT?: book_userWhereInput | book_userWhereInput[]
    id?: StringFilter<"book_user"> | string
    createAt?: DateTimeFilter<"book_user"> | Date | string
    updateAt?: DateTimeFilter<"book_user"> | Date | string
    name?: StringFilter<"book_user"> | string
    email?: StringFilter<"book_user"> | string
    password?: StringFilter<"book_user"> | string
    role?: Enumbook_roleFilter<"book_user"> | $Enums.book_role
    book_roleId?: StringFilter<"book_user"> | string
    borrowed?: Book_borrowedListRelationFilter
    book_borrow_history?: Book_borrow_historyListRelationFilter
    book_rating?: Book_ratingListRelationFilter
  }

  export type book_userOrderByWithRelationInput = {
    id?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    book_roleId?: SortOrder
    borrowed?: book_borrowedOrderByRelationAggregateInput
    book_borrow_history?: book_borrow_historyOrderByRelationAggregateInput
    book_rating?: book_ratingOrderByRelationAggregateInput
    _relevance?: book_userOrderByRelevanceInput
  }

  export type book_userWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: book_userWhereInput | book_userWhereInput[]
    OR?: book_userWhereInput[]
    NOT?: book_userWhereInput | book_userWhereInput[]
    createAt?: DateTimeFilter<"book_user"> | Date | string
    updateAt?: DateTimeFilter<"book_user"> | Date | string
    name?: StringFilter<"book_user"> | string
    password?: StringFilter<"book_user"> | string
    role?: Enumbook_roleFilter<"book_user"> | $Enums.book_role
    book_roleId?: StringFilter<"book_user"> | string
    borrowed?: Book_borrowedListRelationFilter
    book_borrow_history?: Book_borrow_historyListRelationFilter
    book_rating?: Book_ratingListRelationFilter
  }, "id" | "email">

  export type book_userOrderByWithAggregationInput = {
    id?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    book_roleId?: SortOrder
    _count?: book_userCountOrderByAggregateInput
    _max?: book_userMaxOrderByAggregateInput
    _min?: book_userMinOrderByAggregateInput
  }

  export type book_userScalarWhereWithAggregatesInput = {
    AND?: book_userScalarWhereWithAggregatesInput | book_userScalarWhereWithAggregatesInput[]
    OR?: book_userScalarWhereWithAggregatesInput[]
    NOT?: book_userScalarWhereWithAggregatesInput | book_userScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"book_user"> | string
    createAt?: DateTimeWithAggregatesFilter<"book_user"> | Date | string
    updateAt?: DateTimeWithAggregatesFilter<"book_user"> | Date | string
    name?: StringWithAggregatesFilter<"book_user"> | string
    email?: StringWithAggregatesFilter<"book_user"> | string
    password?: StringWithAggregatesFilter<"book_user"> | string
    role?: Enumbook_roleWithAggregatesFilter<"book_user"> | $Enums.book_role
    book_roleId?: StringWithAggregatesFilter<"book_user"> | string
  }

  export type book_bookWhereInput = {
    AND?: book_bookWhereInput | book_bookWhereInput[]
    OR?: book_bookWhereInput[]
    NOT?: book_bookWhereInput | book_bookWhereInput[]
    id?: StringFilter<"book_book"> | string
    createAt?: DateTimeFilter<"book_book"> | Date | string
    updateAt?: DateTimeFilter<"book_book"> | Date | string
    title?: StringFilter<"book_book"> | string
    author?: StringFilter<"book_book"> | string
    isbn?: StringFilter<"book_book"> | string
    description?: StringNullableFilter<"book_book"> | string | null
    publication?: DateTimeFilter<"book_book"> | Date | string
    categoryId?: StringFilter<"book_book"> | string
    available?: BoolFilter<"book_book"> | boolean
    category?: XOR<Book_categoryScalarRelationFilter, book_categoryWhereInput>
    borrowed?: Book_borrowedListRelationFilter
    book_borrow_history?: Book_borrow_historyListRelationFilter
    book_rating?: Book_ratingListRelationFilter
  }

  export type book_bookOrderByWithRelationInput = {
    id?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    title?: SortOrder
    author?: SortOrder
    isbn?: SortOrder
    description?: SortOrderInput | SortOrder
    publication?: SortOrder
    categoryId?: SortOrder
    available?: SortOrder
    category?: book_categoryOrderByWithRelationInput
    borrowed?: book_borrowedOrderByRelationAggregateInput
    book_borrow_history?: book_borrow_historyOrderByRelationAggregateInput
    book_rating?: book_ratingOrderByRelationAggregateInput
    _relevance?: book_bookOrderByRelevanceInput
  }

  export type book_bookWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    isbn?: string
    AND?: book_bookWhereInput | book_bookWhereInput[]
    OR?: book_bookWhereInput[]
    NOT?: book_bookWhereInput | book_bookWhereInput[]
    createAt?: DateTimeFilter<"book_book"> | Date | string
    updateAt?: DateTimeFilter<"book_book"> | Date | string
    title?: StringFilter<"book_book"> | string
    author?: StringFilter<"book_book"> | string
    description?: StringNullableFilter<"book_book"> | string | null
    publication?: DateTimeFilter<"book_book"> | Date | string
    categoryId?: StringFilter<"book_book"> | string
    available?: BoolFilter<"book_book"> | boolean
    category?: XOR<Book_categoryScalarRelationFilter, book_categoryWhereInput>
    borrowed?: Book_borrowedListRelationFilter
    book_borrow_history?: Book_borrow_historyListRelationFilter
    book_rating?: Book_ratingListRelationFilter
  }, "id" | "isbn">

  export type book_bookOrderByWithAggregationInput = {
    id?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    title?: SortOrder
    author?: SortOrder
    isbn?: SortOrder
    description?: SortOrderInput | SortOrder
    publication?: SortOrder
    categoryId?: SortOrder
    available?: SortOrder
    _count?: book_bookCountOrderByAggregateInput
    _max?: book_bookMaxOrderByAggregateInput
    _min?: book_bookMinOrderByAggregateInput
  }

  export type book_bookScalarWhereWithAggregatesInput = {
    AND?: book_bookScalarWhereWithAggregatesInput | book_bookScalarWhereWithAggregatesInput[]
    OR?: book_bookScalarWhereWithAggregatesInput[]
    NOT?: book_bookScalarWhereWithAggregatesInput | book_bookScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"book_book"> | string
    createAt?: DateTimeWithAggregatesFilter<"book_book"> | Date | string
    updateAt?: DateTimeWithAggregatesFilter<"book_book"> | Date | string
    title?: StringWithAggregatesFilter<"book_book"> | string
    author?: StringWithAggregatesFilter<"book_book"> | string
    isbn?: StringWithAggregatesFilter<"book_book"> | string
    description?: StringNullableWithAggregatesFilter<"book_book"> | string | null
    publication?: DateTimeWithAggregatesFilter<"book_book"> | Date | string
    categoryId?: StringWithAggregatesFilter<"book_book"> | string
    available?: BoolWithAggregatesFilter<"book_book"> | boolean
  }

  export type book_categoryWhereInput = {
    AND?: book_categoryWhereInput | book_categoryWhereInput[]
    OR?: book_categoryWhereInput[]
    NOT?: book_categoryWhereInput | book_categoryWhereInput[]
    id?: StringFilter<"book_category"> | string
    createAt?: DateTimeFilter<"book_category"> | Date | string
    updateAt?: DateTimeFilter<"book_category"> | Date | string
    categoryName?: StringFilter<"book_category"> | string
    books?: Book_bookListRelationFilter
  }

  export type book_categoryOrderByWithRelationInput = {
    id?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    categoryName?: SortOrder
    books?: book_bookOrderByRelationAggregateInput
    _relevance?: book_categoryOrderByRelevanceInput
  }

  export type book_categoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    categoryName?: string
    AND?: book_categoryWhereInput | book_categoryWhereInput[]
    OR?: book_categoryWhereInput[]
    NOT?: book_categoryWhereInput | book_categoryWhereInput[]
    createAt?: DateTimeFilter<"book_category"> | Date | string
    updateAt?: DateTimeFilter<"book_category"> | Date | string
    books?: Book_bookListRelationFilter
  }, "id" | "categoryName">

  export type book_categoryOrderByWithAggregationInput = {
    id?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    categoryName?: SortOrder
    _count?: book_categoryCountOrderByAggregateInput
    _max?: book_categoryMaxOrderByAggregateInput
    _min?: book_categoryMinOrderByAggregateInput
  }

  export type book_categoryScalarWhereWithAggregatesInput = {
    AND?: book_categoryScalarWhereWithAggregatesInput | book_categoryScalarWhereWithAggregatesInput[]
    OR?: book_categoryScalarWhereWithAggregatesInput[]
    NOT?: book_categoryScalarWhereWithAggregatesInput | book_categoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"book_category"> | string
    createAt?: DateTimeWithAggregatesFilter<"book_category"> | Date | string
    updateAt?: DateTimeWithAggregatesFilter<"book_category"> | Date | string
    categoryName?: StringWithAggregatesFilter<"book_category"> | string
  }

  export type book_borrowedWhereInput = {
    AND?: book_borrowedWhereInput | book_borrowedWhereInput[]
    OR?: book_borrowedWhereInput[]
    NOT?: book_borrowedWhereInput | book_borrowedWhereInput[]
    id?: StringFilter<"book_borrowed"> | string
    borrowDate?: DateTimeFilter<"book_borrowed"> | Date | string
    returnDate?: DateTimeNullableFilter<"book_borrowed"> | Date | string | null
    dueDate?: DateTimeFilter<"book_borrowed"> | Date | string
    userId?: StringFilter<"book_borrowed"> | string
    bookId?: StringFilter<"book_borrowed"> | string
    returned?: BoolFilter<"book_borrowed"> | boolean
    user?: XOR<Book_userScalarRelationFilter, book_userWhereInput>
    book?: XOR<Book_bookScalarRelationFilter, book_bookWhereInput>
  }

  export type book_borrowedOrderByWithRelationInput = {
    id?: SortOrder
    borrowDate?: SortOrder
    returnDate?: SortOrderInput | SortOrder
    dueDate?: SortOrder
    userId?: SortOrder
    bookId?: SortOrder
    returned?: SortOrder
    user?: book_userOrderByWithRelationInput
    book?: book_bookOrderByWithRelationInput
    _relevance?: book_borrowedOrderByRelevanceInput
  }

  export type book_borrowedWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: book_borrowedWhereInput | book_borrowedWhereInput[]
    OR?: book_borrowedWhereInput[]
    NOT?: book_borrowedWhereInput | book_borrowedWhereInput[]
    borrowDate?: DateTimeFilter<"book_borrowed"> | Date | string
    returnDate?: DateTimeNullableFilter<"book_borrowed"> | Date | string | null
    dueDate?: DateTimeFilter<"book_borrowed"> | Date | string
    userId?: StringFilter<"book_borrowed"> | string
    bookId?: StringFilter<"book_borrowed"> | string
    returned?: BoolFilter<"book_borrowed"> | boolean
    user?: XOR<Book_userScalarRelationFilter, book_userWhereInput>
    book?: XOR<Book_bookScalarRelationFilter, book_bookWhereInput>
  }, "id">

  export type book_borrowedOrderByWithAggregationInput = {
    id?: SortOrder
    borrowDate?: SortOrder
    returnDate?: SortOrderInput | SortOrder
    dueDate?: SortOrder
    userId?: SortOrder
    bookId?: SortOrder
    returned?: SortOrder
    _count?: book_borrowedCountOrderByAggregateInput
    _max?: book_borrowedMaxOrderByAggregateInput
    _min?: book_borrowedMinOrderByAggregateInput
  }

  export type book_borrowedScalarWhereWithAggregatesInput = {
    AND?: book_borrowedScalarWhereWithAggregatesInput | book_borrowedScalarWhereWithAggregatesInput[]
    OR?: book_borrowedScalarWhereWithAggregatesInput[]
    NOT?: book_borrowedScalarWhereWithAggregatesInput | book_borrowedScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"book_borrowed"> | string
    borrowDate?: DateTimeWithAggregatesFilter<"book_borrowed"> | Date | string
    returnDate?: DateTimeNullableWithAggregatesFilter<"book_borrowed"> | Date | string | null
    dueDate?: DateTimeWithAggregatesFilter<"book_borrowed"> | Date | string
    userId?: StringWithAggregatesFilter<"book_borrowed"> | string
    bookId?: StringWithAggregatesFilter<"book_borrowed"> | string
    returned?: BoolWithAggregatesFilter<"book_borrowed"> | boolean
  }

  export type book_borrow_historyWhereInput = {
    AND?: book_borrow_historyWhereInput | book_borrow_historyWhereInput[]
    OR?: book_borrow_historyWhereInput[]
    NOT?: book_borrow_historyWhereInput | book_borrow_historyWhereInput[]
    id?: StringFilter<"book_borrow_history"> | string
    borrowDate?: DateTimeFilter<"book_borrow_history"> | Date | string
    returnDate?: DateTimeNullableFilter<"book_borrow_history"> | Date | string | null
    userId?: StringFilter<"book_borrow_history"> | string
    bookId?: StringFilter<"book_borrow_history"> | string
    returned?: BoolFilter<"book_borrow_history"> | boolean
    user?: XOR<Book_userScalarRelationFilter, book_userWhereInput>
    book?: XOR<Book_bookScalarRelationFilter, book_bookWhereInput>
  }

  export type book_borrow_historyOrderByWithRelationInput = {
    id?: SortOrder
    borrowDate?: SortOrder
    returnDate?: SortOrderInput | SortOrder
    userId?: SortOrder
    bookId?: SortOrder
    returned?: SortOrder
    user?: book_userOrderByWithRelationInput
    book?: book_bookOrderByWithRelationInput
    _relevance?: book_borrow_historyOrderByRelevanceInput
  }

  export type book_borrow_historyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: book_borrow_historyWhereInput | book_borrow_historyWhereInput[]
    OR?: book_borrow_historyWhereInput[]
    NOT?: book_borrow_historyWhereInput | book_borrow_historyWhereInput[]
    borrowDate?: DateTimeFilter<"book_borrow_history"> | Date | string
    returnDate?: DateTimeNullableFilter<"book_borrow_history"> | Date | string | null
    userId?: StringFilter<"book_borrow_history"> | string
    bookId?: StringFilter<"book_borrow_history"> | string
    returned?: BoolFilter<"book_borrow_history"> | boolean
    user?: XOR<Book_userScalarRelationFilter, book_userWhereInput>
    book?: XOR<Book_bookScalarRelationFilter, book_bookWhereInput>
  }, "id">

  export type book_borrow_historyOrderByWithAggregationInput = {
    id?: SortOrder
    borrowDate?: SortOrder
    returnDate?: SortOrderInput | SortOrder
    userId?: SortOrder
    bookId?: SortOrder
    returned?: SortOrder
    _count?: book_borrow_historyCountOrderByAggregateInput
    _max?: book_borrow_historyMaxOrderByAggregateInput
    _min?: book_borrow_historyMinOrderByAggregateInput
  }

  export type book_borrow_historyScalarWhereWithAggregatesInput = {
    AND?: book_borrow_historyScalarWhereWithAggregatesInput | book_borrow_historyScalarWhereWithAggregatesInput[]
    OR?: book_borrow_historyScalarWhereWithAggregatesInput[]
    NOT?: book_borrow_historyScalarWhereWithAggregatesInput | book_borrow_historyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"book_borrow_history"> | string
    borrowDate?: DateTimeWithAggregatesFilter<"book_borrow_history"> | Date | string
    returnDate?: DateTimeNullableWithAggregatesFilter<"book_borrow_history"> | Date | string | null
    userId?: StringWithAggregatesFilter<"book_borrow_history"> | string
    bookId?: StringWithAggregatesFilter<"book_borrow_history"> | string
    returned?: BoolWithAggregatesFilter<"book_borrow_history"> | boolean
  }

  export type book_ratingWhereInput = {
    AND?: book_ratingWhereInput | book_ratingWhereInput[]
    OR?: book_ratingWhereInput[]
    NOT?: book_ratingWhereInput | book_ratingWhereInput[]
    id?: StringFilter<"book_rating"> | string
    createAt?: DateTimeFilter<"book_rating"> | Date | string
    updateAt?: DateTimeFilter<"book_rating"> | Date | string
    rating?: FloatFilter<"book_rating"> | number
    review?: StringNullableFilter<"book_rating"> | string | null
    userId?: StringFilter<"book_rating"> | string
    bookId?: StringFilter<"book_rating"> | string
    user?: XOR<Book_userScalarRelationFilter, book_userWhereInput>
    book?: XOR<Book_bookScalarRelationFilter, book_bookWhereInput>
  }

  export type book_ratingOrderByWithRelationInput = {
    id?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    rating?: SortOrder
    review?: SortOrderInput | SortOrder
    userId?: SortOrder
    bookId?: SortOrder
    user?: book_userOrderByWithRelationInput
    book?: book_bookOrderByWithRelationInput
    _relevance?: book_ratingOrderByRelevanceInput
  }

  export type book_ratingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: book_ratingWhereInput | book_ratingWhereInput[]
    OR?: book_ratingWhereInput[]
    NOT?: book_ratingWhereInput | book_ratingWhereInput[]
    createAt?: DateTimeFilter<"book_rating"> | Date | string
    updateAt?: DateTimeFilter<"book_rating"> | Date | string
    rating?: FloatFilter<"book_rating"> | number
    review?: StringNullableFilter<"book_rating"> | string | null
    userId?: StringFilter<"book_rating"> | string
    bookId?: StringFilter<"book_rating"> | string
    user?: XOR<Book_userScalarRelationFilter, book_userWhereInput>
    book?: XOR<Book_bookScalarRelationFilter, book_bookWhereInput>
  }, "id">

  export type book_ratingOrderByWithAggregationInput = {
    id?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    rating?: SortOrder
    review?: SortOrderInput | SortOrder
    userId?: SortOrder
    bookId?: SortOrder
    _count?: book_ratingCountOrderByAggregateInput
    _avg?: book_ratingAvgOrderByAggregateInput
    _max?: book_ratingMaxOrderByAggregateInput
    _min?: book_ratingMinOrderByAggregateInput
    _sum?: book_ratingSumOrderByAggregateInput
  }

  export type book_ratingScalarWhereWithAggregatesInput = {
    AND?: book_ratingScalarWhereWithAggregatesInput | book_ratingScalarWhereWithAggregatesInput[]
    OR?: book_ratingScalarWhereWithAggregatesInput[]
    NOT?: book_ratingScalarWhereWithAggregatesInput | book_ratingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"book_rating"> | string
    createAt?: DateTimeWithAggregatesFilter<"book_rating"> | Date | string
    updateAt?: DateTimeWithAggregatesFilter<"book_rating"> | Date | string
    rating?: FloatWithAggregatesFilter<"book_rating"> | number
    review?: StringNullableWithAggregatesFilter<"book_rating"> | string | null
    userId?: StringWithAggregatesFilter<"book_rating"> | string
    bookId?: StringWithAggregatesFilter<"book_rating"> | string
  }

  export type study_userWhereInput = {
    AND?: study_userWhereInput | study_userWhereInput[]
    OR?: study_userWhereInput[]
    NOT?: study_userWhereInput | study_userWhereInput[]
    uid?: StringFilter<"study_user"> | string
    createAt?: DateTimeFilter<"study_user"> | Date | string
    updateAt?: DateTimeFilter<"study_user"> | Date | string
    name?: StringFilter<"study_user"> | string
    account?: StringFilter<"study_user"> | string
    password?: StringFilter<"study_user"> | string
    isAdmin?: BoolFilter<"study_user"> | boolean
    reservation?: Study_reservationListRelationFilter
    message?: Study_messageListRelationFilter
  }

  export type study_userOrderByWithRelationInput = {
    uid?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    name?: SortOrder
    account?: SortOrder
    password?: SortOrder
    isAdmin?: SortOrder
    reservation?: study_reservationOrderByRelationAggregateInput
    message?: study_messageOrderByRelationAggregateInput
    _relevance?: study_userOrderByRelevanceInput
  }

  export type study_userWhereUniqueInput = Prisma.AtLeast<{
    uid?: string
    account?: string
    AND?: study_userWhereInput | study_userWhereInput[]
    OR?: study_userWhereInput[]
    NOT?: study_userWhereInput | study_userWhereInput[]
    createAt?: DateTimeFilter<"study_user"> | Date | string
    updateAt?: DateTimeFilter<"study_user"> | Date | string
    name?: StringFilter<"study_user"> | string
    password?: StringFilter<"study_user"> | string
    isAdmin?: BoolFilter<"study_user"> | boolean
    reservation?: Study_reservationListRelationFilter
    message?: Study_messageListRelationFilter
  }, "uid" | "account">

  export type study_userOrderByWithAggregationInput = {
    uid?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    name?: SortOrder
    account?: SortOrder
    password?: SortOrder
    isAdmin?: SortOrder
    _count?: study_userCountOrderByAggregateInput
    _max?: study_userMaxOrderByAggregateInput
    _min?: study_userMinOrderByAggregateInput
  }

  export type study_userScalarWhereWithAggregatesInput = {
    AND?: study_userScalarWhereWithAggregatesInput | study_userScalarWhereWithAggregatesInput[]
    OR?: study_userScalarWhereWithAggregatesInput[]
    NOT?: study_userScalarWhereWithAggregatesInput | study_userScalarWhereWithAggregatesInput[]
    uid?: StringWithAggregatesFilter<"study_user"> | string
    createAt?: DateTimeWithAggregatesFilter<"study_user"> | Date | string
    updateAt?: DateTimeWithAggregatesFilter<"study_user"> | Date | string
    name?: StringWithAggregatesFilter<"study_user"> | string
    account?: StringWithAggregatesFilter<"study_user"> | string
    password?: StringWithAggregatesFilter<"study_user"> | string
    isAdmin?: BoolWithAggregatesFilter<"study_user"> | boolean
  }

  export type study_storeWhereInput = {
    AND?: study_storeWhereInput | study_storeWhereInput[]
    OR?: study_storeWhereInput[]
    NOT?: study_storeWhereInput | study_storeWhereInput[]
    uid?: StringFilter<"study_store"> | string
    createAt?: DateTimeFilter<"study_store"> | Date | string
    updateAt?: DateTimeFilter<"study_store"> | Date | string
    name?: StringFilter<"study_store"> | string
    local?: StringFilter<"study_store"> | string
    address?: StringFilter<"study_store"> | string
    status?: BoolFilter<"study_store"> | boolean
    remark?: StringNullableFilter<"study_store"> | string | null
    floors?: Study_floorListRelationFilter
  }

  export type study_storeOrderByWithRelationInput = {
    uid?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    name?: SortOrder
    local?: SortOrder
    address?: SortOrder
    status?: SortOrder
    remark?: SortOrderInput | SortOrder
    floors?: study_floorOrderByRelationAggregateInput
    _relevance?: study_storeOrderByRelevanceInput
  }

  export type study_storeWhereUniqueInput = Prisma.AtLeast<{
    uid?: string
    AND?: study_storeWhereInput | study_storeWhereInput[]
    OR?: study_storeWhereInput[]
    NOT?: study_storeWhereInput | study_storeWhereInput[]
    createAt?: DateTimeFilter<"study_store"> | Date | string
    updateAt?: DateTimeFilter<"study_store"> | Date | string
    name?: StringFilter<"study_store"> | string
    local?: StringFilter<"study_store"> | string
    address?: StringFilter<"study_store"> | string
    status?: BoolFilter<"study_store"> | boolean
    remark?: StringNullableFilter<"study_store"> | string | null
    floors?: Study_floorListRelationFilter
  }, "uid">

  export type study_storeOrderByWithAggregationInput = {
    uid?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    name?: SortOrder
    local?: SortOrder
    address?: SortOrder
    status?: SortOrder
    remark?: SortOrderInput | SortOrder
    _count?: study_storeCountOrderByAggregateInput
    _max?: study_storeMaxOrderByAggregateInput
    _min?: study_storeMinOrderByAggregateInput
  }

  export type study_storeScalarWhereWithAggregatesInput = {
    AND?: study_storeScalarWhereWithAggregatesInput | study_storeScalarWhereWithAggregatesInput[]
    OR?: study_storeScalarWhereWithAggregatesInput[]
    NOT?: study_storeScalarWhereWithAggregatesInput | study_storeScalarWhereWithAggregatesInput[]
    uid?: StringWithAggregatesFilter<"study_store"> | string
    createAt?: DateTimeWithAggregatesFilter<"study_store"> | Date | string
    updateAt?: DateTimeWithAggregatesFilter<"study_store"> | Date | string
    name?: StringWithAggregatesFilter<"study_store"> | string
    local?: StringWithAggregatesFilter<"study_store"> | string
    address?: StringWithAggregatesFilter<"study_store"> | string
    status?: BoolWithAggregatesFilter<"study_store"> | boolean
    remark?: StringNullableWithAggregatesFilter<"study_store"> | string | null
  }

  export type study_floorWhereInput = {
    AND?: study_floorWhereInput | study_floorWhereInput[]
    OR?: study_floorWhereInput[]
    NOT?: study_floorWhereInput | study_floorWhereInput[]
    uid?: StringFilter<"study_floor"> | string
    createAt?: DateTimeFilter<"study_floor"> | Date | string
    updateAt?: DateTimeFilter<"study_floor"> | Date | string
    floorNumber?: IntFilter<"study_floor"> | number
    storeId?: StringFilter<"study_floor"> | string
    store?: XOR<Study_storeScalarRelationFilter, study_storeWhereInput>
    studyRooms?: Study_roomListRelationFilter
  }

  export type study_floorOrderByWithRelationInput = {
    uid?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    floorNumber?: SortOrder
    storeId?: SortOrder
    store?: study_storeOrderByWithRelationInput
    studyRooms?: study_roomOrderByRelationAggregateInput
    _relevance?: study_floorOrderByRelevanceInput
  }

  export type study_floorWhereUniqueInput = Prisma.AtLeast<{
    uid?: string
    AND?: study_floorWhereInput | study_floorWhereInput[]
    OR?: study_floorWhereInput[]
    NOT?: study_floorWhereInput | study_floorWhereInput[]
    createAt?: DateTimeFilter<"study_floor"> | Date | string
    updateAt?: DateTimeFilter<"study_floor"> | Date | string
    floorNumber?: IntFilter<"study_floor"> | number
    storeId?: StringFilter<"study_floor"> | string
    store?: XOR<Study_storeScalarRelationFilter, study_storeWhereInput>
    studyRooms?: Study_roomListRelationFilter
  }, "uid">

  export type study_floorOrderByWithAggregationInput = {
    uid?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    floorNumber?: SortOrder
    storeId?: SortOrder
    _count?: study_floorCountOrderByAggregateInput
    _avg?: study_floorAvgOrderByAggregateInput
    _max?: study_floorMaxOrderByAggregateInput
    _min?: study_floorMinOrderByAggregateInput
    _sum?: study_floorSumOrderByAggregateInput
  }

  export type study_floorScalarWhereWithAggregatesInput = {
    AND?: study_floorScalarWhereWithAggregatesInput | study_floorScalarWhereWithAggregatesInput[]
    OR?: study_floorScalarWhereWithAggregatesInput[]
    NOT?: study_floorScalarWhereWithAggregatesInput | study_floorScalarWhereWithAggregatesInput[]
    uid?: StringWithAggregatesFilter<"study_floor"> | string
    createAt?: DateTimeWithAggregatesFilter<"study_floor"> | Date | string
    updateAt?: DateTimeWithAggregatesFilter<"study_floor"> | Date | string
    floorNumber?: IntWithAggregatesFilter<"study_floor"> | number
    storeId?: StringWithAggregatesFilter<"study_floor"> | string
  }

  export type study_roomWhereInput = {
    AND?: study_roomWhereInput | study_roomWhereInput[]
    OR?: study_roomWhereInput[]
    NOT?: study_roomWhereInput | study_roomWhereInput[]
    uid?: StringFilter<"study_room"> | string
    createAt?: DateTimeFilter<"study_room"> | Date | string
    updateAt?: DateTimeFilter<"study_room"> | Date | string
    name?: StringFilter<"study_room"> | string
    floorId?: StringFilter<"study_room"> | string
    capacity?: IntFilter<"study_room"> | number
    status?: BoolFilter<"study_room"> | boolean
    floor?: XOR<Study_floorScalarRelationFilter, study_floorWhereInput>
    seats?: Study_seatListRelationFilter
  }

  export type study_roomOrderByWithRelationInput = {
    uid?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    name?: SortOrder
    floorId?: SortOrder
    capacity?: SortOrder
    status?: SortOrder
    floor?: study_floorOrderByWithRelationInput
    seats?: study_seatOrderByRelationAggregateInput
    _relevance?: study_roomOrderByRelevanceInput
  }

  export type study_roomWhereUniqueInput = Prisma.AtLeast<{
    uid?: string
    AND?: study_roomWhereInput | study_roomWhereInput[]
    OR?: study_roomWhereInput[]
    NOT?: study_roomWhereInput | study_roomWhereInput[]
    createAt?: DateTimeFilter<"study_room"> | Date | string
    updateAt?: DateTimeFilter<"study_room"> | Date | string
    name?: StringFilter<"study_room"> | string
    floorId?: StringFilter<"study_room"> | string
    capacity?: IntFilter<"study_room"> | number
    status?: BoolFilter<"study_room"> | boolean
    floor?: XOR<Study_floorScalarRelationFilter, study_floorWhereInput>
    seats?: Study_seatListRelationFilter
  }, "uid">

  export type study_roomOrderByWithAggregationInput = {
    uid?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    name?: SortOrder
    floorId?: SortOrder
    capacity?: SortOrder
    status?: SortOrder
    _count?: study_roomCountOrderByAggregateInput
    _avg?: study_roomAvgOrderByAggregateInput
    _max?: study_roomMaxOrderByAggregateInput
    _min?: study_roomMinOrderByAggregateInput
    _sum?: study_roomSumOrderByAggregateInput
  }

  export type study_roomScalarWhereWithAggregatesInput = {
    AND?: study_roomScalarWhereWithAggregatesInput | study_roomScalarWhereWithAggregatesInput[]
    OR?: study_roomScalarWhereWithAggregatesInput[]
    NOT?: study_roomScalarWhereWithAggregatesInput | study_roomScalarWhereWithAggregatesInput[]
    uid?: StringWithAggregatesFilter<"study_room"> | string
    createAt?: DateTimeWithAggregatesFilter<"study_room"> | Date | string
    updateAt?: DateTimeWithAggregatesFilter<"study_room"> | Date | string
    name?: StringWithAggregatesFilter<"study_room"> | string
    floorId?: StringWithAggregatesFilter<"study_room"> | string
    capacity?: IntWithAggregatesFilter<"study_room"> | number
    status?: BoolWithAggregatesFilter<"study_room"> | boolean
  }

  export type study_seatWhereInput = {
    AND?: study_seatWhereInput | study_seatWhereInput[]
    OR?: study_seatWhereInput[]
    NOT?: study_seatWhereInput | study_seatWhereInput[]
    uid?: StringFilter<"study_seat"> | string
    createAt?: DateTimeFilter<"study_seat"> | Date | string
    updateAt?: DateTimeFilter<"study_seat"> | Date | string
    seatNumber?: StringFilter<"study_seat"> | string
    roomId?: StringFilter<"study_seat"> | string
    status?: BoolFilter<"study_seat"> | boolean
    room?: XOR<Study_roomScalarRelationFilter, study_roomWhereInput>
    reservations?: Study_reservationListRelationFilter
  }

  export type study_seatOrderByWithRelationInput = {
    uid?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    seatNumber?: SortOrder
    roomId?: SortOrder
    status?: SortOrder
    room?: study_roomOrderByWithRelationInput
    reservations?: study_reservationOrderByRelationAggregateInput
    _relevance?: study_seatOrderByRelevanceInput
  }

  export type study_seatWhereUniqueInput = Prisma.AtLeast<{
    uid?: string
    AND?: study_seatWhereInput | study_seatWhereInput[]
    OR?: study_seatWhereInput[]
    NOT?: study_seatWhereInput | study_seatWhereInput[]
    createAt?: DateTimeFilter<"study_seat"> | Date | string
    updateAt?: DateTimeFilter<"study_seat"> | Date | string
    seatNumber?: StringFilter<"study_seat"> | string
    roomId?: StringFilter<"study_seat"> | string
    status?: BoolFilter<"study_seat"> | boolean
    room?: XOR<Study_roomScalarRelationFilter, study_roomWhereInput>
    reservations?: Study_reservationListRelationFilter
  }, "uid">

  export type study_seatOrderByWithAggregationInput = {
    uid?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    seatNumber?: SortOrder
    roomId?: SortOrder
    status?: SortOrder
    _count?: study_seatCountOrderByAggregateInput
    _max?: study_seatMaxOrderByAggregateInput
    _min?: study_seatMinOrderByAggregateInput
  }

  export type study_seatScalarWhereWithAggregatesInput = {
    AND?: study_seatScalarWhereWithAggregatesInput | study_seatScalarWhereWithAggregatesInput[]
    OR?: study_seatScalarWhereWithAggregatesInput[]
    NOT?: study_seatScalarWhereWithAggregatesInput | study_seatScalarWhereWithAggregatesInput[]
    uid?: StringWithAggregatesFilter<"study_seat"> | string
    createAt?: DateTimeWithAggregatesFilter<"study_seat"> | Date | string
    updateAt?: DateTimeWithAggregatesFilter<"study_seat"> | Date | string
    seatNumber?: StringWithAggregatesFilter<"study_seat"> | string
    roomId?: StringWithAggregatesFilter<"study_seat"> | string
    status?: BoolWithAggregatesFilter<"study_seat"> | boolean
  }

  export type study_reservationWhereInput = {
    AND?: study_reservationWhereInput | study_reservationWhereInput[]
    OR?: study_reservationWhereInput[]
    NOT?: study_reservationWhereInput | study_reservationWhereInput[]
    uid?: StringFilter<"study_reservation"> | string
    createAt?: DateTimeFilter<"study_reservation"> | Date | string
    updateAt?: DateTimeFilter<"study_reservation"> | Date | string
    userId?: StringFilter<"study_reservation"> | string
    seatId?: StringFilter<"study_reservation"> | string
    startTime?: DateTimeFilter<"study_reservation"> | Date | string
    endTime?: DateTimeFilter<"study_reservation"> | Date | string
    status?: StringFilter<"study_reservation"> | string
    user?: XOR<Study_userScalarRelationFilter, study_userWhereInput>
    seat?: XOR<Study_seatScalarRelationFilter, study_seatWhereInput>
  }

  export type study_reservationOrderByWithRelationInput = {
    uid?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    userId?: SortOrder
    seatId?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    status?: SortOrder
    user?: study_userOrderByWithRelationInput
    seat?: study_seatOrderByWithRelationInput
    _relevance?: study_reservationOrderByRelevanceInput
  }

  export type study_reservationWhereUniqueInput = Prisma.AtLeast<{
    uid?: string
    AND?: study_reservationWhereInput | study_reservationWhereInput[]
    OR?: study_reservationWhereInput[]
    NOT?: study_reservationWhereInput | study_reservationWhereInput[]
    createAt?: DateTimeFilter<"study_reservation"> | Date | string
    updateAt?: DateTimeFilter<"study_reservation"> | Date | string
    userId?: StringFilter<"study_reservation"> | string
    seatId?: StringFilter<"study_reservation"> | string
    startTime?: DateTimeFilter<"study_reservation"> | Date | string
    endTime?: DateTimeFilter<"study_reservation"> | Date | string
    status?: StringFilter<"study_reservation"> | string
    user?: XOR<Study_userScalarRelationFilter, study_userWhereInput>
    seat?: XOR<Study_seatScalarRelationFilter, study_seatWhereInput>
  }, "uid">

  export type study_reservationOrderByWithAggregationInput = {
    uid?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    userId?: SortOrder
    seatId?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    status?: SortOrder
    _count?: study_reservationCountOrderByAggregateInput
    _max?: study_reservationMaxOrderByAggregateInput
    _min?: study_reservationMinOrderByAggregateInput
  }

  export type study_reservationScalarWhereWithAggregatesInput = {
    AND?: study_reservationScalarWhereWithAggregatesInput | study_reservationScalarWhereWithAggregatesInput[]
    OR?: study_reservationScalarWhereWithAggregatesInput[]
    NOT?: study_reservationScalarWhereWithAggregatesInput | study_reservationScalarWhereWithAggregatesInput[]
    uid?: StringWithAggregatesFilter<"study_reservation"> | string
    createAt?: DateTimeWithAggregatesFilter<"study_reservation"> | Date | string
    updateAt?: DateTimeWithAggregatesFilter<"study_reservation"> | Date | string
    userId?: StringWithAggregatesFilter<"study_reservation"> | string
    seatId?: StringWithAggregatesFilter<"study_reservation"> | string
    startTime?: DateTimeWithAggregatesFilter<"study_reservation"> | Date | string
    endTime?: DateTimeWithAggregatesFilter<"study_reservation"> | Date | string
    status?: StringWithAggregatesFilter<"study_reservation"> | string
  }

  export type study_messageWhereInput = {
    AND?: study_messageWhereInput | study_messageWhereInput[]
    OR?: study_messageWhereInput[]
    NOT?: study_messageWhereInput | study_messageWhereInput[]
    uid?: StringFilter<"study_message"> | string
    createAt?: DateTimeFilter<"study_message"> | Date | string
    updateAt?: DateTimeFilter<"study_message"> | Date | string
    userId?: StringFilter<"study_message"> | string
    content?: StringFilter<"study_message"> | string
    reply?: StringNullableFilter<"study_message"> | string | null
    status?: BoolFilter<"study_message"> | boolean
    user?: XOR<Study_userScalarRelationFilter, study_userWhereInput>
  }

  export type study_messageOrderByWithRelationInput = {
    uid?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    reply?: SortOrderInput | SortOrder
    status?: SortOrder
    user?: study_userOrderByWithRelationInput
    _relevance?: study_messageOrderByRelevanceInput
  }

  export type study_messageWhereUniqueInput = Prisma.AtLeast<{
    uid?: string
    AND?: study_messageWhereInput | study_messageWhereInput[]
    OR?: study_messageWhereInput[]
    NOT?: study_messageWhereInput | study_messageWhereInput[]
    createAt?: DateTimeFilter<"study_message"> | Date | string
    updateAt?: DateTimeFilter<"study_message"> | Date | string
    userId?: StringFilter<"study_message"> | string
    content?: StringFilter<"study_message"> | string
    reply?: StringNullableFilter<"study_message"> | string | null
    status?: BoolFilter<"study_message"> | boolean
    user?: XOR<Study_userScalarRelationFilter, study_userWhereInput>
  }, "uid">

  export type study_messageOrderByWithAggregationInput = {
    uid?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    reply?: SortOrderInput | SortOrder
    status?: SortOrder
    _count?: study_messageCountOrderByAggregateInput
    _max?: study_messageMaxOrderByAggregateInput
    _min?: study_messageMinOrderByAggregateInput
  }

  export type study_messageScalarWhereWithAggregatesInput = {
    AND?: study_messageScalarWhereWithAggregatesInput | study_messageScalarWhereWithAggregatesInput[]
    OR?: study_messageScalarWhereWithAggregatesInput[]
    NOT?: study_messageScalarWhereWithAggregatesInput | study_messageScalarWhereWithAggregatesInput[]
    uid?: StringWithAggregatesFilter<"study_message"> | string
    createAt?: DateTimeWithAggregatesFilter<"study_message"> | Date | string
    updateAt?: DateTimeWithAggregatesFilter<"study_message"> | Date | string
    userId?: StringWithAggregatesFilter<"study_message"> | string
    content?: StringWithAggregatesFilter<"study_message"> | string
    reply?: StringNullableWithAggregatesFilter<"study_message"> | string | null
    status?: BoolWithAggregatesFilter<"study_message"> | boolean
  }

  export type study_announcementWhereInput = {
    AND?: study_announcementWhereInput | study_announcementWhereInput[]
    OR?: study_announcementWhereInput[]
    NOT?: study_announcementWhereInput | study_announcementWhereInput[]
    uid?: StringFilter<"study_announcement"> | string
    createAt?: DateTimeFilter<"study_announcement"> | Date | string
    updateAt?: DateTimeFilter<"study_announcement"> | Date | string
    title?: StringFilter<"study_announcement"> | string
    content?: StringFilter<"study_announcement"> | string
    status?: BoolFilter<"study_announcement"> | boolean
  }

  export type study_announcementOrderByWithRelationInput = {
    uid?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    title?: SortOrder
    content?: SortOrder
    status?: SortOrder
    _relevance?: study_announcementOrderByRelevanceInput
  }

  export type study_announcementWhereUniqueInput = Prisma.AtLeast<{
    uid?: string
    AND?: study_announcementWhereInput | study_announcementWhereInput[]
    OR?: study_announcementWhereInput[]
    NOT?: study_announcementWhereInput | study_announcementWhereInput[]
    createAt?: DateTimeFilter<"study_announcement"> | Date | string
    updateAt?: DateTimeFilter<"study_announcement"> | Date | string
    title?: StringFilter<"study_announcement"> | string
    content?: StringFilter<"study_announcement"> | string
    status?: BoolFilter<"study_announcement"> | boolean
  }, "uid">

  export type study_announcementOrderByWithAggregationInput = {
    uid?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    title?: SortOrder
    content?: SortOrder
    status?: SortOrder
    _count?: study_announcementCountOrderByAggregateInput
    _max?: study_announcementMaxOrderByAggregateInput
    _min?: study_announcementMinOrderByAggregateInput
  }

  export type study_announcementScalarWhereWithAggregatesInput = {
    AND?: study_announcementScalarWhereWithAggregatesInput | study_announcementScalarWhereWithAggregatesInput[]
    OR?: study_announcementScalarWhereWithAggregatesInput[]
    NOT?: study_announcementScalarWhereWithAggregatesInput | study_announcementScalarWhereWithAggregatesInput[]
    uid?: StringWithAggregatesFilter<"study_announcement"> | string
    createAt?: DateTimeWithAggregatesFilter<"study_announcement"> | Date | string
    updateAt?: DateTimeWithAggregatesFilter<"study_announcement"> | Date | string
    title?: StringWithAggregatesFilter<"study_announcement"> | string
    content?: StringWithAggregatesFilter<"study_announcement"> | string
    status?: BoolWithAggregatesFilter<"study_announcement"> | boolean
  }

  export type sys_userCreateInput = {
    uid?: string
    createAt?: Date | string
    updateAt?: Date | string
    name: string
    password: string
    salt: string
    accounts?: sys_accountCreateNestedManyWithoutUserInput
    role?: sys_roleCreateNestedOneWithoutUsersInput
    ban_menus?: sys_user_ban_menuCreateNestedManyWithoutUserInput
  }

  export type sys_userUncheckedCreateInput = {
    uid?: string
    createAt?: Date | string
    updateAt?: Date | string
    name: string
    password: string
    salt: string
    roleId?: string | null
    accounts?: sys_accountUncheckedCreateNestedManyWithoutUserInput
    ban_menus?: sys_user_ban_menuUncheckedCreateNestedManyWithoutUserInput
  }

  export type sys_userUpdateInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    salt?: StringFieldUpdateOperationsInput | string
    accounts?: sys_accountUpdateManyWithoutUserNestedInput
    role?: sys_roleUpdateOneWithoutUsersNestedInput
    ban_menus?: sys_user_ban_menuUpdateManyWithoutUserNestedInput
  }

  export type sys_userUncheckedUpdateInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    salt?: StringFieldUpdateOperationsInput | string
    roleId?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: sys_accountUncheckedUpdateManyWithoutUserNestedInput
    ban_menus?: sys_user_ban_menuUncheckedUpdateManyWithoutUserNestedInput
  }

  export type sys_userCreateManyInput = {
    uid?: string
    createAt?: Date | string
    updateAt?: Date | string
    name: string
    password: string
    salt: string
    roleId?: string | null
  }

  export type sys_userUpdateManyMutationInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    salt?: StringFieldUpdateOperationsInput | string
  }

  export type sys_userUncheckedUpdateManyInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    salt?: StringFieldUpdateOperationsInput | string
    roleId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type sys_accountCreateInput = {
    createAt?: Date | string
    updateAt?: Date | string
    provider: $Enums.sys_account_provider
    provider_id: string
    user?: sys_userCreateNestedOneWithoutAccountsInput
  }

  export type sys_accountUncheckedCreateInput = {
    createAt?: Date | string
    updateAt?: Date | string
    provider: $Enums.sys_account_provider
    provider_id: string
    userId?: string | null
  }

  export type sys_accountUpdateInput = {
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    provider?: Enumsys_account_providerFieldUpdateOperationsInput | $Enums.sys_account_provider
    provider_id?: StringFieldUpdateOperationsInput | string
    user?: sys_userUpdateOneWithoutAccountsNestedInput
  }

  export type sys_accountUncheckedUpdateInput = {
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    provider?: Enumsys_account_providerFieldUpdateOperationsInput | $Enums.sys_account_provider
    provider_id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type sys_accountCreateManyInput = {
    createAt?: Date | string
    updateAt?: Date | string
    provider: $Enums.sys_account_provider
    provider_id: string
    userId?: string | null
  }

  export type sys_accountUpdateManyMutationInput = {
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    provider?: Enumsys_account_providerFieldUpdateOperationsInput | $Enums.sys_account_provider
    provider_id?: StringFieldUpdateOperationsInput | string
  }

  export type sys_accountUncheckedUpdateManyInput = {
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    provider?: Enumsys_account_providerFieldUpdateOperationsInput | $Enums.sys_account_provider
    provider_id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type sys_menuCreateInput = {
    uid?: string
    createAt?: Date | string
    updateAt?: Date | string
    name: string
    path: string
    powers: number
    comment?: string | null
    parent?: sys_menuCreateNestedOneWithoutChildrenInput
    children?: sys_menuCreateNestedManyWithoutParentInput
    roles?: sys_menu_on_roleCreateNestedManyWithoutMenuInput
    user_bans?: sys_user_ban_menuCreateNestedManyWithoutMenuInput
  }

  export type sys_menuUncheckedCreateInput = {
    uid?: string
    createAt?: Date | string
    updateAt?: Date | string
    name: string
    path: string
    powers: number
    comment?: string | null
    parentId?: string | null
    children?: sys_menuUncheckedCreateNestedManyWithoutParentInput
    roles?: sys_menu_on_roleUncheckedCreateNestedManyWithoutMenuInput
    user_bans?: sys_user_ban_menuUncheckedCreateNestedManyWithoutMenuInput
  }

  export type sys_menuUpdateInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    powers?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    parent?: sys_menuUpdateOneWithoutChildrenNestedInput
    children?: sys_menuUpdateManyWithoutParentNestedInput
    roles?: sys_menu_on_roleUpdateManyWithoutMenuNestedInput
    user_bans?: sys_user_ban_menuUpdateManyWithoutMenuNestedInput
  }

  export type sys_menuUncheckedUpdateInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    powers?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    children?: sys_menuUncheckedUpdateManyWithoutParentNestedInput
    roles?: sys_menu_on_roleUncheckedUpdateManyWithoutMenuNestedInput
    user_bans?: sys_user_ban_menuUncheckedUpdateManyWithoutMenuNestedInput
  }

  export type sys_menuCreateManyInput = {
    uid?: string
    createAt?: Date | string
    updateAt?: Date | string
    name: string
    path: string
    powers: number
    comment?: string | null
    parentId?: string | null
  }

  export type sys_menuUpdateManyMutationInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    powers?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type sys_menuUncheckedUpdateManyInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    powers?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type sys_user_ban_menuCreateInput = {
    user: sys_userCreateNestedOneWithoutBan_menusInput
    menu: sys_menuCreateNestedOneWithoutUser_bansInput
  }

  export type sys_user_ban_menuUncheckedCreateInput = {
    userId: string
    menuId: string
  }

  export type sys_user_ban_menuUpdateInput = {
    user?: sys_userUpdateOneRequiredWithoutBan_menusNestedInput
    menu?: sys_menuUpdateOneRequiredWithoutUser_bansNestedInput
  }

  export type sys_user_ban_menuUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    menuId?: StringFieldUpdateOperationsInput | string
  }

  export type sys_user_ban_menuCreateManyInput = {
    userId: string
    menuId: string
  }

  export type sys_user_ban_menuUpdateManyMutationInput = {

  }

  export type sys_user_ban_menuUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    menuId?: StringFieldUpdateOperationsInput | string
  }

  export type sys_menu_on_roleCreateInput = {
    power?: bigint | number
    menu: sys_menuCreateNestedOneWithoutRolesInput
    role: sys_roleCreateNestedOneWithoutMenusInput
  }

  export type sys_menu_on_roleUncheckedCreateInput = {
    roleId: string
    menuId: string
    power?: bigint | number
  }

  export type sys_menu_on_roleUpdateInput = {
    power?: BigIntFieldUpdateOperationsInput | bigint | number
    menu?: sys_menuUpdateOneRequiredWithoutRolesNestedInput
    role?: sys_roleUpdateOneRequiredWithoutMenusNestedInput
  }

  export type sys_menu_on_roleUncheckedUpdateInput = {
    roleId?: StringFieldUpdateOperationsInput | string
    menuId?: StringFieldUpdateOperationsInput | string
    power?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type sys_menu_on_roleCreateManyInput = {
    roleId: string
    menuId: string
    power?: bigint | number
  }

  export type sys_menu_on_roleUpdateManyMutationInput = {
    power?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type sys_menu_on_roleUncheckedUpdateManyInput = {
    roleId?: StringFieldUpdateOperationsInput | string
    menuId?: StringFieldUpdateOperationsInput | string
    power?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type sys_roleCreateInput = {
    uid?: string
    createAt?: Date | string
    updateAt?: Date | string
    name: string
    status?: boolean
    comment?: string | null
    menus?: sys_menu_on_roleCreateNestedManyWithoutRoleInput
    users?: sys_userCreateNestedManyWithoutRoleInput
  }

  export type sys_roleUncheckedCreateInput = {
    uid?: string
    createAt?: Date | string
    updateAt?: Date | string
    name: string
    status?: boolean
    comment?: string | null
    menus?: sys_menu_on_roleUncheckedCreateNestedManyWithoutRoleInput
    users?: sys_userUncheckedCreateNestedManyWithoutRoleInput
  }

  export type sys_roleUpdateInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    menus?: sys_menu_on_roleUpdateManyWithoutRoleNestedInput
    users?: sys_userUpdateManyWithoutRoleNestedInput
  }

  export type sys_roleUncheckedUpdateInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    menus?: sys_menu_on_roleUncheckedUpdateManyWithoutRoleNestedInput
    users?: sys_userUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type sys_roleCreateManyInput = {
    uid?: string
    createAt?: Date | string
    updateAt?: Date | string
    name: string
    status?: boolean
    comment?: string | null
  }

  export type sys_roleUpdateManyMutationInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    comment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type sys_roleUncheckedUpdateManyInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    comment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type blog_userCreateInput = {
    uid?: string
    createAt?: Date | string
    updateAt?: Date | string
    name: string
    posts?: blog_postsCreateNestedManyWithoutUserInput
  }

  export type blog_userUncheckedCreateInput = {
    uid?: string
    createAt?: Date | string
    updateAt?: Date | string
    name: string
    posts?: blog_postsUncheckedCreateNestedManyWithoutUserInput
  }

  export type blog_userUpdateInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    posts?: blog_postsUpdateManyWithoutUserNestedInput
  }

  export type blog_userUncheckedUpdateInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    posts?: blog_postsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type blog_userCreateManyInput = {
    uid?: string
    createAt?: Date | string
    updateAt?: Date | string
    name: string
  }

  export type blog_userUpdateManyMutationInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type blog_userUncheckedUpdateManyInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type blog_categoriesCreateInput = {
    uid?: string
    createAt?: Date | string
    updateAt?: Date | string
    name: string
    posts?: blog_postsCreateNestedManyWithoutCategoriesInput
  }

  export type blog_categoriesUncheckedCreateInput = {
    uid?: string
    createAt?: Date | string
    updateAt?: Date | string
    name: string
    posts?: blog_postsUncheckedCreateNestedManyWithoutCategoriesInput
  }

  export type blog_categoriesUpdateInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    posts?: blog_postsUpdateManyWithoutCategoriesNestedInput
  }

  export type blog_categoriesUncheckedUpdateInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    posts?: blog_postsUncheckedUpdateManyWithoutCategoriesNestedInput
  }

  export type blog_categoriesCreateManyInput = {
    uid?: string
    createAt?: Date | string
    updateAt?: Date | string
    name: string
  }

  export type blog_categoriesUpdateManyMutationInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type blog_categoriesUncheckedUpdateManyInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type blog_postsCreateInput = {
    uid?: string
    createAt?: Date | string
    updateAt?: Date | string
    title: string
    content: string
    categories?: blog_categoriesCreateNestedOneWithoutPostsInput
    user: blog_userCreateNestedOneWithoutPostsInput
    tags?: blog_posts_on_tagsCreateNestedManyWithoutPostsInput
  }

  export type blog_postsUncheckedCreateInput = {
    uid?: string
    createAt?: Date | string
    updateAt?: Date | string
    title: string
    content: string
    userId: string
    categoriesId?: string | null
    tags?: blog_posts_on_tagsUncheckedCreateNestedManyWithoutPostsInput
  }

  export type blog_postsUpdateInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    categories?: blog_categoriesUpdateOneWithoutPostsNestedInput
    user?: blog_userUpdateOneRequiredWithoutPostsNestedInput
    tags?: blog_posts_on_tagsUpdateManyWithoutPostsNestedInput
  }

  export type blog_postsUncheckedUpdateInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    categoriesId?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: blog_posts_on_tagsUncheckedUpdateManyWithoutPostsNestedInput
  }

  export type blog_postsCreateManyInput = {
    uid?: string
    createAt?: Date | string
    updateAt?: Date | string
    title: string
    content: string
    userId: string
    categoriesId?: string | null
  }

  export type blog_postsUpdateManyMutationInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
  }

  export type blog_postsUncheckedUpdateManyInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    categoriesId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type blog_noticeCreateInput = {
    uid?: string
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type blog_noticeUncheckedCreateInput = {
    uid?: string
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type blog_noticeUpdateInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type blog_noticeUncheckedUpdateInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type blog_noticeCreateManyInput = {
    uid?: string
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type blog_noticeUpdateManyMutationInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type blog_noticeUncheckedUpdateManyInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type blog_posts_on_tagsCreateInput = {
    posts: blog_postsCreateNestedOneWithoutTagsInput
    tag: blog_tagCreateNestedOneWithoutBlog_posts_on_tagsInput
  }

  export type blog_posts_on_tagsUncheckedCreateInput = {
    postsId: string
    tagId: string
  }

  export type blog_posts_on_tagsUpdateInput = {
    posts?: blog_postsUpdateOneRequiredWithoutTagsNestedInput
    tag?: blog_tagUpdateOneRequiredWithoutBlog_posts_on_tagsNestedInput
  }

  export type blog_posts_on_tagsUncheckedUpdateInput = {
    postsId?: StringFieldUpdateOperationsInput | string
    tagId?: StringFieldUpdateOperationsInput | string
  }

  export type blog_posts_on_tagsCreateManyInput = {
    postsId: string
    tagId: string
  }

  export type blog_posts_on_tagsUpdateManyMutationInput = {

  }

  export type blog_posts_on_tagsUncheckedUpdateManyInput = {
    postsId?: StringFieldUpdateOperationsInput | string
    tagId?: StringFieldUpdateOperationsInput | string
  }

  export type blog_tagCreateInput = {
    uid?: string
    createAt?: Date | string
    updateAt?: Date | string
    name: string
    blog_posts_on_tags?: blog_posts_on_tagsCreateNestedManyWithoutTagInput
  }

  export type blog_tagUncheckedCreateInput = {
    uid?: string
    createAt?: Date | string
    updateAt?: Date | string
    name: string
    blog_posts_on_tags?: blog_posts_on_tagsUncheckedCreateNestedManyWithoutTagInput
  }

  export type blog_tagUpdateInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    blog_posts_on_tags?: blog_posts_on_tagsUpdateManyWithoutTagNestedInput
  }

  export type blog_tagUncheckedUpdateInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    blog_posts_on_tags?: blog_posts_on_tagsUncheckedUpdateManyWithoutTagNestedInput
  }

  export type blog_tagCreateManyInput = {
    uid?: string
    createAt?: Date | string
    updateAt?: Date | string
    name: string
  }

  export type blog_tagUpdateManyMutationInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type blog_tagUncheckedUpdateManyInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type file_userCreateInput = {
    uid?: string
    createAt?: Date | string
    updateAt?: Date | string
    name: string
    is_admin?: boolean
    medias?: file_user_on_mediaCreateNestedManyWithoutUserInput
    folders?: file_folderCreateNestedManyWithoutUserInput
    file_config?: file_configCreateNestedOneWithoutUserInput
    keys?: file_keysCreateNestedManyWithoutUserInput
  }

  export type file_userUncheckedCreateInput = {
    uid?: string
    createAt?: Date | string
    updateAt?: Date | string
    name: string
    is_admin?: boolean
    medias?: file_user_on_mediaUncheckedCreateNestedManyWithoutUserInput
    folders?: file_folderUncheckedCreateNestedManyWithoutUserInput
    file_config?: file_configUncheckedCreateNestedOneWithoutUserInput
    keys?: file_keysUncheckedCreateNestedManyWithoutUserInput
  }

  export type file_userUpdateInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    is_admin?: BoolFieldUpdateOperationsInput | boolean
    medias?: file_user_on_mediaUpdateManyWithoutUserNestedInput
    folders?: file_folderUpdateManyWithoutUserNestedInput
    file_config?: file_configUpdateOneWithoutUserNestedInput
    keys?: file_keysUpdateManyWithoutUserNestedInput
  }

  export type file_userUncheckedUpdateInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    is_admin?: BoolFieldUpdateOperationsInput | boolean
    medias?: file_user_on_mediaUncheckedUpdateManyWithoutUserNestedInput
    folders?: file_folderUncheckedUpdateManyWithoutUserNestedInput
    file_config?: file_configUncheckedUpdateOneWithoutUserNestedInput
    keys?: file_keysUncheckedUpdateManyWithoutUserNestedInput
  }

  export type file_userCreateManyInput = {
    uid?: string
    createAt?: Date | string
    updateAt?: Date | string
    name: string
    is_admin?: boolean
  }

  export type file_userUpdateManyMutationInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    is_admin?: BoolFieldUpdateOperationsInput | boolean
  }

  export type file_userUncheckedUpdateManyInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    is_admin?: BoolFieldUpdateOperationsInput | boolean
  }

  export type file_keysCreateInput = {
    api_key: string
    api_secret: string
    user: file_userCreateNestedOneWithoutKeysInput
  }

  export type file_keysUncheckedCreateInput = {
    api_key: string
    api_secret: string
    userId: string
  }

  export type file_keysUpdateInput = {
    api_key?: StringFieldUpdateOperationsInput | string
    api_secret?: StringFieldUpdateOperationsInput | string
    user?: file_userUpdateOneRequiredWithoutKeysNestedInput
  }

  export type file_keysUncheckedUpdateInput = {
    api_key?: StringFieldUpdateOperationsInput | string
    api_secret?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type file_keysCreateManyInput = {
    api_key: string
    api_secret: string
    userId: string
  }

  export type file_keysUpdateManyMutationInput = {
    api_key?: StringFieldUpdateOperationsInput | string
    api_secret?: StringFieldUpdateOperationsInput | string
  }

  export type file_keysUncheckedUpdateManyInput = {
    api_key?: StringFieldUpdateOperationsInput | string
    api_secret?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type file_configCreateInput = {
    uid?: string
    user: file_userCreateNestedOneWithoutFile_configInput
  }

  export type file_configUncheckedCreateInput = {
    uid?: string
    userId: string
  }

  export type file_configUpdateInput = {
    uid?: StringFieldUpdateOperationsInput | string
    user?: file_userUpdateOneRequiredWithoutFile_configNestedInput
  }

  export type file_configUncheckedUpdateInput = {
    uid?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type file_configCreateManyInput = {
    uid?: string
    userId: string
  }

  export type file_configUpdateManyMutationInput = {
    uid?: StringFieldUpdateOperationsInput | string
  }

  export type file_configUncheckedUpdateManyInput = {
    uid?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type file_user_on_mediaCreateInput = {
    comment?: string | null
    user: file_userCreateNestedOneWithoutMediasInput
    media: file_mediaCreateNestedOneWithoutUsersInput
  }

  export type file_user_on_mediaUncheckedCreateInput = {
    userId: string
    mediaId: string
    comment?: string | null
  }

  export type file_user_on_mediaUpdateInput = {
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    user?: file_userUpdateOneRequiredWithoutMediasNestedInput
    media?: file_mediaUpdateOneRequiredWithoutUsersNestedInput
  }

  export type file_user_on_mediaUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    mediaId?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type file_user_on_mediaCreateManyInput = {
    userId: string
    mediaId: string
    comment?: string | null
  }

  export type file_user_on_mediaUpdateManyMutationInput = {
    comment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type file_user_on_mediaUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    mediaId?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type file_blockCreateInput = {
    uid?: string
    createAt?: Date | string
    updateAt?: Date | string
    hash_key: string
    size: number
    media: file_mediaCreateNestedOneWithoutBlocksInput
  }

  export type file_blockUncheckedCreateInput = {
    uid?: string
    createAt?: Date | string
    updateAt?: Date | string
    mediaId: string
    hash_key: string
    size: number
  }

  export type file_blockUpdateInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hash_key?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    media?: file_mediaUpdateOneRequiredWithoutBlocksNestedInput
  }

  export type file_blockUncheckedUpdateInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mediaId?: StringFieldUpdateOperationsInput | string
    hash_key?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
  }

  export type file_blockCreateManyInput = {
    uid?: string
    createAt?: Date | string
    updateAt?: Date | string
    mediaId: string
    hash_key: string
    size: number
  }

  export type file_blockUpdateManyMutationInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hash_key?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
  }

  export type file_blockUncheckedUpdateManyInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mediaId?: StringFieldUpdateOperationsInput | string
    hash_key?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
  }

  export type file_mediaCreateInput = {
    uid?: string
    createAt?: Date | string
    updateAt?: Date | string
    type: $Enums.file_type
    name: string
    hash_key: string
    size: number
    disable?: boolean
    comment?: string | null
    blocks?: file_blockCreateNestedManyWithoutMediaInput
    users?: file_user_on_mediaCreateNestedManyWithoutMediaInput
    folders?: file_media_on_folderCreateNestedManyWithoutMediaInput
  }

  export type file_mediaUncheckedCreateInput = {
    uid?: string
    createAt?: Date | string
    updateAt?: Date | string
    type: $Enums.file_type
    name: string
    hash_key: string
    size: number
    disable?: boolean
    comment?: string | null
    blocks?: file_blockUncheckedCreateNestedManyWithoutMediaInput
    users?: file_user_on_mediaUncheckedCreateNestedManyWithoutMediaInput
    folders?: file_media_on_folderUncheckedCreateNestedManyWithoutMediaInput
  }

  export type file_mediaUpdateInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: Enumfile_typeFieldUpdateOperationsInput | $Enums.file_type
    name?: StringFieldUpdateOperationsInput | string
    hash_key?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    disable?: BoolFieldUpdateOperationsInput | boolean
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    blocks?: file_blockUpdateManyWithoutMediaNestedInput
    users?: file_user_on_mediaUpdateManyWithoutMediaNestedInput
    folders?: file_media_on_folderUpdateManyWithoutMediaNestedInput
  }

  export type file_mediaUncheckedUpdateInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: Enumfile_typeFieldUpdateOperationsInput | $Enums.file_type
    name?: StringFieldUpdateOperationsInput | string
    hash_key?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    disable?: BoolFieldUpdateOperationsInput | boolean
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    blocks?: file_blockUncheckedUpdateManyWithoutMediaNestedInput
    users?: file_user_on_mediaUncheckedUpdateManyWithoutMediaNestedInput
    folders?: file_media_on_folderUncheckedUpdateManyWithoutMediaNestedInput
  }

  export type file_mediaCreateManyInput = {
    uid?: string
    createAt?: Date | string
    updateAt?: Date | string
    type: $Enums.file_type
    name: string
    hash_key: string
    size: number
    disable?: boolean
    comment?: string | null
  }

  export type file_mediaUpdateManyMutationInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: Enumfile_typeFieldUpdateOperationsInput | $Enums.file_type
    name?: StringFieldUpdateOperationsInput | string
    hash_key?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    disable?: BoolFieldUpdateOperationsInput | boolean
    comment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type file_mediaUncheckedUpdateManyInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: Enumfile_typeFieldUpdateOperationsInput | $Enums.file_type
    name?: StringFieldUpdateOperationsInput | string
    hash_key?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    disable?: BoolFieldUpdateOperationsInput | boolean
    comment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type file_media_on_folderCreateInput = {
    media: file_mediaCreateNestedOneWithoutFoldersInput
    folder: file_folderCreateNestedOneWithoutMediasInput
  }

  export type file_media_on_folderUncheckedCreateInput = {
    mediaId: string
    folderId: string
  }

  export type file_media_on_folderUpdateInput = {
    media?: file_mediaUpdateOneRequiredWithoutFoldersNestedInput
    folder?: file_folderUpdateOneRequiredWithoutMediasNestedInput
  }

  export type file_media_on_folderUncheckedUpdateInput = {
    mediaId?: StringFieldUpdateOperationsInput | string
    folderId?: StringFieldUpdateOperationsInput | string
  }

  export type file_media_on_folderCreateManyInput = {
    mediaId: string
    folderId: string
  }

  export type file_media_on_folderUpdateManyMutationInput = {

  }

  export type file_media_on_folderUncheckedUpdateManyInput = {
    mediaId?: StringFieldUpdateOperationsInput | string
    folderId?: StringFieldUpdateOperationsInput | string
  }

  export type file_folderCreateInput = {
    uid?: string
    createAt?: Date | string
    updateAt?: Date | string
    name: string
    user: file_userCreateNestedOneWithoutFoldersInput
    parent?: file_folderCreateNestedOneWithoutChildrenInput
    children?: file_folderCreateNestedManyWithoutParentInput
    medias?: file_media_on_folderCreateNestedManyWithoutFolderInput
  }

  export type file_folderUncheckedCreateInput = {
    uid?: string
    createAt?: Date | string
    updateAt?: Date | string
    name: string
    userId: string
    parentId?: string | null
    children?: file_folderUncheckedCreateNestedManyWithoutParentInput
    medias?: file_media_on_folderUncheckedCreateNestedManyWithoutFolderInput
  }

  export type file_folderUpdateInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    user?: file_userUpdateOneRequiredWithoutFoldersNestedInput
    parent?: file_folderUpdateOneWithoutChildrenNestedInput
    children?: file_folderUpdateManyWithoutParentNestedInput
    medias?: file_media_on_folderUpdateManyWithoutFolderNestedInput
  }

  export type file_folderUncheckedUpdateInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    children?: file_folderUncheckedUpdateManyWithoutParentNestedInput
    medias?: file_media_on_folderUncheckedUpdateManyWithoutFolderNestedInput
  }

  export type file_folderCreateManyInput = {
    uid?: string
    createAt?: Date | string
    updateAt?: Date | string
    name: string
    userId: string
    parentId?: string | null
  }

  export type file_folderUpdateManyMutationInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type file_folderUncheckedUpdateManyInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type book_userCreateInput = {
    id?: string
    createAt?: Date | string
    updateAt?: Date | string
    name: string
    email: string
    password: string
    role?: $Enums.book_role
    book_roleId: string
    borrowed?: book_borrowedCreateNestedManyWithoutUserInput
    book_borrow_history?: book_borrow_historyCreateNestedManyWithoutUserInput
    book_rating?: book_ratingCreateNestedManyWithoutUserInput
  }

  export type book_userUncheckedCreateInput = {
    id?: string
    createAt?: Date | string
    updateAt?: Date | string
    name: string
    email: string
    password: string
    role?: $Enums.book_role
    book_roleId: string
    borrowed?: book_borrowedUncheckedCreateNestedManyWithoutUserInput
    book_borrow_history?: book_borrow_historyUncheckedCreateNestedManyWithoutUserInput
    book_rating?: book_ratingUncheckedCreateNestedManyWithoutUserInput
  }

  export type book_userUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: Enumbook_roleFieldUpdateOperationsInput | $Enums.book_role
    book_roleId?: StringFieldUpdateOperationsInput | string
    borrowed?: book_borrowedUpdateManyWithoutUserNestedInput
    book_borrow_history?: book_borrow_historyUpdateManyWithoutUserNestedInput
    book_rating?: book_ratingUpdateManyWithoutUserNestedInput
  }

  export type book_userUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: Enumbook_roleFieldUpdateOperationsInput | $Enums.book_role
    book_roleId?: StringFieldUpdateOperationsInput | string
    borrowed?: book_borrowedUncheckedUpdateManyWithoutUserNestedInput
    book_borrow_history?: book_borrow_historyUncheckedUpdateManyWithoutUserNestedInput
    book_rating?: book_ratingUncheckedUpdateManyWithoutUserNestedInput
  }

  export type book_userCreateManyInput = {
    id?: string
    createAt?: Date | string
    updateAt?: Date | string
    name: string
    email: string
    password: string
    role?: $Enums.book_role
    book_roleId: string
  }

  export type book_userUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: Enumbook_roleFieldUpdateOperationsInput | $Enums.book_role
    book_roleId?: StringFieldUpdateOperationsInput | string
  }

  export type book_userUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: Enumbook_roleFieldUpdateOperationsInput | $Enums.book_role
    book_roleId?: StringFieldUpdateOperationsInput | string
  }

  export type book_bookCreateInput = {
    id?: string
    createAt?: Date | string
    updateAt?: Date | string
    title: string
    author: string
    isbn: string
    description?: string | null
    publication: Date | string
    available?: boolean
    category: book_categoryCreateNestedOneWithoutBooksInput
    borrowed?: book_borrowedCreateNestedManyWithoutBookInput
    book_borrow_history?: book_borrow_historyCreateNestedManyWithoutBookInput
    book_rating?: book_ratingCreateNestedManyWithoutBookInput
  }

  export type book_bookUncheckedCreateInput = {
    id?: string
    createAt?: Date | string
    updateAt?: Date | string
    title: string
    author: string
    isbn: string
    description?: string | null
    publication: Date | string
    categoryId: string
    available?: boolean
    borrowed?: book_borrowedUncheckedCreateNestedManyWithoutBookInput
    book_borrow_history?: book_borrow_historyUncheckedCreateNestedManyWithoutBookInput
    book_rating?: book_ratingUncheckedCreateNestedManyWithoutBookInput
  }

  export type book_bookUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    isbn?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    publication?: DateTimeFieldUpdateOperationsInput | Date | string
    available?: BoolFieldUpdateOperationsInput | boolean
    category?: book_categoryUpdateOneRequiredWithoutBooksNestedInput
    borrowed?: book_borrowedUpdateManyWithoutBookNestedInput
    book_borrow_history?: book_borrow_historyUpdateManyWithoutBookNestedInput
    book_rating?: book_ratingUpdateManyWithoutBookNestedInput
  }

  export type book_bookUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    isbn?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    publication?: DateTimeFieldUpdateOperationsInput | Date | string
    categoryId?: StringFieldUpdateOperationsInput | string
    available?: BoolFieldUpdateOperationsInput | boolean
    borrowed?: book_borrowedUncheckedUpdateManyWithoutBookNestedInput
    book_borrow_history?: book_borrow_historyUncheckedUpdateManyWithoutBookNestedInput
    book_rating?: book_ratingUncheckedUpdateManyWithoutBookNestedInput
  }

  export type book_bookCreateManyInput = {
    id?: string
    createAt?: Date | string
    updateAt?: Date | string
    title: string
    author: string
    isbn: string
    description?: string | null
    publication: Date | string
    categoryId: string
    available?: boolean
  }

  export type book_bookUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    isbn?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    publication?: DateTimeFieldUpdateOperationsInput | Date | string
    available?: BoolFieldUpdateOperationsInput | boolean
  }

  export type book_bookUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    isbn?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    publication?: DateTimeFieldUpdateOperationsInput | Date | string
    categoryId?: StringFieldUpdateOperationsInput | string
    available?: BoolFieldUpdateOperationsInput | boolean
  }

  export type book_categoryCreateInput = {
    id?: string
    createAt?: Date | string
    updateAt?: Date | string
    categoryName: string
    books?: book_bookCreateNestedManyWithoutCategoryInput
  }

  export type book_categoryUncheckedCreateInput = {
    id?: string
    createAt?: Date | string
    updateAt?: Date | string
    categoryName: string
    books?: book_bookUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type book_categoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categoryName?: StringFieldUpdateOperationsInput | string
    books?: book_bookUpdateManyWithoutCategoryNestedInput
  }

  export type book_categoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categoryName?: StringFieldUpdateOperationsInput | string
    books?: book_bookUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type book_categoryCreateManyInput = {
    id?: string
    createAt?: Date | string
    updateAt?: Date | string
    categoryName: string
  }

  export type book_categoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categoryName?: StringFieldUpdateOperationsInput | string
  }

  export type book_categoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categoryName?: StringFieldUpdateOperationsInput | string
  }

  export type book_borrowedCreateInput = {
    id?: string
    borrowDate?: Date | string
    returnDate?: Date | string | null
    dueDate: Date | string
    returned?: boolean
    user: book_userCreateNestedOneWithoutBorrowedInput
    book: book_bookCreateNestedOneWithoutBorrowedInput
  }

  export type book_borrowedUncheckedCreateInput = {
    id?: string
    borrowDate?: Date | string
    returnDate?: Date | string | null
    dueDate: Date | string
    userId: string
    bookId: string
    returned?: boolean
  }

  export type book_borrowedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    borrowDate?: DateTimeFieldUpdateOperationsInput | Date | string
    returnDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    returned?: BoolFieldUpdateOperationsInput | boolean
    user?: book_userUpdateOneRequiredWithoutBorrowedNestedInput
    book?: book_bookUpdateOneRequiredWithoutBorrowedNestedInput
  }

  export type book_borrowedUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    borrowDate?: DateTimeFieldUpdateOperationsInput | Date | string
    returnDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    bookId?: StringFieldUpdateOperationsInput | string
    returned?: BoolFieldUpdateOperationsInput | boolean
  }

  export type book_borrowedCreateManyInput = {
    id?: string
    borrowDate?: Date | string
    returnDate?: Date | string | null
    dueDate: Date | string
    userId: string
    bookId: string
    returned?: boolean
  }

  export type book_borrowedUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    borrowDate?: DateTimeFieldUpdateOperationsInput | Date | string
    returnDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    returned?: BoolFieldUpdateOperationsInput | boolean
  }

  export type book_borrowedUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    borrowDate?: DateTimeFieldUpdateOperationsInput | Date | string
    returnDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    bookId?: StringFieldUpdateOperationsInput | string
    returned?: BoolFieldUpdateOperationsInput | boolean
  }

  export type book_borrow_historyCreateInput = {
    id?: string
    borrowDate?: Date | string
    returnDate?: Date | string | null
    returned?: boolean
    user: book_userCreateNestedOneWithoutBook_borrow_historyInput
    book: book_bookCreateNestedOneWithoutBook_borrow_historyInput
  }

  export type book_borrow_historyUncheckedCreateInput = {
    id?: string
    borrowDate?: Date | string
    returnDate?: Date | string | null
    userId: string
    bookId: string
    returned?: boolean
  }

  export type book_borrow_historyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    borrowDate?: DateTimeFieldUpdateOperationsInput | Date | string
    returnDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    returned?: BoolFieldUpdateOperationsInput | boolean
    user?: book_userUpdateOneRequiredWithoutBook_borrow_historyNestedInput
    book?: book_bookUpdateOneRequiredWithoutBook_borrow_historyNestedInput
  }

  export type book_borrow_historyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    borrowDate?: DateTimeFieldUpdateOperationsInput | Date | string
    returnDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: StringFieldUpdateOperationsInput | string
    bookId?: StringFieldUpdateOperationsInput | string
    returned?: BoolFieldUpdateOperationsInput | boolean
  }

  export type book_borrow_historyCreateManyInput = {
    id?: string
    borrowDate?: Date | string
    returnDate?: Date | string | null
    userId: string
    bookId: string
    returned?: boolean
  }

  export type book_borrow_historyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    borrowDate?: DateTimeFieldUpdateOperationsInput | Date | string
    returnDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    returned?: BoolFieldUpdateOperationsInput | boolean
  }

  export type book_borrow_historyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    borrowDate?: DateTimeFieldUpdateOperationsInput | Date | string
    returnDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: StringFieldUpdateOperationsInput | string
    bookId?: StringFieldUpdateOperationsInput | string
    returned?: BoolFieldUpdateOperationsInput | boolean
  }

  export type book_ratingCreateInput = {
    id?: string
    createAt?: Date | string
    updateAt?: Date | string
    rating: number
    review?: string | null
    user: book_userCreateNestedOneWithoutBook_ratingInput
    book: book_bookCreateNestedOneWithoutBook_ratingInput
  }

  export type book_ratingUncheckedCreateInput = {
    id?: string
    createAt?: Date | string
    updateAt?: Date | string
    rating: number
    review?: string | null
    userId: string
    bookId: string
  }

  export type book_ratingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rating?: FloatFieldUpdateOperationsInput | number
    review?: NullableStringFieldUpdateOperationsInput | string | null
    user?: book_userUpdateOneRequiredWithoutBook_ratingNestedInput
    book?: book_bookUpdateOneRequiredWithoutBook_ratingNestedInput
  }

  export type book_ratingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rating?: FloatFieldUpdateOperationsInput | number
    review?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    bookId?: StringFieldUpdateOperationsInput | string
  }

  export type book_ratingCreateManyInput = {
    id?: string
    createAt?: Date | string
    updateAt?: Date | string
    rating: number
    review?: string | null
    userId: string
    bookId: string
  }

  export type book_ratingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rating?: FloatFieldUpdateOperationsInput | number
    review?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type book_ratingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rating?: FloatFieldUpdateOperationsInput | number
    review?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    bookId?: StringFieldUpdateOperationsInput | string
  }

  export type study_userCreateInput = {
    uid?: string
    createAt?: Date | string
    updateAt?: Date | string
    name: string
    account: string
    password: string
    isAdmin?: boolean
    reservation?: study_reservationCreateNestedManyWithoutUserInput
    message?: study_messageCreateNestedManyWithoutUserInput
  }

  export type study_userUncheckedCreateInput = {
    uid?: string
    createAt?: Date | string
    updateAt?: Date | string
    name: string
    account: string
    password: string
    isAdmin?: boolean
    reservation?: study_reservationUncheckedCreateNestedManyWithoutUserInput
    message?: study_messageUncheckedCreateNestedManyWithoutUserInput
  }

  export type study_userUpdateInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    account?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    reservation?: study_reservationUpdateManyWithoutUserNestedInput
    message?: study_messageUpdateManyWithoutUserNestedInput
  }

  export type study_userUncheckedUpdateInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    account?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    reservation?: study_reservationUncheckedUpdateManyWithoutUserNestedInput
    message?: study_messageUncheckedUpdateManyWithoutUserNestedInput
  }

  export type study_userCreateManyInput = {
    uid?: string
    createAt?: Date | string
    updateAt?: Date | string
    name: string
    account: string
    password: string
    isAdmin?: boolean
  }

  export type study_userUpdateManyMutationInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    account?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
  }

  export type study_userUncheckedUpdateManyInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    account?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
  }

  export type study_storeCreateInput = {
    uid?: string
    createAt?: Date | string
    updateAt?: Date | string
    name: string
    local: string
    address: string
    status?: boolean
    remark?: string | null
    floors?: study_floorCreateNestedManyWithoutStoreInput
  }

  export type study_storeUncheckedCreateInput = {
    uid?: string
    createAt?: Date | string
    updateAt?: Date | string
    name: string
    local: string
    address: string
    status?: boolean
    remark?: string | null
    floors?: study_floorUncheckedCreateNestedManyWithoutStoreInput
  }

  export type study_storeUpdateInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    local?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    remark?: NullableStringFieldUpdateOperationsInput | string | null
    floors?: study_floorUpdateManyWithoutStoreNestedInput
  }

  export type study_storeUncheckedUpdateInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    local?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    remark?: NullableStringFieldUpdateOperationsInput | string | null
    floors?: study_floorUncheckedUpdateManyWithoutStoreNestedInput
  }

  export type study_storeCreateManyInput = {
    uid?: string
    createAt?: Date | string
    updateAt?: Date | string
    name: string
    local: string
    address: string
    status?: boolean
    remark?: string | null
  }

  export type study_storeUpdateManyMutationInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    local?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    remark?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type study_storeUncheckedUpdateManyInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    local?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    remark?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type study_floorCreateInput = {
    uid?: string
    createAt?: Date | string
    updateAt?: Date | string
    floorNumber: number
    store: study_storeCreateNestedOneWithoutFloorsInput
    studyRooms?: study_roomCreateNestedManyWithoutFloorInput
  }

  export type study_floorUncheckedCreateInput = {
    uid?: string
    createAt?: Date | string
    updateAt?: Date | string
    floorNumber: number
    storeId: string
    studyRooms?: study_roomUncheckedCreateNestedManyWithoutFloorInput
  }

  export type study_floorUpdateInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    floorNumber?: IntFieldUpdateOperationsInput | number
    store?: study_storeUpdateOneRequiredWithoutFloorsNestedInput
    studyRooms?: study_roomUpdateManyWithoutFloorNestedInput
  }

  export type study_floorUncheckedUpdateInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    floorNumber?: IntFieldUpdateOperationsInput | number
    storeId?: StringFieldUpdateOperationsInput | string
    studyRooms?: study_roomUncheckedUpdateManyWithoutFloorNestedInput
  }

  export type study_floorCreateManyInput = {
    uid?: string
    createAt?: Date | string
    updateAt?: Date | string
    floorNumber: number
    storeId: string
  }

  export type study_floorUpdateManyMutationInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    floorNumber?: IntFieldUpdateOperationsInput | number
  }

  export type study_floorUncheckedUpdateManyInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    floorNumber?: IntFieldUpdateOperationsInput | number
    storeId?: StringFieldUpdateOperationsInput | string
  }

  export type study_roomCreateInput = {
    uid?: string
    createAt?: Date | string
    updateAt?: Date | string
    name: string
    capacity: number
    status?: boolean
    floor: study_floorCreateNestedOneWithoutStudyRoomsInput
    seats?: study_seatCreateNestedManyWithoutRoomInput
  }

  export type study_roomUncheckedCreateInput = {
    uid?: string
    createAt?: Date | string
    updateAt?: Date | string
    name: string
    floorId: string
    capacity: number
    status?: boolean
    seats?: study_seatUncheckedCreateNestedManyWithoutRoomInput
  }

  export type study_roomUpdateInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    floor?: study_floorUpdateOneRequiredWithoutStudyRoomsNestedInput
    seats?: study_seatUpdateManyWithoutRoomNestedInput
  }

  export type study_roomUncheckedUpdateInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    floorId?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    seats?: study_seatUncheckedUpdateManyWithoutRoomNestedInput
  }

  export type study_roomCreateManyInput = {
    uid?: string
    createAt?: Date | string
    updateAt?: Date | string
    name: string
    floorId: string
    capacity: number
    status?: boolean
  }

  export type study_roomUpdateManyMutationInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
  }

  export type study_roomUncheckedUpdateManyInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    floorId?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
  }

  export type study_seatCreateInput = {
    uid?: string
    createAt?: Date | string
    updateAt?: Date | string
    seatNumber: string
    status?: boolean
    room: study_roomCreateNestedOneWithoutSeatsInput
    reservations?: study_reservationCreateNestedManyWithoutSeatInput
  }

  export type study_seatUncheckedCreateInput = {
    uid?: string
    createAt?: Date | string
    updateAt?: Date | string
    seatNumber: string
    roomId: string
    status?: boolean
    reservations?: study_reservationUncheckedCreateNestedManyWithoutSeatInput
  }

  export type study_seatUpdateInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seatNumber?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    room?: study_roomUpdateOneRequiredWithoutSeatsNestedInput
    reservations?: study_reservationUpdateManyWithoutSeatNestedInput
  }

  export type study_seatUncheckedUpdateInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seatNumber?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    reservations?: study_reservationUncheckedUpdateManyWithoutSeatNestedInput
  }

  export type study_seatCreateManyInput = {
    uid?: string
    createAt?: Date | string
    updateAt?: Date | string
    seatNumber: string
    roomId: string
    status?: boolean
  }

  export type study_seatUpdateManyMutationInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seatNumber?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
  }

  export type study_seatUncheckedUpdateManyInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seatNumber?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
  }

  export type study_reservationCreateInput = {
    uid?: string
    createAt?: Date | string
    updateAt?: Date | string
    startTime: Date | string
    endTime: Date | string
    status?: string
    user: study_userCreateNestedOneWithoutReservationInput
    seat: study_seatCreateNestedOneWithoutReservationsInput
  }

  export type study_reservationUncheckedCreateInput = {
    uid?: string
    createAt?: Date | string
    updateAt?: Date | string
    userId: string
    seatId: string
    startTime: Date | string
    endTime: Date | string
    status?: string
  }

  export type study_reservationUpdateInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    user?: study_userUpdateOneRequiredWithoutReservationNestedInput
    seat?: study_seatUpdateOneRequiredWithoutReservationsNestedInput
  }

  export type study_reservationUncheckedUpdateInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    seatId?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type study_reservationCreateManyInput = {
    uid?: string
    createAt?: Date | string
    updateAt?: Date | string
    userId: string
    seatId: string
    startTime: Date | string
    endTime: Date | string
    status?: string
  }

  export type study_reservationUpdateManyMutationInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type study_reservationUncheckedUpdateManyInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    seatId?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type study_messageCreateInput = {
    uid?: string
    createAt?: Date | string
    updateAt?: Date | string
    content: string
    reply?: string | null
    status?: boolean
    user: study_userCreateNestedOneWithoutMessageInput
  }

  export type study_messageUncheckedCreateInput = {
    uid?: string
    createAt?: Date | string
    updateAt?: Date | string
    userId: string
    content: string
    reply?: string | null
    status?: boolean
  }

  export type study_messageUpdateInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    reply?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    user?: study_userUpdateOneRequiredWithoutMessageNestedInput
  }

  export type study_messageUncheckedUpdateInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    reply?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
  }

  export type study_messageCreateManyInput = {
    uid?: string
    createAt?: Date | string
    updateAt?: Date | string
    userId: string
    content: string
    reply?: string | null
    status?: boolean
  }

  export type study_messageUpdateManyMutationInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    reply?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
  }

  export type study_messageUncheckedUpdateManyInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    reply?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
  }

  export type study_announcementCreateInput = {
    uid?: string
    createAt?: Date | string
    updateAt?: Date | string
    title: string
    content: string
    status?: boolean
  }

  export type study_announcementUncheckedCreateInput = {
    uid?: string
    createAt?: Date | string
    updateAt?: Date | string
    title: string
    content: string
    status?: boolean
  }

  export type study_announcementUpdateInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
  }

  export type study_announcementUncheckedUpdateInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
  }

  export type study_announcementCreateManyInput = {
    uid?: string
    createAt?: Date | string
    updateAt?: Date | string
    title: string
    content: string
    status?: boolean
  }

  export type study_announcementUpdateManyMutationInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
  }

  export type study_announcementUncheckedUpdateManyInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type Sys_accountListRelationFilter = {
    every?: sys_accountWhereInput
    some?: sys_accountWhereInput
    none?: sys_accountWhereInput
  }

  export type Sys_roleNullableScalarRelationFilter = {
    is?: sys_roleWhereInput | null
    isNot?: sys_roleWhereInput | null
  }

  export type Sys_user_ban_menuListRelationFilter = {
    every?: sys_user_ban_menuWhereInput
    some?: sys_user_ban_menuWhereInput
    none?: sys_user_ban_menuWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type sys_accountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type sys_user_ban_menuOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type sys_userOrderByRelevanceInput = {
    fields: sys_userOrderByRelevanceFieldEnum | sys_userOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type sys_userCountOrderByAggregateInput = {
    uid?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    name?: SortOrder
    password?: SortOrder
    salt?: SortOrder
    roleId?: SortOrder
  }

  export type sys_userMaxOrderByAggregateInput = {
    uid?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    name?: SortOrder
    password?: SortOrder
    salt?: SortOrder
    roleId?: SortOrder
  }

  export type sys_userMinOrderByAggregateInput = {
    uid?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    name?: SortOrder
    password?: SortOrder
    salt?: SortOrder
    roleId?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type Enumsys_account_providerFilter<$PrismaModel = never> = {
    equals?: $Enums.sys_account_provider | Enumsys_account_providerFieldRefInput<$PrismaModel>
    in?: $Enums.sys_account_provider[]
    notIn?: $Enums.sys_account_provider[]
    not?: NestedEnumsys_account_providerFilter<$PrismaModel> | $Enums.sys_account_provider
  }

  export type Sys_userNullableScalarRelationFilter = {
    is?: sys_userWhereInput | null
    isNot?: sys_userWhereInput | null
  }

  export type sys_accountOrderByRelevanceInput = {
    fields: sys_accountOrderByRelevanceFieldEnum | sys_accountOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type sys_accountProviderProvider_idCompoundUniqueInput = {
    provider: $Enums.sys_account_provider
    provider_id: string
  }

  export type sys_accountCountOrderByAggregateInput = {
    createAt?: SortOrder
    updateAt?: SortOrder
    provider?: SortOrder
    provider_id?: SortOrder
    userId?: SortOrder
  }

  export type sys_accountMaxOrderByAggregateInput = {
    createAt?: SortOrder
    updateAt?: SortOrder
    provider?: SortOrder
    provider_id?: SortOrder
    userId?: SortOrder
  }

  export type sys_accountMinOrderByAggregateInput = {
    createAt?: SortOrder
    updateAt?: SortOrder
    provider?: SortOrder
    provider_id?: SortOrder
    userId?: SortOrder
  }

  export type Enumsys_account_providerWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.sys_account_provider | Enumsys_account_providerFieldRefInput<$PrismaModel>
    in?: $Enums.sys_account_provider[]
    notIn?: $Enums.sys_account_provider[]
    not?: NestedEnumsys_account_providerWithAggregatesFilter<$PrismaModel> | $Enums.sys_account_provider
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumsys_account_providerFilter<$PrismaModel>
    _max?: NestedEnumsys_account_providerFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type Sys_menuNullableScalarRelationFilter = {
    is?: sys_menuWhereInput | null
    isNot?: sys_menuWhereInput | null
  }

  export type Sys_menuListRelationFilter = {
    every?: sys_menuWhereInput
    some?: sys_menuWhereInput
    none?: sys_menuWhereInput
  }

  export type Sys_menu_on_roleListRelationFilter = {
    every?: sys_menu_on_roleWhereInput
    some?: sys_menu_on_roleWhereInput
    none?: sys_menu_on_roleWhereInput
  }

  export type sys_menuOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type sys_menu_on_roleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type sys_menuOrderByRelevanceInput = {
    fields: sys_menuOrderByRelevanceFieldEnum | sys_menuOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type sys_menuCountOrderByAggregateInput = {
    uid?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    name?: SortOrder
    path?: SortOrder
    powers?: SortOrder
    comment?: SortOrder
    parentId?: SortOrder
  }

  export type sys_menuAvgOrderByAggregateInput = {
    powers?: SortOrder
  }

  export type sys_menuMaxOrderByAggregateInput = {
    uid?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    name?: SortOrder
    path?: SortOrder
    powers?: SortOrder
    comment?: SortOrder
    parentId?: SortOrder
  }

  export type sys_menuMinOrderByAggregateInput = {
    uid?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    name?: SortOrder
    path?: SortOrder
    powers?: SortOrder
    comment?: SortOrder
    parentId?: SortOrder
  }

  export type sys_menuSumOrderByAggregateInput = {
    powers?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type Sys_userScalarRelationFilter = {
    is?: sys_userWhereInput
    isNot?: sys_userWhereInput
  }

  export type Sys_menuScalarRelationFilter = {
    is?: sys_menuWhereInput
    isNot?: sys_menuWhereInput
  }

  export type sys_user_ban_menuOrderByRelevanceInput = {
    fields: sys_user_ban_menuOrderByRelevanceFieldEnum | sys_user_ban_menuOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type sys_user_ban_menuUserIdMenuIdCompoundUniqueInput = {
    userId: string
    menuId: string
  }

  export type sys_user_ban_menuCountOrderByAggregateInput = {
    userId?: SortOrder
    menuId?: SortOrder
  }

  export type sys_user_ban_menuMaxOrderByAggregateInput = {
    userId?: SortOrder
    menuId?: SortOrder
  }

  export type sys_user_ban_menuMinOrderByAggregateInput = {
    userId?: SortOrder
    menuId?: SortOrder
  }

  export type BigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[]
    notIn?: bigint[] | number[]
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type Sys_roleScalarRelationFilter = {
    is?: sys_roleWhereInput
    isNot?: sys_roleWhereInput
  }

  export type sys_menu_on_roleOrderByRelevanceInput = {
    fields: sys_menu_on_roleOrderByRelevanceFieldEnum | sys_menu_on_roleOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type sys_menu_on_roleRoleIdMenuIdCompoundUniqueInput = {
    roleId: string
    menuId: string
  }

  export type sys_menu_on_roleCountOrderByAggregateInput = {
    roleId?: SortOrder
    menuId?: SortOrder
    power?: SortOrder
  }

  export type sys_menu_on_roleAvgOrderByAggregateInput = {
    power?: SortOrder
  }

  export type sys_menu_on_roleMaxOrderByAggregateInput = {
    roleId?: SortOrder
    menuId?: SortOrder
    power?: SortOrder
  }

  export type sys_menu_on_roleMinOrderByAggregateInput = {
    roleId?: SortOrder
    menuId?: SortOrder
    power?: SortOrder
  }

  export type sys_menu_on_roleSumOrderByAggregateInput = {
    power?: SortOrder
  }

  export type BigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[]
    notIn?: bigint[] | number[]
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type Sys_userListRelationFilter = {
    every?: sys_userWhereInput
    some?: sys_userWhereInput
    none?: sys_userWhereInput
  }

  export type sys_userOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type sys_roleOrderByRelevanceInput = {
    fields: sys_roleOrderByRelevanceFieldEnum | sys_roleOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type sys_roleCountOrderByAggregateInput = {
    uid?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    name?: SortOrder
    status?: SortOrder
    comment?: SortOrder
  }

  export type sys_roleMaxOrderByAggregateInput = {
    uid?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    name?: SortOrder
    status?: SortOrder
    comment?: SortOrder
  }

  export type sys_roleMinOrderByAggregateInput = {
    uid?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    name?: SortOrder
    status?: SortOrder
    comment?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type Blog_postsListRelationFilter = {
    every?: blog_postsWhereInput
    some?: blog_postsWhereInput
    none?: blog_postsWhereInput
  }

  export type blog_postsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type blog_userOrderByRelevanceInput = {
    fields: blog_userOrderByRelevanceFieldEnum | blog_userOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type blog_userCountOrderByAggregateInput = {
    uid?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    name?: SortOrder
  }

  export type blog_userMaxOrderByAggregateInput = {
    uid?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    name?: SortOrder
  }

  export type blog_userMinOrderByAggregateInput = {
    uid?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    name?: SortOrder
  }

  export type blog_categoriesOrderByRelevanceInput = {
    fields: blog_categoriesOrderByRelevanceFieldEnum | blog_categoriesOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type blog_categoriesCountOrderByAggregateInput = {
    uid?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    name?: SortOrder
  }

  export type blog_categoriesMaxOrderByAggregateInput = {
    uid?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    name?: SortOrder
  }

  export type blog_categoriesMinOrderByAggregateInput = {
    uid?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    name?: SortOrder
  }

  export type Blog_categoriesNullableScalarRelationFilter = {
    is?: blog_categoriesWhereInput | null
    isNot?: blog_categoriesWhereInput | null
  }

  export type Blog_userScalarRelationFilter = {
    is?: blog_userWhereInput
    isNot?: blog_userWhereInput
  }

  export type Blog_posts_on_tagsListRelationFilter = {
    every?: blog_posts_on_tagsWhereInput
    some?: blog_posts_on_tagsWhereInput
    none?: blog_posts_on_tagsWhereInput
  }

  export type blog_posts_on_tagsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type blog_postsOrderByRelevanceInput = {
    fields: blog_postsOrderByRelevanceFieldEnum | blog_postsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type blog_postsCountOrderByAggregateInput = {
    uid?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    title?: SortOrder
    content?: SortOrder
    userId?: SortOrder
    categoriesId?: SortOrder
  }

  export type blog_postsMaxOrderByAggregateInput = {
    uid?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    title?: SortOrder
    content?: SortOrder
    userId?: SortOrder
    categoriesId?: SortOrder
  }

  export type blog_postsMinOrderByAggregateInput = {
    uid?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    title?: SortOrder
    content?: SortOrder
    userId?: SortOrder
    categoriesId?: SortOrder
  }

  export type blog_noticeOrderByRelevanceInput = {
    fields: blog_noticeOrderByRelevanceFieldEnum | blog_noticeOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type blog_noticeCountOrderByAggregateInput = {
    uid?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
  }

  export type blog_noticeMaxOrderByAggregateInput = {
    uid?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
  }

  export type blog_noticeMinOrderByAggregateInput = {
    uid?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
  }

  export type Blog_postsScalarRelationFilter = {
    is?: blog_postsWhereInput
    isNot?: blog_postsWhereInput
  }

  export type Blog_tagScalarRelationFilter = {
    is?: blog_tagWhereInput
    isNot?: blog_tagWhereInput
  }

  export type blog_posts_on_tagsOrderByRelevanceInput = {
    fields: blog_posts_on_tagsOrderByRelevanceFieldEnum | blog_posts_on_tagsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type blog_posts_on_tagsPostsIdTagIdCompoundUniqueInput = {
    postsId: string
    tagId: string
  }

  export type blog_posts_on_tagsCountOrderByAggregateInput = {
    postsId?: SortOrder
    tagId?: SortOrder
  }

  export type blog_posts_on_tagsMaxOrderByAggregateInput = {
    postsId?: SortOrder
    tagId?: SortOrder
  }

  export type blog_posts_on_tagsMinOrderByAggregateInput = {
    postsId?: SortOrder
    tagId?: SortOrder
  }

  export type blog_tagOrderByRelevanceInput = {
    fields: blog_tagOrderByRelevanceFieldEnum | blog_tagOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type blog_tagCountOrderByAggregateInput = {
    uid?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    name?: SortOrder
  }

  export type blog_tagMaxOrderByAggregateInput = {
    uid?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    name?: SortOrder
  }

  export type blog_tagMinOrderByAggregateInput = {
    uid?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    name?: SortOrder
  }

  export type File_user_on_mediaListRelationFilter = {
    every?: file_user_on_mediaWhereInput
    some?: file_user_on_mediaWhereInput
    none?: file_user_on_mediaWhereInput
  }

  export type File_folderListRelationFilter = {
    every?: file_folderWhereInput
    some?: file_folderWhereInput
    none?: file_folderWhereInput
  }

  export type File_configNullableScalarRelationFilter = {
    is?: file_configWhereInput | null
    isNot?: file_configWhereInput | null
  }

  export type File_keysListRelationFilter = {
    every?: file_keysWhereInput
    some?: file_keysWhereInput
    none?: file_keysWhereInput
  }

  export type file_user_on_mediaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type file_folderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type file_keysOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type file_userOrderByRelevanceInput = {
    fields: file_userOrderByRelevanceFieldEnum | file_userOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type file_userCountOrderByAggregateInput = {
    uid?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    name?: SortOrder
    is_admin?: SortOrder
  }

  export type file_userMaxOrderByAggregateInput = {
    uid?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    name?: SortOrder
    is_admin?: SortOrder
  }

  export type file_userMinOrderByAggregateInput = {
    uid?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    name?: SortOrder
    is_admin?: SortOrder
  }

  export type File_userScalarRelationFilter = {
    is?: file_userWhereInput
    isNot?: file_userWhereInput
  }

  export type file_keysOrderByRelevanceInput = {
    fields: file_keysOrderByRelevanceFieldEnum | file_keysOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type file_keysCountOrderByAggregateInput = {
    api_key?: SortOrder
    api_secret?: SortOrder
    userId?: SortOrder
  }

  export type file_keysMaxOrderByAggregateInput = {
    api_key?: SortOrder
    api_secret?: SortOrder
    userId?: SortOrder
  }

  export type file_keysMinOrderByAggregateInput = {
    api_key?: SortOrder
    api_secret?: SortOrder
    userId?: SortOrder
  }

  export type file_configOrderByRelevanceInput = {
    fields: file_configOrderByRelevanceFieldEnum | file_configOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type file_configCountOrderByAggregateInput = {
    uid?: SortOrder
    userId?: SortOrder
  }

  export type file_configMaxOrderByAggregateInput = {
    uid?: SortOrder
    userId?: SortOrder
  }

  export type file_configMinOrderByAggregateInput = {
    uid?: SortOrder
    userId?: SortOrder
  }

  export type File_mediaScalarRelationFilter = {
    is?: file_mediaWhereInput
    isNot?: file_mediaWhereInput
  }

  export type file_user_on_mediaOrderByRelevanceInput = {
    fields: file_user_on_mediaOrderByRelevanceFieldEnum | file_user_on_mediaOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type file_user_on_mediaUserIdMediaIdCompoundUniqueInput = {
    userId: string
    mediaId: string
  }

  export type file_user_on_mediaCountOrderByAggregateInput = {
    userId?: SortOrder
    mediaId?: SortOrder
    comment?: SortOrder
  }

  export type file_user_on_mediaMaxOrderByAggregateInput = {
    userId?: SortOrder
    mediaId?: SortOrder
    comment?: SortOrder
  }

  export type file_user_on_mediaMinOrderByAggregateInput = {
    userId?: SortOrder
    mediaId?: SortOrder
    comment?: SortOrder
  }

  export type file_blockOrderByRelevanceInput = {
    fields: file_blockOrderByRelevanceFieldEnum | file_blockOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type file_blockCountOrderByAggregateInput = {
    uid?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    mediaId?: SortOrder
    hash_key?: SortOrder
    size?: SortOrder
  }

  export type file_blockAvgOrderByAggregateInput = {
    size?: SortOrder
  }

  export type file_blockMaxOrderByAggregateInput = {
    uid?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    mediaId?: SortOrder
    hash_key?: SortOrder
    size?: SortOrder
  }

  export type file_blockMinOrderByAggregateInput = {
    uid?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    mediaId?: SortOrder
    hash_key?: SortOrder
    size?: SortOrder
  }

  export type file_blockSumOrderByAggregateInput = {
    size?: SortOrder
  }

  export type Enumfile_typeFilter<$PrismaModel = never> = {
    equals?: $Enums.file_type | Enumfile_typeFieldRefInput<$PrismaModel>
    in?: $Enums.file_type[]
    notIn?: $Enums.file_type[]
    not?: NestedEnumfile_typeFilter<$PrismaModel> | $Enums.file_type
  }

  export type File_blockListRelationFilter = {
    every?: file_blockWhereInput
    some?: file_blockWhereInput
    none?: file_blockWhereInput
  }

  export type File_media_on_folderListRelationFilter = {
    every?: file_media_on_folderWhereInput
    some?: file_media_on_folderWhereInput
    none?: file_media_on_folderWhereInput
  }

  export type file_blockOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type file_media_on_folderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type file_mediaOrderByRelevanceInput = {
    fields: file_mediaOrderByRelevanceFieldEnum | file_mediaOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type file_mediaCountOrderByAggregateInput = {
    uid?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    type?: SortOrder
    name?: SortOrder
    hash_key?: SortOrder
    size?: SortOrder
    disable?: SortOrder
    comment?: SortOrder
  }

  export type file_mediaAvgOrderByAggregateInput = {
    size?: SortOrder
  }

  export type file_mediaMaxOrderByAggregateInput = {
    uid?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    type?: SortOrder
    name?: SortOrder
    hash_key?: SortOrder
    size?: SortOrder
    disable?: SortOrder
    comment?: SortOrder
  }

  export type file_mediaMinOrderByAggregateInput = {
    uid?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    type?: SortOrder
    name?: SortOrder
    hash_key?: SortOrder
    size?: SortOrder
    disable?: SortOrder
    comment?: SortOrder
  }

  export type file_mediaSumOrderByAggregateInput = {
    size?: SortOrder
  }

  export type Enumfile_typeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.file_type | Enumfile_typeFieldRefInput<$PrismaModel>
    in?: $Enums.file_type[]
    notIn?: $Enums.file_type[]
    not?: NestedEnumfile_typeWithAggregatesFilter<$PrismaModel> | $Enums.file_type
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumfile_typeFilter<$PrismaModel>
    _max?: NestedEnumfile_typeFilter<$PrismaModel>
  }

  export type File_folderScalarRelationFilter = {
    is?: file_folderWhereInput
    isNot?: file_folderWhereInput
  }

  export type file_media_on_folderOrderByRelevanceInput = {
    fields: file_media_on_folderOrderByRelevanceFieldEnum | file_media_on_folderOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type file_media_on_folderMediaIdFolderIdCompoundUniqueInput = {
    mediaId: string
    folderId: string
  }

  export type file_media_on_folderCountOrderByAggregateInput = {
    mediaId?: SortOrder
    folderId?: SortOrder
  }

  export type file_media_on_folderMaxOrderByAggregateInput = {
    mediaId?: SortOrder
    folderId?: SortOrder
  }

  export type file_media_on_folderMinOrderByAggregateInput = {
    mediaId?: SortOrder
    folderId?: SortOrder
  }

  export type File_folderNullableScalarRelationFilter = {
    is?: file_folderWhereInput | null
    isNot?: file_folderWhereInput | null
  }

  export type file_folderOrderByRelevanceInput = {
    fields: file_folderOrderByRelevanceFieldEnum | file_folderOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type file_folderCountOrderByAggregateInput = {
    uid?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    name?: SortOrder
    userId?: SortOrder
    parentId?: SortOrder
  }

  export type file_folderMaxOrderByAggregateInput = {
    uid?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    name?: SortOrder
    userId?: SortOrder
    parentId?: SortOrder
  }

  export type file_folderMinOrderByAggregateInput = {
    uid?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    name?: SortOrder
    userId?: SortOrder
    parentId?: SortOrder
  }

  export type Enumbook_roleFilter<$PrismaModel = never> = {
    equals?: $Enums.book_role | Enumbook_roleFieldRefInput<$PrismaModel>
    in?: $Enums.book_role[]
    notIn?: $Enums.book_role[]
    not?: NestedEnumbook_roleFilter<$PrismaModel> | $Enums.book_role
  }

  export type Book_borrowedListRelationFilter = {
    every?: book_borrowedWhereInput
    some?: book_borrowedWhereInput
    none?: book_borrowedWhereInput
  }

  export type Book_borrow_historyListRelationFilter = {
    every?: book_borrow_historyWhereInput
    some?: book_borrow_historyWhereInput
    none?: book_borrow_historyWhereInput
  }

  export type Book_ratingListRelationFilter = {
    every?: book_ratingWhereInput
    some?: book_ratingWhereInput
    none?: book_ratingWhereInput
  }

  export type book_borrowedOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type book_borrow_historyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type book_ratingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type book_userOrderByRelevanceInput = {
    fields: book_userOrderByRelevanceFieldEnum | book_userOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type book_userCountOrderByAggregateInput = {
    id?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    book_roleId?: SortOrder
  }

  export type book_userMaxOrderByAggregateInput = {
    id?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    book_roleId?: SortOrder
  }

  export type book_userMinOrderByAggregateInput = {
    id?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    book_roleId?: SortOrder
  }

  export type Enumbook_roleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.book_role | Enumbook_roleFieldRefInput<$PrismaModel>
    in?: $Enums.book_role[]
    notIn?: $Enums.book_role[]
    not?: NestedEnumbook_roleWithAggregatesFilter<$PrismaModel> | $Enums.book_role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumbook_roleFilter<$PrismaModel>
    _max?: NestedEnumbook_roleFilter<$PrismaModel>
  }

  export type Book_categoryScalarRelationFilter = {
    is?: book_categoryWhereInput
    isNot?: book_categoryWhereInput
  }

  export type book_bookOrderByRelevanceInput = {
    fields: book_bookOrderByRelevanceFieldEnum | book_bookOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type book_bookCountOrderByAggregateInput = {
    id?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    title?: SortOrder
    author?: SortOrder
    isbn?: SortOrder
    description?: SortOrder
    publication?: SortOrder
    categoryId?: SortOrder
    available?: SortOrder
  }

  export type book_bookMaxOrderByAggregateInput = {
    id?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    title?: SortOrder
    author?: SortOrder
    isbn?: SortOrder
    description?: SortOrder
    publication?: SortOrder
    categoryId?: SortOrder
    available?: SortOrder
  }

  export type book_bookMinOrderByAggregateInput = {
    id?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    title?: SortOrder
    author?: SortOrder
    isbn?: SortOrder
    description?: SortOrder
    publication?: SortOrder
    categoryId?: SortOrder
    available?: SortOrder
  }

  export type Book_bookListRelationFilter = {
    every?: book_bookWhereInput
    some?: book_bookWhereInput
    none?: book_bookWhereInput
  }

  export type book_bookOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type book_categoryOrderByRelevanceInput = {
    fields: book_categoryOrderByRelevanceFieldEnum | book_categoryOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type book_categoryCountOrderByAggregateInput = {
    id?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    categoryName?: SortOrder
  }

  export type book_categoryMaxOrderByAggregateInput = {
    id?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    categoryName?: SortOrder
  }

  export type book_categoryMinOrderByAggregateInput = {
    id?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    categoryName?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type Book_userScalarRelationFilter = {
    is?: book_userWhereInput
    isNot?: book_userWhereInput
  }

  export type Book_bookScalarRelationFilter = {
    is?: book_bookWhereInput
    isNot?: book_bookWhereInput
  }

  export type book_borrowedOrderByRelevanceInput = {
    fields: book_borrowedOrderByRelevanceFieldEnum | book_borrowedOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type book_borrowedCountOrderByAggregateInput = {
    id?: SortOrder
    borrowDate?: SortOrder
    returnDate?: SortOrder
    dueDate?: SortOrder
    userId?: SortOrder
    bookId?: SortOrder
    returned?: SortOrder
  }

  export type book_borrowedMaxOrderByAggregateInput = {
    id?: SortOrder
    borrowDate?: SortOrder
    returnDate?: SortOrder
    dueDate?: SortOrder
    userId?: SortOrder
    bookId?: SortOrder
    returned?: SortOrder
  }

  export type book_borrowedMinOrderByAggregateInput = {
    id?: SortOrder
    borrowDate?: SortOrder
    returnDate?: SortOrder
    dueDate?: SortOrder
    userId?: SortOrder
    bookId?: SortOrder
    returned?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type book_borrow_historyOrderByRelevanceInput = {
    fields: book_borrow_historyOrderByRelevanceFieldEnum | book_borrow_historyOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type book_borrow_historyCountOrderByAggregateInput = {
    id?: SortOrder
    borrowDate?: SortOrder
    returnDate?: SortOrder
    userId?: SortOrder
    bookId?: SortOrder
    returned?: SortOrder
  }

  export type book_borrow_historyMaxOrderByAggregateInput = {
    id?: SortOrder
    borrowDate?: SortOrder
    returnDate?: SortOrder
    userId?: SortOrder
    bookId?: SortOrder
    returned?: SortOrder
  }

  export type book_borrow_historyMinOrderByAggregateInput = {
    id?: SortOrder
    borrowDate?: SortOrder
    returnDate?: SortOrder
    userId?: SortOrder
    bookId?: SortOrder
    returned?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type book_ratingOrderByRelevanceInput = {
    fields: book_ratingOrderByRelevanceFieldEnum | book_ratingOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type book_ratingCountOrderByAggregateInput = {
    id?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    rating?: SortOrder
    review?: SortOrder
    userId?: SortOrder
    bookId?: SortOrder
  }

  export type book_ratingAvgOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type book_ratingMaxOrderByAggregateInput = {
    id?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    rating?: SortOrder
    review?: SortOrder
    userId?: SortOrder
    bookId?: SortOrder
  }

  export type book_ratingMinOrderByAggregateInput = {
    id?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    rating?: SortOrder
    review?: SortOrder
    userId?: SortOrder
    bookId?: SortOrder
  }

  export type book_ratingSumOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type Study_reservationListRelationFilter = {
    every?: study_reservationWhereInput
    some?: study_reservationWhereInput
    none?: study_reservationWhereInput
  }

  export type Study_messageListRelationFilter = {
    every?: study_messageWhereInput
    some?: study_messageWhereInput
    none?: study_messageWhereInput
  }

  export type study_reservationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type study_messageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type study_userOrderByRelevanceInput = {
    fields: study_userOrderByRelevanceFieldEnum | study_userOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type study_userCountOrderByAggregateInput = {
    uid?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    name?: SortOrder
    account?: SortOrder
    password?: SortOrder
    isAdmin?: SortOrder
  }

  export type study_userMaxOrderByAggregateInput = {
    uid?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    name?: SortOrder
    account?: SortOrder
    password?: SortOrder
    isAdmin?: SortOrder
  }

  export type study_userMinOrderByAggregateInput = {
    uid?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    name?: SortOrder
    account?: SortOrder
    password?: SortOrder
    isAdmin?: SortOrder
  }

  export type Study_floorListRelationFilter = {
    every?: study_floorWhereInput
    some?: study_floorWhereInput
    none?: study_floorWhereInput
  }

  export type study_floorOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type study_storeOrderByRelevanceInput = {
    fields: study_storeOrderByRelevanceFieldEnum | study_storeOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type study_storeCountOrderByAggregateInput = {
    uid?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    name?: SortOrder
    local?: SortOrder
    address?: SortOrder
    status?: SortOrder
    remark?: SortOrder
  }

  export type study_storeMaxOrderByAggregateInput = {
    uid?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    name?: SortOrder
    local?: SortOrder
    address?: SortOrder
    status?: SortOrder
    remark?: SortOrder
  }

  export type study_storeMinOrderByAggregateInput = {
    uid?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    name?: SortOrder
    local?: SortOrder
    address?: SortOrder
    status?: SortOrder
    remark?: SortOrder
  }

  export type Study_storeScalarRelationFilter = {
    is?: study_storeWhereInput
    isNot?: study_storeWhereInput
  }

  export type Study_roomListRelationFilter = {
    every?: study_roomWhereInput
    some?: study_roomWhereInput
    none?: study_roomWhereInput
  }

  export type study_roomOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type study_floorOrderByRelevanceInput = {
    fields: study_floorOrderByRelevanceFieldEnum | study_floorOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type study_floorCountOrderByAggregateInput = {
    uid?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    floorNumber?: SortOrder
    storeId?: SortOrder
  }

  export type study_floorAvgOrderByAggregateInput = {
    floorNumber?: SortOrder
  }

  export type study_floorMaxOrderByAggregateInput = {
    uid?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    floorNumber?: SortOrder
    storeId?: SortOrder
  }

  export type study_floorMinOrderByAggregateInput = {
    uid?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    floorNumber?: SortOrder
    storeId?: SortOrder
  }

  export type study_floorSumOrderByAggregateInput = {
    floorNumber?: SortOrder
  }

  export type Study_floorScalarRelationFilter = {
    is?: study_floorWhereInput
    isNot?: study_floorWhereInput
  }

  export type Study_seatListRelationFilter = {
    every?: study_seatWhereInput
    some?: study_seatWhereInput
    none?: study_seatWhereInput
  }

  export type study_seatOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type study_roomOrderByRelevanceInput = {
    fields: study_roomOrderByRelevanceFieldEnum | study_roomOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type study_roomCountOrderByAggregateInput = {
    uid?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    name?: SortOrder
    floorId?: SortOrder
    capacity?: SortOrder
    status?: SortOrder
  }

  export type study_roomAvgOrderByAggregateInput = {
    capacity?: SortOrder
  }

  export type study_roomMaxOrderByAggregateInput = {
    uid?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    name?: SortOrder
    floorId?: SortOrder
    capacity?: SortOrder
    status?: SortOrder
  }

  export type study_roomMinOrderByAggregateInput = {
    uid?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    name?: SortOrder
    floorId?: SortOrder
    capacity?: SortOrder
    status?: SortOrder
  }

  export type study_roomSumOrderByAggregateInput = {
    capacity?: SortOrder
  }

  export type Study_roomScalarRelationFilter = {
    is?: study_roomWhereInput
    isNot?: study_roomWhereInput
  }

  export type study_seatOrderByRelevanceInput = {
    fields: study_seatOrderByRelevanceFieldEnum | study_seatOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type study_seatCountOrderByAggregateInput = {
    uid?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    seatNumber?: SortOrder
    roomId?: SortOrder
    status?: SortOrder
  }

  export type study_seatMaxOrderByAggregateInput = {
    uid?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    seatNumber?: SortOrder
    roomId?: SortOrder
    status?: SortOrder
  }

  export type study_seatMinOrderByAggregateInput = {
    uid?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    seatNumber?: SortOrder
    roomId?: SortOrder
    status?: SortOrder
  }

  export type Study_userScalarRelationFilter = {
    is?: study_userWhereInput
    isNot?: study_userWhereInput
  }

  export type Study_seatScalarRelationFilter = {
    is?: study_seatWhereInput
    isNot?: study_seatWhereInput
  }

  export type study_reservationOrderByRelevanceInput = {
    fields: study_reservationOrderByRelevanceFieldEnum | study_reservationOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type study_reservationCountOrderByAggregateInput = {
    uid?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    userId?: SortOrder
    seatId?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    status?: SortOrder
  }

  export type study_reservationMaxOrderByAggregateInput = {
    uid?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    userId?: SortOrder
    seatId?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    status?: SortOrder
  }

  export type study_reservationMinOrderByAggregateInput = {
    uid?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    userId?: SortOrder
    seatId?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    status?: SortOrder
  }

  export type study_messageOrderByRelevanceInput = {
    fields: study_messageOrderByRelevanceFieldEnum | study_messageOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type study_messageCountOrderByAggregateInput = {
    uid?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    reply?: SortOrder
    status?: SortOrder
  }

  export type study_messageMaxOrderByAggregateInput = {
    uid?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    reply?: SortOrder
    status?: SortOrder
  }

  export type study_messageMinOrderByAggregateInput = {
    uid?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    reply?: SortOrder
    status?: SortOrder
  }

  export type study_announcementOrderByRelevanceInput = {
    fields: study_announcementOrderByRelevanceFieldEnum | study_announcementOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type study_announcementCountOrderByAggregateInput = {
    uid?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    title?: SortOrder
    content?: SortOrder
    status?: SortOrder
  }

  export type study_announcementMaxOrderByAggregateInput = {
    uid?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    title?: SortOrder
    content?: SortOrder
    status?: SortOrder
  }

  export type study_announcementMinOrderByAggregateInput = {
    uid?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    title?: SortOrder
    content?: SortOrder
    status?: SortOrder
  }

  export type sys_accountCreateNestedManyWithoutUserInput = {
    create?: XOR<sys_accountCreateWithoutUserInput, sys_accountUncheckedCreateWithoutUserInput> | sys_accountCreateWithoutUserInput[] | sys_accountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: sys_accountCreateOrConnectWithoutUserInput | sys_accountCreateOrConnectWithoutUserInput[]
    createMany?: sys_accountCreateManyUserInputEnvelope
    connect?: sys_accountWhereUniqueInput | sys_accountWhereUniqueInput[]
  }

  export type sys_roleCreateNestedOneWithoutUsersInput = {
    create?: XOR<sys_roleCreateWithoutUsersInput, sys_roleUncheckedCreateWithoutUsersInput>
    connectOrCreate?: sys_roleCreateOrConnectWithoutUsersInput
    connect?: sys_roleWhereUniqueInput
  }

  export type sys_user_ban_menuCreateNestedManyWithoutUserInput = {
    create?: XOR<sys_user_ban_menuCreateWithoutUserInput, sys_user_ban_menuUncheckedCreateWithoutUserInput> | sys_user_ban_menuCreateWithoutUserInput[] | sys_user_ban_menuUncheckedCreateWithoutUserInput[]
    connectOrCreate?: sys_user_ban_menuCreateOrConnectWithoutUserInput | sys_user_ban_menuCreateOrConnectWithoutUserInput[]
    createMany?: sys_user_ban_menuCreateManyUserInputEnvelope
    connect?: sys_user_ban_menuWhereUniqueInput | sys_user_ban_menuWhereUniqueInput[]
  }

  export type sys_accountUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<sys_accountCreateWithoutUserInput, sys_accountUncheckedCreateWithoutUserInput> | sys_accountCreateWithoutUserInput[] | sys_accountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: sys_accountCreateOrConnectWithoutUserInput | sys_accountCreateOrConnectWithoutUserInput[]
    createMany?: sys_accountCreateManyUserInputEnvelope
    connect?: sys_accountWhereUniqueInput | sys_accountWhereUniqueInput[]
  }

  export type sys_user_ban_menuUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<sys_user_ban_menuCreateWithoutUserInput, sys_user_ban_menuUncheckedCreateWithoutUserInput> | sys_user_ban_menuCreateWithoutUserInput[] | sys_user_ban_menuUncheckedCreateWithoutUserInput[]
    connectOrCreate?: sys_user_ban_menuCreateOrConnectWithoutUserInput | sys_user_ban_menuCreateOrConnectWithoutUserInput[]
    createMany?: sys_user_ban_menuCreateManyUserInputEnvelope
    connect?: sys_user_ban_menuWhereUniqueInput | sys_user_ban_menuWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type sys_accountUpdateManyWithoutUserNestedInput = {
    create?: XOR<sys_accountCreateWithoutUserInput, sys_accountUncheckedCreateWithoutUserInput> | sys_accountCreateWithoutUserInput[] | sys_accountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: sys_accountCreateOrConnectWithoutUserInput | sys_accountCreateOrConnectWithoutUserInput[]
    upsert?: sys_accountUpsertWithWhereUniqueWithoutUserInput | sys_accountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: sys_accountCreateManyUserInputEnvelope
    set?: sys_accountWhereUniqueInput | sys_accountWhereUniqueInput[]
    disconnect?: sys_accountWhereUniqueInput | sys_accountWhereUniqueInput[]
    delete?: sys_accountWhereUniqueInput | sys_accountWhereUniqueInput[]
    connect?: sys_accountWhereUniqueInput | sys_accountWhereUniqueInput[]
    update?: sys_accountUpdateWithWhereUniqueWithoutUserInput | sys_accountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: sys_accountUpdateManyWithWhereWithoutUserInput | sys_accountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: sys_accountScalarWhereInput | sys_accountScalarWhereInput[]
  }

  export type sys_roleUpdateOneWithoutUsersNestedInput = {
    create?: XOR<sys_roleCreateWithoutUsersInput, sys_roleUncheckedCreateWithoutUsersInput>
    connectOrCreate?: sys_roleCreateOrConnectWithoutUsersInput
    upsert?: sys_roleUpsertWithoutUsersInput
    disconnect?: sys_roleWhereInput | boolean
    delete?: sys_roleWhereInput | boolean
    connect?: sys_roleWhereUniqueInput
    update?: XOR<XOR<sys_roleUpdateToOneWithWhereWithoutUsersInput, sys_roleUpdateWithoutUsersInput>, sys_roleUncheckedUpdateWithoutUsersInput>
  }

  export type sys_user_ban_menuUpdateManyWithoutUserNestedInput = {
    create?: XOR<sys_user_ban_menuCreateWithoutUserInput, sys_user_ban_menuUncheckedCreateWithoutUserInput> | sys_user_ban_menuCreateWithoutUserInput[] | sys_user_ban_menuUncheckedCreateWithoutUserInput[]
    connectOrCreate?: sys_user_ban_menuCreateOrConnectWithoutUserInput | sys_user_ban_menuCreateOrConnectWithoutUserInput[]
    upsert?: sys_user_ban_menuUpsertWithWhereUniqueWithoutUserInput | sys_user_ban_menuUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: sys_user_ban_menuCreateManyUserInputEnvelope
    set?: sys_user_ban_menuWhereUniqueInput | sys_user_ban_menuWhereUniqueInput[]
    disconnect?: sys_user_ban_menuWhereUniqueInput | sys_user_ban_menuWhereUniqueInput[]
    delete?: sys_user_ban_menuWhereUniqueInput | sys_user_ban_menuWhereUniqueInput[]
    connect?: sys_user_ban_menuWhereUniqueInput | sys_user_ban_menuWhereUniqueInput[]
    update?: sys_user_ban_menuUpdateWithWhereUniqueWithoutUserInput | sys_user_ban_menuUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: sys_user_ban_menuUpdateManyWithWhereWithoutUserInput | sys_user_ban_menuUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: sys_user_ban_menuScalarWhereInput | sys_user_ban_menuScalarWhereInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type sys_accountUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<sys_accountCreateWithoutUserInput, sys_accountUncheckedCreateWithoutUserInput> | sys_accountCreateWithoutUserInput[] | sys_accountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: sys_accountCreateOrConnectWithoutUserInput | sys_accountCreateOrConnectWithoutUserInput[]
    upsert?: sys_accountUpsertWithWhereUniqueWithoutUserInput | sys_accountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: sys_accountCreateManyUserInputEnvelope
    set?: sys_accountWhereUniqueInput | sys_accountWhereUniqueInput[]
    disconnect?: sys_accountWhereUniqueInput | sys_accountWhereUniqueInput[]
    delete?: sys_accountWhereUniqueInput | sys_accountWhereUniqueInput[]
    connect?: sys_accountWhereUniqueInput | sys_accountWhereUniqueInput[]
    update?: sys_accountUpdateWithWhereUniqueWithoutUserInput | sys_accountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: sys_accountUpdateManyWithWhereWithoutUserInput | sys_accountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: sys_accountScalarWhereInput | sys_accountScalarWhereInput[]
  }

  export type sys_user_ban_menuUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<sys_user_ban_menuCreateWithoutUserInput, sys_user_ban_menuUncheckedCreateWithoutUserInput> | sys_user_ban_menuCreateWithoutUserInput[] | sys_user_ban_menuUncheckedCreateWithoutUserInput[]
    connectOrCreate?: sys_user_ban_menuCreateOrConnectWithoutUserInput | sys_user_ban_menuCreateOrConnectWithoutUserInput[]
    upsert?: sys_user_ban_menuUpsertWithWhereUniqueWithoutUserInput | sys_user_ban_menuUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: sys_user_ban_menuCreateManyUserInputEnvelope
    set?: sys_user_ban_menuWhereUniqueInput | sys_user_ban_menuWhereUniqueInput[]
    disconnect?: sys_user_ban_menuWhereUniqueInput | sys_user_ban_menuWhereUniqueInput[]
    delete?: sys_user_ban_menuWhereUniqueInput | sys_user_ban_menuWhereUniqueInput[]
    connect?: sys_user_ban_menuWhereUniqueInput | sys_user_ban_menuWhereUniqueInput[]
    update?: sys_user_ban_menuUpdateWithWhereUniqueWithoutUserInput | sys_user_ban_menuUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: sys_user_ban_menuUpdateManyWithWhereWithoutUserInput | sys_user_ban_menuUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: sys_user_ban_menuScalarWhereInput | sys_user_ban_menuScalarWhereInput[]
  }

  export type sys_userCreateNestedOneWithoutAccountsInput = {
    create?: XOR<sys_userCreateWithoutAccountsInput, sys_userUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: sys_userCreateOrConnectWithoutAccountsInput
    connect?: sys_userWhereUniqueInput
  }

  export type Enumsys_account_providerFieldUpdateOperationsInput = {
    set?: $Enums.sys_account_provider
  }

  export type sys_userUpdateOneWithoutAccountsNestedInput = {
    create?: XOR<sys_userCreateWithoutAccountsInput, sys_userUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: sys_userCreateOrConnectWithoutAccountsInput
    upsert?: sys_userUpsertWithoutAccountsInput
    disconnect?: sys_userWhereInput | boolean
    delete?: sys_userWhereInput | boolean
    connect?: sys_userWhereUniqueInput
    update?: XOR<XOR<sys_userUpdateToOneWithWhereWithoutAccountsInput, sys_userUpdateWithoutAccountsInput>, sys_userUncheckedUpdateWithoutAccountsInput>
  }

  export type sys_menuCreateNestedOneWithoutChildrenInput = {
    create?: XOR<sys_menuCreateWithoutChildrenInput, sys_menuUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: sys_menuCreateOrConnectWithoutChildrenInput
    connect?: sys_menuWhereUniqueInput
  }

  export type sys_menuCreateNestedManyWithoutParentInput = {
    create?: XOR<sys_menuCreateWithoutParentInput, sys_menuUncheckedCreateWithoutParentInput> | sys_menuCreateWithoutParentInput[] | sys_menuUncheckedCreateWithoutParentInput[]
    connectOrCreate?: sys_menuCreateOrConnectWithoutParentInput | sys_menuCreateOrConnectWithoutParentInput[]
    createMany?: sys_menuCreateManyParentInputEnvelope
    connect?: sys_menuWhereUniqueInput | sys_menuWhereUniqueInput[]
  }

  export type sys_menu_on_roleCreateNestedManyWithoutMenuInput = {
    create?: XOR<sys_menu_on_roleCreateWithoutMenuInput, sys_menu_on_roleUncheckedCreateWithoutMenuInput> | sys_menu_on_roleCreateWithoutMenuInput[] | sys_menu_on_roleUncheckedCreateWithoutMenuInput[]
    connectOrCreate?: sys_menu_on_roleCreateOrConnectWithoutMenuInput | sys_menu_on_roleCreateOrConnectWithoutMenuInput[]
    createMany?: sys_menu_on_roleCreateManyMenuInputEnvelope
    connect?: sys_menu_on_roleWhereUniqueInput | sys_menu_on_roleWhereUniqueInput[]
  }

  export type sys_user_ban_menuCreateNestedManyWithoutMenuInput = {
    create?: XOR<sys_user_ban_menuCreateWithoutMenuInput, sys_user_ban_menuUncheckedCreateWithoutMenuInput> | sys_user_ban_menuCreateWithoutMenuInput[] | sys_user_ban_menuUncheckedCreateWithoutMenuInput[]
    connectOrCreate?: sys_user_ban_menuCreateOrConnectWithoutMenuInput | sys_user_ban_menuCreateOrConnectWithoutMenuInput[]
    createMany?: sys_user_ban_menuCreateManyMenuInputEnvelope
    connect?: sys_user_ban_menuWhereUniqueInput | sys_user_ban_menuWhereUniqueInput[]
  }

  export type sys_menuUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<sys_menuCreateWithoutParentInput, sys_menuUncheckedCreateWithoutParentInput> | sys_menuCreateWithoutParentInput[] | sys_menuUncheckedCreateWithoutParentInput[]
    connectOrCreate?: sys_menuCreateOrConnectWithoutParentInput | sys_menuCreateOrConnectWithoutParentInput[]
    createMany?: sys_menuCreateManyParentInputEnvelope
    connect?: sys_menuWhereUniqueInput | sys_menuWhereUniqueInput[]
  }

  export type sys_menu_on_roleUncheckedCreateNestedManyWithoutMenuInput = {
    create?: XOR<sys_menu_on_roleCreateWithoutMenuInput, sys_menu_on_roleUncheckedCreateWithoutMenuInput> | sys_menu_on_roleCreateWithoutMenuInput[] | sys_menu_on_roleUncheckedCreateWithoutMenuInput[]
    connectOrCreate?: sys_menu_on_roleCreateOrConnectWithoutMenuInput | sys_menu_on_roleCreateOrConnectWithoutMenuInput[]
    createMany?: sys_menu_on_roleCreateManyMenuInputEnvelope
    connect?: sys_menu_on_roleWhereUniqueInput | sys_menu_on_roleWhereUniqueInput[]
  }

  export type sys_user_ban_menuUncheckedCreateNestedManyWithoutMenuInput = {
    create?: XOR<sys_user_ban_menuCreateWithoutMenuInput, sys_user_ban_menuUncheckedCreateWithoutMenuInput> | sys_user_ban_menuCreateWithoutMenuInput[] | sys_user_ban_menuUncheckedCreateWithoutMenuInput[]
    connectOrCreate?: sys_user_ban_menuCreateOrConnectWithoutMenuInput | sys_user_ban_menuCreateOrConnectWithoutMenuInput[]
    createMany?: sys_user_ban_menuCreateManyMenuInputEnvelope
    connect?: sys_user_ban_menuWhereUniqueInput | sys_user_ban_menuWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type sys_menuUpdateOneWithoutChildrenNestedInput = {
    create?: XOR<sys_menuCreateWithoutChildrenInput, sys_menuUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: sys_menuCreateOrConnectWithoutChildrenInput
    upsert?: sys_menuUpsertWithoutChildrenInput
    disconnect?: sys_menuWhereInput | boolean
    delete?: sys_menuWhereInput | boolean
    connect?: sys_menuWhereUniqueInput
    update?: XOR<XOR<sys_menuUpdateToOneWithWhereWithoutChildrenInput, sys_menuUpdateWithoutChildrenInput>, sys_menuUncheckedUpdateWithoutChildrenInput>
  }

  export type sys_menuUpdateManyWithoutParentNestedInput = {
    create?: XOR<sys_menuCreateWithoutParentInput, sys_menuUncheckedCreateWithoutParentInput> | sys_menuCreateWithoutParentInput[] | sys_menuUncheckedCreateWithoutParentInput[]
    connectOrCreate?: sys_menuCreateOrConnectWithoutParentInput | sys_menuCreateOrConnectWithoutParentInput[]
    upsert?: sys_menuUpsertWithWhereUniqueWithoutParentInput | sys_menuUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: sys_menuCreateManyParentInputEnvelope
    set?: sys_menuWhereUniqueInput | sys_menuWhereUniqueInput[]
    disconnect?: sys_menuWhereUniqueInput | sys_menuWhereUniqueInput[]
    delete?: sys_menuWhereUniqueInput | sys_menuWhereUniqueInput[]
    connect?: sys_menuWhereUniqueInput | sys_menuWhereUniqueInput[]
    update?: sys_menuUpdateWithWhereUniqueWithoutParentInput | sys_menuUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: sys_menuUpdateManyWithWhereWithoutParentInput | sys_menuUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: sys_menuScalarWhereInput | sys_menuScalarWhereInput[]
  }

  export type sys_menu_on_roleUpdateManyWithoutMenuNestedInput = {
    create?: XOR<sys_menu_on_roleCreateWithoutMenuInput, sys_menu_on_roleUncheckedCreateWithoutMenuInput> | sys_menu_on_roleCreateWithoutMenuInput[] | sys_menu_on_roleUncheckedCreateWithoutMenuInput[]
    connectOrCreate?: sys_menu_on_roleCreateOrConnectWithoutMenuInput | sys_menu_on_roleCreateOrConnectWithoutMenuInput[]
    upsert?: sys_menu_on_roleUpsertWithWhereUniqueWithoutMenuInput | sys_menu_on_roleUpsertWithWhereUniqueWithoutMenuInput[]
    createMany?: sys_menu_on_roleCreateManyMenuInputEnvelope
    set?: sys_menu_on_roleWhereUniqueInput | sys_menu_on_roleWhereUniqueInput[]
    disconnect?: sys_menu_on_roleWhereUniqueInput | sys_menu_on_roleWhereUniqueInput[]
    delete?: sys_menu_on_roleWhereUniqueInput | sys_menu_on_roleWhereUniqueInput[]
    connect?: sys_menu_on_roleWhereUniqueInput | sys_menu_on_roleWhereUniqueInput[]
    update?: sys_menu_on_roleUpdateWithWhereUniqueWithoutMenuInput | sys_menu_on_roleUpdateWithWhereUniqueWithoutMenuInput[]
    updateMany?: sys_menu_on_roleUpdateManyWithWhereWithoutMenuInput | sys_menu_on_roleUpdateManyWithWhereWithoutMenuInput[]
    deleteMany?: sys_menu_on_roleScalarWhereInput | sys_menu_on_roleScalarWhereInput[]
  }

  export type sys_user_ban_menuUpdateManyWithoutMenuNestedInput = {
    create?: XOR<sys_user_ban_menuCreateWithoutMenuInput, sys_user_ban_menuUncheckedCreateWithoutMenuInput> | sys_user_ban_menuCreateWithoutMenuInput[] | sys_user_ban_menuUncheckedCreateWithoutMenuInput[]
    connectOrCreate?: sys_user_ban_menuCreateOrConnectWithoutMenuInput | sys_user_ban_menuCreateOrConnectWithoutMenuInput[]
    upsert?: sys_user_ban_menuUpsertWithWhereUniqueWithoutMenuInput | sys_user_ban_menuUpsertWithWhereUniqueWithoutMenuInput[]
    createMany?: sys_user_ban_menuCreateManyMenuInputEnvelope
    set?: sys_user_ban_menuWhereUniqueInput | sys_user_ban_menuWhereUniqueInput[]
    disconnect?: sys_user_ban_menuWhereUniqueInput | sys_user_ban_menuWhereUniqueInput[]
    delete?: sys_user_ban_menuWhereUniqueInput | sys_user_ban_menuWhereUniqueInput[]
    connect?: sys_user_ban_menuWhereUniqueInput | sys_user_ban_menuWhereUniqueInput[]
    update?: sys_user_ban_menuUpdateWithWhereUniqueWithoutMenuInput | sys_user_ban_menuUpdateWithWhereUniqueWithoutMenuInput[]
    updateMany?: sys_user_ban_menuUpdateManyWithWhereWithoutMenuInput | sys_user_ban_menuUpdateManyWithWhereWithoutMenuInput[]
    deleteMany?: sys_user_ban_menuScalarWhereInput | sys_user_ban_menuScalarWhereInput[]
  }

  export type sys_menuUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<sys_menuCreateWithoutParentInput, sys_menuUncheckedCreateWithoutParentInput> | sys_menuCreateWithoutParentInput[] | sys_menuUncheckedCreateWithoutParentInput[]
    connectOrCreate?: sys_menuCreateOrConnectWithoutParentInput | sys_menuCreateOrConnectWithoutParentInput[]
    upsert?: sys_menuUpsertWithWhereUniqueWithoutParentInput | sys_menuUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: sys_menuCreateManyParentInputEnvelope
    set?: sys_menuWhereUniqueInput | sys_menuWhereUniqueInput[]
    disconnect?: sys_menuWhereUniqueInput | sys_menuWhereUniqueInput[]
    delete?: sys_menuWhereUniqueInput | sys_menuWhereUniqueInput[]
    connect?: sys_menuWhereUniqueInput | sys_menuWhereUniqueInput[]
    update?: sys_menuUpdateWithWhereUniqueWithoutParentInput | sys_menuUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: sys_menuUpdateManyWithWhereWithoutParentInput | sys_menuUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: sys_menuScalarWhereInput | sys_menuScalarWhereInput[]
  }

  export type sys_menu_on_roleUncheckedUpdateManyWithoutMenuNestedInput = {
    create?: XOR<sys_menu_on_roleCreateWithoutMenuInput, sys_menu_on_roleUncheckedCreateWithoutMenuInput> | sys_menu_on_roleCreateWithoutMenuInput[] | sys_menu_on_roleUncheckedCreateWithoutMenuInput[]
    connectOrCreate?: sys_menu_on_roleCreateOrConnectWithoutMenuInput | sys_menu_on_roleCreateOrConnectWithoutMenuInput[]
    upsert?: sys_menu_on_roleUpsertWithWhereUniqueWithoutMenuInput | sys_menu_on_roleUpsertWithWhereUniqueWithoutMenuInput[]
    createMany?: sys_menu_on_roleCreateManyMenuInputEnvelope
    set?: sys_menu_on_roleWhereUniqueInput | sys_menu_on_roleWhereUniqueInput[]
    disconnect?: sys_menu_on_roleWhereUniqueInput | sys_menu_on_roleWhereUniqueInput[]
    delete?: sys_menu_on_roleWhereUniqueInput | sys_menu_on_roleWhereUniqueInput[]
    connect?: sys_menu_on_roleWhereUniqueInput | sys_menu_on_roleWhereUniqueInput[]
    update?: sys_menu_on_roleUpdateWithWhereUniqueWithoutMenuInput | sys_menu_on_roleUpdateWithWhereUniqueWithoutMenuInput[]
    updateMany?: sys_menu_on_roleUpdateManyWithWhereWithoutMenuInput | sys_menu_on_roleUpdateManyWithWhereWithoutMenuInput[]
    deleteMany?: sys_menu_on_roleScalarWhereInput | sys_menu_on_roleScalarWhereInput[]
  }

  export type sys_user_ban_menuUncheckedUpdateManyWithoutMenuNestedInput = {
    create?: XOR<sys_user_ban_menuCreateWithoutMenuInput, sys_user_ban_menuUncheckedCreateWithoutMenuInput> | sys_user_ban_menuCreateWithoutMenuInput[] | sys_user_ban_menuUncheckedCreateWithoutMenuInput[]
    connectOrCreate?: sys_user_ban_menuCreateOrConnectWithoutMenuInput | sys_user_ban_menuCreateOrConnectWithoutMenuInput[]
    upsert?: sys_user_ban_menuUpsertWithWhereUniqueWithoutMenuInput | sys_user_ban_menuUpsertWithWhereUniqueWithoutMenuInput[]
    createMany?: sys_user_ban_menuCreateManyMenuInputEnvelope
    set?: sys_user_ban_menuWhereUniqueInput | sys_user_ban_menuWhereUniqueInput[]
    disconnect?: sys_user_ban_menuWhereUniqueInput | sys_user_ban_menuWhereUniqueInput[]
    delete?: sys_user_ban_menuWhereUniqueInput | sys_user_ban_menuWhereUniqueInput[]
    connect?: sys_user_ban_menuWhereUniqueInput | sys_user_ban_menuWhereUniqueInput[]
    update?: sys_user_ban_menuUpdateWithWhereUniqueWithoutMenuInput | sys_user_ban_menuUpdateWithWhereUniqueWithoutMenuInput[]
    updateMany?: sys_user_ban_menuUpdateManyWithWhereWithoutMenuInput | sys_user_ban_menuUpdateManyWithWhereWithoutMenuInput[]
    deleteMany?: sys_user_ban_menuScalarWhereInput | sys_user_ban_menuScalarWhereInput[]
  }

  export type sys_userCreateNestedOneWithoutBan_menusInput = {
    create?: XOR<sys_userCreateWithoutBan_menusInput, sys_userUncheckedCreateWithoutBan_menusInput>
    connectOrCreate?: sys_userCreateOrConnectWithoutBan_menusInput
    connect?: sys_userWhereUniqueInput
  }

  export type sys_menuCreateNestedOneWithoutUser_bansInput = {
    create?: XOR<sys_menuCreateWithoutUser_bansInput, sys_menuUncheckedCreateWithoutUser_bansInput>
    connectOrCreate?: sys_menuCreateOrConnectWithoutUser_bansInput
    connect?: sys_menuWhereUniqueInput
  }

  export type sys_userUpdateOneRequiredWithoutBan_menusNestedInput = {
    create?: XOR<sys_userCreateWithoutBan_menusInput, sys_userUncheckedCreateWithoutBan_menusInput>
    connectOrCreate?: sys_userCreateOrConnectWithoutBan_menusInput
    upsert?: sys_userUpsertWithoutBan_menusInput
    connect?: sys_userWhereUniqueInput
    update?: XOR<XOR<sys_userUpdateToOneWithWhereWithoutBan_menusInput, sys_userUpdateWithoutBan_menusInput>, sys_userUncheckedUpdateWithoutBan_menusInput>
  }

  export type sys_menuUpdateOneRequiredWithoutUser_bansNestedInput = {
    create?: XOR<sys_menuCreateWithoutUser_bansInput, sys_menuUncheckedCreateWithoutUser_bansInput>
    connectOrCreate?: sys_menuCreateOrConnectWithoutUser_bansInput
    upsert?: sys_menuUpsertWithoutUser_bansInput
    connect?: sys_menuWhereUniqueInput
    update?: XOR<XOR<sys_menuUpdateToOneWithWhereWithoutUser_bansInput, sys_menuUpdateWithoutUser_bansInput>, sys_menuUncheckedUpdateWithoutUser_bansInput>
  }

  export type sys_menuCreateNestedOneWithoutRolesInput = {
    create?: XOR<sys_menuCreateWithoutRolesInput, sys_menuUncheckedCreateWithoutRolesInput>
    connectOrCreate?: sys_menuCreateOrConnectWithoutRolesInput
    connect?: sys_menuWhereUniqueInput
  }

  export type sys_roleCreateNestedOneWithoutMenusInput = {
    create?: XOR<sys_roleCreateWithoutMenusInput, sys_roleUncheckedCreateWithoutMenusInput>
    connectOrCreate?: sys_roleCreateOrConnectWithoutMenusInput
    connect?: sys_roleWhereUniqueInput
  }

  export type BigIntFieldUpdateOperationsInput = {
    set?: bigint | number
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type sys_menuUpdateOneRequiredWithoutRolesNestedInput = {
    create?: XOR<sys_menuCreateWithoutRolesInput, sys_menuUncheckedCreateWithoutRolesInput>
    connectOrCreate?: sys_menuCreateOrConnectWithoutRolesInput
    upsert?: sys_menuUpsertWithoutRolesInput
    connect?: sys_menuWhereUniqueInput
    update?: XOR<XOR<sys_menuUpdateToOneWithWhereWithoutRolesInput, sys_menuUpdateWithoutRolesInput>, sys_menuUncheckedUpdateWithoutRolesInput>
  }

  export type sys_roleUpdateOneRequiredWithoutMenusNestedInput = {
    create?: XOR<sys_roleCreateWithoutMenusInput, sys_roleUncheckedCreateWithoutMenusInput>
    connectOrCreate?: sys_roleCreateOrConnectWithoutMenusInput
    upsert?: sys_roleUpsertWithoutMenusInput
    connect?: sys_roleWhereUniqueInput
    update?: XOR<XOR<sys_roleUpdateToOneWithWhereWithoutMenusInput, sys_roleUpdateWithoutMenusInput>, sys_roleUncheckedUpdateWithoutMenusInput>
  }

  export type sys_menu_on_roleCreateNestedManyWithoutRoleInput = {
    create?: XOR<sys_menu_on_roleCreateWithoutRoleInput, sys_menu_on_roleUncheckedCreateWithoutRoleInput> | sys_menu_on_roleCreateWithoutRoleInput[] | sys_menu_on_roleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: sys_menu_on_roleCreateOrConnectWithoutRoleInput | sys_menu_on_roleCreateOrConnectWithoutRoleInput[]
    createMany?: sys_menu_on_roleCreateManyRoleInputEnvelope
    connect?: sys_menu_on_roleWhereUniqueInput | sys_menu_on_roleWhereUniqueInput[]
  }

  export type sys_userCreateNestedManyWithoutRoleInput = {
    create?: XOR<sys_userCreateWithoutRoleInput, sys_userUncheckedCreateWithoutRoleInput> | sys_userCreateWithoutRoleInput[] | sys_userUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: sys_userCreateOrConnectWithoutRoleInput | sys_userCreateOrConnectWithoutRoleInput[]
    createMany?: sys_userCreateManyRoleInputEnvelope
    connect?: sys_userWhereUniqueInput | sys_userWhereUniqueInput[]
  }

  export type sys_menu_on_roleUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<sys_menu_on_roleCreateWithoutRoleInput, sys_menu_on_roleUncheckedCreateWithoutRoleInput> | sys_menu_on_roleCreateWithoutRoleInput[] | sys_menu_on_roleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: sys_menu_on_roleCreateOrConnectWithoutRoleInput | sys_menu_on_roleCreateOrConnectWithoutRoleInput[]
    createMany?: sys_menu_on_roleCreateManyRoleInputEnvelope
    connect?: sys_menu_on_roleWhereUniqueInput | sys_menu_on_roleWhereUniqueInput[]
  }

  export type sys_userUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<sys_userCreateWithoutRoleInput, sys_userUncheckedCreateWithoutRoleInput> | sys_userCreateWithoutRoleInput[] | sys_userUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: sys_userCreateOrConnectWithoutRoleInput | sys_userCreateOrConnectWithoutRoleInput[]
    createMany?: sys_userCreateManyRoleInputEnvelope
    connect?: sys_userWhereUniqueInput | sys_userWhereUniqueInput[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type sys_menu_on_roleUpdateManyWithoutRoleNestedInput = {
    create?: XOR<sys_menu_on_roleCreateWithoutRoleInput, sys_menu_on_roleUncheckedCreateWithoutRoleInput> | sys_menu_on_roleCreateWithoutRoleInput[] | sys_menu_on_roleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: sys_menu_on_roleCreateOrConnectWithoutRoleInput | sys_menu_on_roleCreateOrConnectWithoutRoleInput[]
    upsert?: sys_menu_on_roleUpsertWithWhereUniqueWithoutRoleInput | sys_menu_on_roleUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: sys_menu_on_roleCreateManyRoleInputEnvelope
    set?: sys_menu_on_roleWhereUniqueInput | sys_menu_on_roleWhereUniqueInput[]
    disconnect?: sys_menu_on_roleWhereUniqueInput | sys_menu_on_roleWhereUniqueInput[]
    delete?: sys_menu_on_roleWhereUniqueInput | sys_menu_on_roleWhereUniqueInput[]
    connect?: sys_menu_on_roleWhereUniqueInput | sys_menu_on_roleWhereUniqueInput[]
    update?: sys_menu_on_roleUpdateWithWhereUniqueWithoutRoleInput | sys_menu_on_roleUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: sys_menu_on_roleUpdateManyWithWhereWithoutRoleInput | sys_menu_on_roleUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: sys_menu_on_roleScalarWhereInput | sys_menu_on_roleScalarWhereInput[]
  }

  export type sys_userUpdateManyWithoutRoleNestedInput = {
    create?: XOR<sys_userCreateWithoutRoleInput, sys_userUncheckedCreateWithoutRoleInput> | sys_userCreateWithoutRoleInput[] | sys_userUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: sys_userCreateOrConnectWithoutRoleInput | sys_userCreateOrConnectWithoutRoleInput[]
    upsert?: sys_userUpsertWithWhereUniqueWithoutRoleInput | sys_userUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: sys_userCreateManyRoleInputEnvelope
    set?: sys_userWhereUniqueInput | sys_userWhereUniqueInput[]
    disconnect?: sys_userWhereUniqueInput | sys_userWhereUniqueInput[]
    delete?: sys_userWhereUniqueInput | sys_userWhereUniqueInput[]
    connect?: sys_userWhereUniqueInput | sys_userWhereUniqueInput[]
    update?: sys_userUpdateWithWhereUniqueWithoutRoleInput | sys_userUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: sys_userUpdateManyWithWhereWithoutRoleInput | sys_userUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: sys_userScalarWhereInput | sys_userScalarWhereInput[]
  }

  export type sys_menu_on_roleUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<sys_menu_on_roleCreateWithoutRoleInput, sys_menu_on_roleUncheckedCreateWithoutRoleInput> | sys_menu_on_roleCreateWithoutRoleInput[] | sys_menu_on_roleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: sys_menu_on_roleCreateOrConnectWithoutRoleInput | sys_menu_on_roleCreateOrConnectWithoutRoleInput[]
    upsert?: sys_menu_on_roleUpsertWithWhereUniqueWithoutRoleInput | sys_menu_on_roleUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: sys_menu_on_roleCreateManyRoleInputEnvelope
    set?: sys_menu_on_roleWhereUniqueInput | sys_menu_on_roleWhereUniqueInput[]
    disconnect?: sys_menu_on_roleWhereUniqueInput | sys_menu_on_roleWhereUniqueInput[]
    delete?: sys_menu_on_roleWhereUniqueInput | sys_menu_on_roleWhereUniqueInput[]
    connect?: sys_menu_on_roleWhereUniqueInput | sys_menu_on_roleWhereUniqueInput[]
    update?: sys_menu_on_roleUpdateWithWhereUniqueWithoutRoleInput | sys_menu_on_roleUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: sys_menu_on_roleUpdateManyWithWhereWithoutRoleInput | sys_menu_on_roleUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: sys_menu_on_roleScalarWhereInput | sys_menu_on_roleScalarWhereInput[]
  }

  export type sys_userUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<sys_userCreateWithoutRoleInput, sys_userUncheckedCreateWithoutRoleInput> | sys_userCreateWithoutRoleInput[] | sys_userUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: sys_userCreateOrConnectWithoutRoleInput | sys_userCreateOrConnectWithoutRoleInput[]
    upsert?: sys_userUpsertWithWhereUniqueWithoutRoleInput | sys_userUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: sys_userCreateManyRoleInputEnvelope
    set?: sys_userWhereUniqueInput | sys_userWhereUniqueInput[]
    disconnect?: sys_userWhereUniqueInput | sys_userWhereUniqueInput[]
    delete?: sys_userWhereUniqueInput | sys_userWhereUniqueInput[]
    connect?: sys_userWhereUniqueInput | sys_userWhereUniqueInput[]
    update?: sys_userUpdateWithWhereUniqueWithoutRoleInput | sys_userUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: sys_userUpdateManyWithWhereWithoutRoleInput | sys_userUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: sys_userScalarWhereInput | sys_userScalarWhereInput[]
  }

  export type blog_postsCreateNestedManyWithoutUserInput = {
    create?: XOR<blog_postsCreateWithoutUserInput, blog_postsUncheckedCreateWithoutUserInput> | blog_postsCreateWithoutUserInput[] | blog_postsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: blog_postsCreateOrConnectWithoutUserInput | blog_postsCreateOrConnectWithoutUserInput[]
    createMany?: blog_postsCreateManyUserInputEnvelope
    connect?: blog_postsWhereUniqueInput | blog_postsWhereUniqueInput[]
  }

  export type blog_postsUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<blog_postsCreateWithoutUserInput, blog_postsUncheckedCreateWithoutUserInput> | blog_postsCreateWithoutUserInput[] | blog_postsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: blog_postsCreateOrConnectWithoutUserInput | blog_postsCreateOrConnectWithoutUserInput[]
    createMany?: blog_postsCreateManyUserInputEnvelope
    connect?: blog_postsWhereUniqueInput | blog_postsWhereUniqueInput[]
  }

  export type blog_postsUpdateManyWithoutUserNestedInput = {
    create?: XOR<blog_postsCreateWithoutUserInput, blog_postsUncheckedCreateWithoutUserInput> | blog_postsCreateWithoutUserInput[] | blog_postsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: blog_postsCreateOrConnectWithoutUserInput | blog_postsCreateOrConnectWithoutUserInput[]
    upsert?: blog_postsUpsertWithWhereUniqueWithoutUserInput | blog_postsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: blog_postsCreateManyUserInputEnvelope
    set?: blog_postsWhereUniqueInput | blog_postsWhereUniqueInput[]
    disconnect?: blog_postsWhereUniqueInput | blog_postsWhereUniqueInput[]
    delete?: blog_postsWhereUniqueInput | blog_postsWhereUniqueInput[]
    connect?: blog_postsWhereUniqueInput | blog_postsWhereUniqueInput[]
    update?: blog_postsUpdateWithWhereUniqueWithoutUserInput | blog_postsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: blog_postsUpdateManyWithWhereWithoutUserInput | blog_postsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: blog_postsScalarWhereInput | blog_postsScalarWhereInput[]
  }

  export type blog_postsUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<blog_postsCreateWithoutUserInput, blog_postsUncheckedCreateWithoutUserInput> | blog_postsCreateWithoutUserInput[] | blog_postsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: blog_postsCreateOrConnectWithoutUserInput | blog_postsCreateOrConnectWithoutUserInput[]
    upsert?: blog_postsUpsertWithWhereUniqueWithoutUserInput | blog_postsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: blog_postsCreateManyUserInputEnvelope
    set?: blog_postsWhereUniqueInput | blog_postsWhereUniqueInput[]
    disconnect?: blog_postsWhereUniqueInput | blog_postsWhereUniqueInput[]
    delete?: blog_postsWhereUniqueInput | blog_postsWhereUniqueInput[]
    connect?: blog_postsWhereUniqueInput | blog_postsWhereUniqueInput[]
    update?: blog_postsUpdateWithWhereUniqueWithoutUserInput | blog_postsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: blog_postsUpdateManyWithWhereWithoutUserInput | blog_postsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: blog_postsScalarWhereInput | blog_postsScalarWhereInput[]
  }

  export type blog_postsCreateNestedManyWithoutCategoriesInput = {
    create?: XOR<blog_postsCreateWithoutCategoriesInput, blog_postsUncheckedCreateWithoutCategoriesInput> | blog_postsCreateWithoutCategoriesInput[] | blog_postsUncheckedCreateWithoutCategoriesInput[]
    connectOrCreate?: blog_postsCreateOrConnectWithoutCategoriesInput | blog_postsCreateOrConnectWithoutCategoriesInput[]
    createMany?: blog_postsCreateManyCategoriesInputEnvelope
    connect?: blog_postsWhereUniqueInput | blog_postsWhereUniqueInput[]
  }

  export type blog_postsUncheckedCreateNestedManyWithoutCategoriesInput = {
    create?: XOR<blog_postsCreateWithoutCategoriesInput, blog_postsUncheckedCreateWithoutCategoriesInput> | blog_postsCreateWithoutCategoriesInput[] | blog_postsUncheckedCreateWithoutCategoriesInput[]
    connectOrCreate?: blog_postsCreateOrConnectWithoutCategoriesInput | blog_postsCreateOrConnectWithoutCategoriesInput[]
    createMany?: blog_postsCreateManyCategoriesInputEnvelope
    connect?: blog_postsWhereUniqueInput | blog_postsWhereUniqueInput[]
  }

  export type blog_postsUpdateManyWithoutCategoriesNestedInput = {
    create?: XOR<blog_postsCreateWithoutCategoriesInput, blog_postsUncheckedCreateWithoutCategoriesInput> | blog_postsCreateWithoutCategoriesInput[] | blog_postsUncheckedCreateWithoutCategoriesInput[]
    connectOrCreate?: blog_postsCreateOrConnectWithoutCategoriesInput | blog_postsCreateOrConnectWithoutCategoriesInput[]
    upsert?: blog_postsUpsertWithWhereUniqueWithoutCategoriesInput | blog_postsUpsertWithWhereUniqueWithoutCategoriesInput[]
    createMany?: blog_postsCreateManyCategoriesInputEnvelope
    set?: blog_postsWhereUniqueInput | blog_postsWhereUniqueInput[]
    disconnect?: blog_postsWhereUniqueInput | blog_postsWhereUniqueInput[]
    delete?: blog_postsWhereUniqueInput | blog_postsWhereUniqueInput[]
    connect?: blog_postsWhereUniqueInput | blog_postsWhereUniqueInput[]
    update?: blog_postsUpdateWithWhereUniqueWithoutCategoriesInput | blog_postsUpdateWithWhereUniqueWithoutCategoriesInput[]
    updateMany?: blog_postsUpdateManyWithWhereWithoutCategoriesInput | blog_postsUpdateManyWithWhereWithoutCategoriesInput[]
    deleteMany?: blog_postsScalarWhereInput | blog_postsScalarWhereInput[]
  }

  export type blog_postsUncheckedUpdateManyWithoutCategoriesNestedInput = {
    create?: XOR<blog_postsCreateWithoutCategoriesInput, blog_postsUncheckedCreateWithoutCategoriesInput> | blog_postsCreateWithoutCategoriesInput[] | blog_postsUncheckedCreateWithoutCategoriesInput[]
    connectOrCreate?: blog_postsCreateOrConnectWithoutCategoriesInput | blog_postsCreateOrConnectWithoutCategoriesInput[]
    upsert?: blog_postsUpsertWithWhereUniqueWithoutCategoriesInput | blog_postsUpsertWithWhereUniqueWithoutCategoriesInput[]
    createMany?: blog_postsCreateManyCategoriesInputEnvelope
    set?: blog_postsWhereUniqueInput | blog_postsWhereUniqueInput[]
    disconnect?: blog_postsWhereUniqueInput | blog_postsWhereUniqueInput[]
    delete?: blog_postsWhereUniqueInput | blog_postsWhereUniqueInput[]
    connect?: blog_postsWhereUniqueInput | blog_postsWhereUniqueInput[]
    update?: blog_postsUpdateWithWhereUniqueWithoutCategoriesInput | blog_postsUpdateWithWhereUniqueWithoutCategoriesInput[]
    updateMany?: blog_postsUpdateManyWithWhereWithoutCategoriesInput | blog_postsUpdateManyWithWhereWithoutCategoriesInput[]
    deleteMany?: blog_postsScalarWhereInput | blog_postsScalarWhereInput[]
  }

  export type blog_categoriesCreateNestedOneWithoutPostsInput = {
    create?: XOR<blog_categoriesCreateWithoutPostsInput, blog_categoriesUncheckedCreateWithoutPostsInput>
    connectOrCreate?: blog_categoriesCreateOrConnectWithoutPostsInput
    connect?: blog_categoriesWhereUniqueInput
  }

  export type blog_userCreateNestedOneWithoutPostsInput = {
    create?: XOR<blog_userCreateWithoutPostsInput, blog_userUncheckedCreateWithoutPostsInput>
    connectOrCreate?: blog_userCreateOrConnectWithoutPostsInput
    connect?: blog_userWhereUniqueInput
  }

  export type blog_posts_on_tagsCreateNestedManyWithoutPostsInput = {
    create?: XOR<blog_posts_on_tagsCreateWithoutPostsInput, blog_posts_on_tagsUncheckedCreateWithoutPostsInput> | blog_posts_on_tagsCreateWithoutPostsInput[] | blog_posts_on_tagsUncheckedCreateWithoutPostsInput[]
    connectOrCreate?: blog_posts_on_tagsCreateOrConnectWithoutPostsInput | blog_posts_on_tagsCreateOrConnectWithoutPostsInput[]
    createMany?: blog_posts_on_tagsCreateManyPostsInputEnvelope
    connect?: blog_posts_on_tagsWhereUniqueInput | blog_posts_on_tagsWhereUniqueInput[]
  }

  export type blog_posts_on_tagsUncheckedCreateNestedManyWithoutPostsInput = {
    create?: XOR<blog_posts_on_tagsCreateWithoutPostsInput, blog_posts_on_tagsUncheckedCreateWithoutPostsInput> | blog_posts_on_tagsCreateWithoutPostsInput[] | blog_posts_on_tagsUncheckedCreateWithoutPostsInput[]
    connectOrCreate?: blog_posts_on_tagsCreateOrConnectWithoutPostsInput | blog_posts_on_tagsCreateOrConnectWithoutPostsInput[]
    createMany?: blog_posts_on_tagsCreateManyPostsInputEnvelope
    connect?: blog_posts_on_tagsWhereUniqueInput | blog_posts_on_tagsWhereUniqueInput[]
  }

  export type blog_categoriesUpdateOneWithoutPostsNestedInput = {
    create?: XOR<blog_categoriesCreateWithoutPostsInput, blog_categoriesUncheckedCreateWithoutPostsInput>
    connectOrCreate?: blog_categoriesCreateOrConnectWithoutPostsInput
    upsert?: blog_categoriesUpsertWithoutPostsInput
    disconnect?: blog_categoriesWhereInput | boolean
    delete?: blog_categoriesWhereInput | boolean
    connect?: blog_categoriesWhereUniqueInput
    update?: XOR<XOR<blog_categoriesUpdateToOneWithWhereWithoutPostsInput, blog_categoriesUpdateWithoutPostsInput>, blog_categoriesUncheckedUpdateWithoutPostsInput>
  }

  export type blog_userUpdateOneRequiredWithoutPostsNestedInput = {
    create?: XOR<blog_userCreateWithoutPostsInput, blog_userUncheckedCreateWithoutPostsInput>
    connectOrCreate?: blog_userCreateOrConnectWithoutPostsInput
    upsert?: blog_userUpsertWithoutPostsInput
    connect?: blog_userWhereUniqueInput
    update?: XOR<XOR<blog_userUpdateToOneWithWhereWithoutPostsInput, blog_userUpdateWithoutPostsInput>, blog_userUncheckedUpdateWithoutPostsInput>
  }

  export type blog_posts_on_tagsUpdateManyWithoutPostsNestedInput = {
    create?: XOR<blog_posts_on_tagsCreateWithoutPostsInput, blog_posts_on_tagsUncheckedCreateWithoutPostsInput> | blog_posts_on_tagsCreateWithoutPostsInput[] | blog_posts_on_tagsUncheckedCreateWithoutPostsInput[]
    connectOrCreate?: blog_posts_on_tagsCreateOrConnectWithoutPostsInput | blog_posts_on_tagsCreateOrConnectWithoutPostsInput[]
    upsert?: blog_posts_on_tagsUpsertWithWhereUniqueWithoutPostsInput | blog_posts_on_tagsUpsertWithWhereUniqueWithoutPostsInput[]
    createMany?: blog_posts_on_tagsCreateManyPostsInputEnvelope
    set?: blog_posts_on_tagsWhereUniqueInput | blog_posts_on_tagsWhereUniqueInput[]
    disconnect?: blog_posts_on_tagsWhereUniqueInput | blog_posts_on_tagsWhereUniqueInput[]
    delete?: blog_posts_on_tagsWhereUniqueInput | blog_posts_on_tagsWhereUniqueInput[]
    connect?: blog_posts_on_tagsWhereUniqueInput | blog_posts_on_tagsWhereUniqueInput[]
    update?: blog_posts_on_tagsUpdateWithWhereUniqueWithoutPostsInput | blog_posts_on_tagsUpdateWithWhereUniqueWithoutPostsInput[]
    updateMany?: blog_posts_on_tagsUpdateManyWithWhereWithoutPostsInput | blog_posts_on_tagsUpdateManyWithWhereWithoutPostsInput[]
    deleteMany?: blog_posts_on_tagsScalarWhereInput | blog_posts_on_tagsScalarWhereInput[]
  }

  export type blog_posts_on_tagsUncheckedUpdateManyWithoutPostsNestedInput = {
    create?: XOR<blog_posts_on_tagsCreateWithoutPostsInput, blog_posts_on_tagsUncheckedCreateWithoutPostsInput> | blog_posts_on_tagsCreateWithoutPostsInput[] | blog_posts_on_tagsUncheckedCreateWithoutPostsInput[]
    connectOrCreate?: blog_posts_on_tagsCreateOrConnectWithoutPostsInput | blog_posts_on_tagsCreateOrConnectWithoutPostsInput[]
    upsert?: blog_posts_on_tagsUpsertWithWhereUniqueWithoutPostsInput | blog_posts_on_tagsUpsertWithWhereUniqueWithoutPostsInput[]
    createMany?: blog_posts_on_tagsCreateManyPostsInputEnvelope
    set?: blog_posts_on_tagsWhereUniqueInput | blog_posts_on_tagsWhereUniqueInput[]
    disconnect?: blog_posts_on_tagsWhereUniqueInput | blog_posts_on_tagsWhereUniqueInput[]
    delete?: blog_posts_on_tagsWhereUniqueInput | blog_posts_on_tagsWhereUniqueInput[]
    connect?: blog_posts_on_tagsWhereUniqueInput | blog_posts_on_tagsWhereUniqueInput[]
    update?: blog_posts_on_tagsUpdateWithWhereUniqueWithoutPostsInput | blog_posts_on_tagsUpdateWithWhereUniqueWithoutPostsInput[]
    updateMany?: blog_posts_on_tagsUpdateManyWithWhereWithoutPostsInput | blog_posts_on_tagsUpdateManyWithWhereWithoutPostsInput[]
    deleteMany?: blog_posts_on_tagsScalarWhereInput | blog_posts_on_tagsScalarWhereInput[]
  }

  export type blog_postsCreateNestedOneWithoutTagsInput = {
    create?: XOR<blog_postsCreateWithoutTagsInput, blog_postsUncheckedCreateWithoutTagsInput>
    connectOrCreate?: blog_postsCreateOrConnectWithoutTagsInput
    connect?: blog_postsWhereUniqueInput
  }

  export type blog_tagCreateNestedOneWithoutBlog_posts_on_tagsInput = {
    create?: XOR<blog_tagCreateWithoutBlog_posts_on_tagsInput, blog_tagUncheckedCreateWithoutBlog_posts_on_tagsInput>
    connectOrCreate?: blog_tagCreateOrConnectWithoutBlog_posts_on_tagsInput
    connect?: blog_tagWhereUniqueInput
  }

  export type blog_postsUpdateOneRequiredWithoutTagsNestedInput = {
    create?: XOR<blog_postsCreateWithoutTagsInput, blog_postsUncheckedCreateWithoutTagsInput>
    connectOrCreate?: blog_postsCreateOrConnectWithoutTagsInput
    upsert?: blog_postsUpsertWithoutTagsInput
    connect?: blog_postsWhereUniqueInput
    update?: XOR<XOR<blog_postsUpdateToOneWithWhereWithoutTagsInput, blog_postsUpdateWithoutTagsInput>, blog_postsUncheckedUpdateWithoutTagsInput>
  }

  export type blog_tagUpdateOneRequiredWithoutBlog_posts_on_tagsNestedInput = {
    create?: XOR<blog_tagCreateWithoutBlog_posts_on_tagsInput, blog_tagUncheckedCreateWithoutBlog_posts_on_tagsInput>
    connectOrCreate?: blog_tagCreateOrConnectWithoutBlog_posts_on_tagsInput
    upsert?: blog_tagUpsertWithoutBlog_posts_on_tagsInput
    connect?: blog_tagWhereUniqueInput
    update?: XOR<XOR<blog_tagUpdateToOneWithWhereWithoutBlog_posts_on_tagsInput, blog_tagUpdateWithoutBlog_posts_on_tagsInput>, blog_tagUncheckedUpdateWithoutBlog_posts_on_tagsInput>
  }

  export type blog_posts_on_tagsCreateNestedManyWithoutTagInput = {
    create?: XOR<blog_posts_on_tagsCreateWithoutTagInput, blog_posts_on_tagsUncheckedCreateWithoutTagInput> | blog_posts_on_tagsCreateWithoutTagInput[] | blog_posts_on_tagsUncheckedCreateWithoutTagInput[]
    connectOrCreate?: blog_posts_on_tagsCreateOrConnectWithoutTagInput | blog_posts_on_tagsCreateOrConnectWithoutTagInput[]
    createMany?: blog_posts_on_tagsCreateManyTagInputEnvelope
    connect?: blog_posts_on_tagsWhereUniqueInput | blog_posts_on_tagsWhereUniqueInput[]
  }

  export type blog_posts_on_tagsUncheckedCreateNestedManyWithoutTagInput = {
    create?: XOR<blog_posts_on_tagsCreateWithoutTagInput, blog_posts_on_tagsUncheckedCreateWithoutTagInput> | blog_posts_on_tagsCreateWithoutTagInput[] | blog_posts_on_tagsUncheckedCreateWithoutTagInput[]
    connectOrCreate?: blog_posts_on_tagsCreateOrConnectWithoutTagInput | blog_posts_on_tagsCreateOrConnectWithoutTagInput[]
    createMany?: blog_posts_on_tagsCreateManyTagInputEnvelope
    connect?: blog_posts_on_tagsWhereUniqueInput | blog_posts_on_tagsWhereUniqueInput[]
  }

  export type blog_posts_on_tagsUpdateManyWithoutTagNestedInput = {
    create?: XOR<blog_posts_on_tagsCreateWithoutTagInput, blog_posts_on_tagsUncheckedCreateWithoutTagInput> | blog_posts_on_tagsCreateWithoutTagInput[] | blog_posts_on_tagsUncheckedCreateWithoutTagInput[]
    connectOrCreate?: blog_posts_on_tagsCreateOrConnectWithoutTagInput | blog_posts_on_tagsCreateOrConnectWithoutTagInput[]
    upsert?: blog_posts_on_tagsUpsertWithWhereUniqueWithoutTagInput | blog_posts_on_tagsUpsertWithWhereUniqueWithoutTagInput[]
    createMany?: blog_posts_on_tagsCreateManyTagInputEnvelope
    set?: blog_posts_on_tagsWhereUniqueInput | blog_posts_on_tagsWhereUniqueInput[]
    disconnect?: blog_posts_on_tagsWhereUniqueInput | blog_posts_on_tagsWhereUniqueInput[]
    delete?: blog_posts_on_tagsWhereUniqueInput | blog_posts_on_tagsWhereUniqueInput[]
    connect?: blog_posts_on_tagsWhereUniqueInput | blog_posts_on_tagsWhereUniqueInput[]
    update?: blog_posts_on_tagsUpdateWithWhereUniqueWithoutTagInput | blog_posts_on_tagsUpdateWithWhereUniqueWithoutTagInput[]
    updateMany?: blog_posts_on_tagsUpdateManyWithWhereWithoutTagInput | blog_posts_on_tagsUpdateManyWithWhereWithoutTagInput[]
    deleteMany?: blog_posts_on_tagsScalarWhereInput | blog_posts_on_tagsScalarWhereInput[]
  }

  export type blog_posts_on_tagsUncheckedUpdateManyWithoutTagNestedInput = {
    create?: XOR<blog_posts_on_tagsCreateWithoutTagInput, blog_posts_on_tagsUncheckedCreateWithoutTagInput> | blog_posts_on_tagsCreateWithoutTagInput[] | blog_posts_on_tagsUncheckedCreateWithoutTagInput[]
    connectOrCreate?: blog_posts_on_tagsCreateOrConnectWithoutTagInput | blog_posts_on_tagsCreateOrConnectWithoutTagInput[]
    upsert?: blog_posts_on_tagsUpsertWithWhereUniqueWithoutTagInput | blog_posts_on_tagsUpsertWithWhereUniqueWithoutTagInput[]
    createMany?: blog_posts_on_tagsCreateManyTagInputEnvelope
    set?: blog_posts_on_tagsWhereUniqueInput | blog_posts_on_tagsWhereUniqueInput[]
    disconnect?: blog_posts_on_tagsWhereUniqueInput | blog_posts_on_tagsWhereUniqueInput[]
    delete?: blog_posts_on_tagsWhereUniqueInput | blog_posts_on_tagsWhereUniqueInput[]
    connect?: blog_posts_on_tagsWhereUniqueInput | blog_posts_on_tagsWhereUniqueInput[]
    update?: blog_posts_on_tagsUpdateWithWhereUniqueWithoutTagInput | blog_posts_on_tagsUpdateWithWhereUniqueWithoutTagInput[]
    updateMany?: blog_posts_on_tagsUpdateManyWithWhereWithoutTagInput | blog_posts_on_tagsUpdateManyWithWhereWithoutTagInput[]
    deleteMany?: blog_posts_on_tagsScalarWhereInput | blog_posts_on_tagsScalarWhereInput[]
  }

  export type file_user_on_mediaCreateNestedManyWithoutUserInput = {
    create?: XOR<file_user_on_mediaCreateWithoutUserInput, file_user_on_mediaUncheckedCreateWithoutUserInput> | file_user_on_mediaCreateWithoutUserInput[] | file_user_on_mediaUncheckedCreateWithoutUserInput[]
    connectOrCreate?: file_user_on_mediaCreateOrConnectWithoutUserInput | file_user_on_mediaCreateOrConnectWithoutUserInput[]
    createMany?: file_user_on_mediaCreateManyUserInputEnvelope
    connect?: file_user_on_mediaWhereUniqueInput | file_user_on_mediaWhereUniqueInput[]
  }

  export type file_folderCreateNestedManyWithoutUserInput = {
    create?: XOR<file_folderCreateWithoutUserInput, file_folderUncheckedCreateWithoutUserInput> | file_folderCreateWithoutUserInput[] | file_folderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: file_folderCreateOrConnectWithoutUserInput | file_folderCreateOrConnectWithoutUserInput[]
    createMany?: file_folderCreateManyUserInputEnvelope
    connect?: file_folderWhereUniqueInput | file_folderWhereUniqueInput[]
  }

  export type file_configCreateNestedOneWithoutUserInput = {
    create?: XOR<file_configCreateWithoutUserInput, file_configUncheckedCreateWithoutUserInput>
    connectOrCreate?: file_configCreateOrConnectWithoutUserInput
    connect?: file_configWhereUniqueInput
  }

  export type file_keysCreateNestedManyWithoutUserInput = {
    create?: XOR<file_keysCreateWithoutUserInput, file_keysUncheckedCreateWithoutUserInput> | file_keysCreateWithoutUserInput[] | file_keysUncheckedCreateWithoutUserInput[]
    connectOrCreate?: file_keysCreateOrConnectWithoutUserInput | file_keysCreateOrConnectWithoutUserInput[]
    createMany?: file_keysCreateManyUserInputEnvelope
    connect?: file_keysWhereUniqueInput | file_keysWhereUniqueInput[]
  }

  export type file_user_on_mediaUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<file_user_on_mediaCreateWithoutUserInput, file_user_on_mediaUncheckedCreateWithoutUserInput> | file_user_on_mediaCreateWithoutUserInput[] | file_user_on_mediaUncheckedCreateWithoutUserInput[]
    connectOrCreate?: file_user_on_mediaCreateOrConnectWithoutUserInput | file_user_on_mediaCreateOrConnectWithoutUserInput[]
    createMany?: file_user_on_mediaCreateManyUserInputEnvelope
    connect?: file_user_on_mediaWhereUniqueInput | file_user_on_mediaWhereUniqueInput[]
  }

  export type file_folderUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<file_folderCreateWithoutUserInput, file_folderUncheckedCreateWithoutUserInput> | file_folderCreateWithoutUserInput[] | file_folderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: file_folderCreateOrConnectWithoutUserInput | file_folderCreateOrConnectWithoutUserInput[]
    createMany?: file_folderCreateManyUserInputEnvelope
    connect?: file_folderWhereUniqueInput | file_folderWhereUniqueInput[]
  }

  export type file_configUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<file_configCreateWithoutUserInput, file_configUncheckedCreateWithoutUserInput>
    connectOrCreate?: file_configCreateOrConnectWithoutUserInput
    connect?: file_configWhereUniqueInput
  }

  export type file_keysUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<file_keysCreateWithoutUserInput, file_keysUncheckedCreateWithoutUserInput> | file_keysCreateWithoutUserInput[] | file_keysUncheckedCreateWithoutUserInput[]
    connectOrCreate?: file_keysCreateOrConnectWithoutUserInput | file_keysCreateOrConnectWithoutUserInput[]
    createMany?: file_keysCreateManyUserInputEnvelope
    connect?: file_keysWhereUniqueInput | file_keysWhereUniqueInput[]
  }

  export type file_user_on_mediaUpdateManyWithoutUserNestedInput = {
    create?: XOR<file_user_on_mediaCreateWithoutUserInput, file_user_on_mediaUncheckedCreateWithoutUserInput> | file_user_on_mediaCreateWithoutUserInput[] | file_user_on_mediaUncheckedCreateWithoutUserInput[]
    connectOrCreate?: file_user_on_mediaCreateOrConnectWithoutUserInput | file_user_on_mediaCreateOrConnectWithoutUserInput[]
    upsert?: file_user_on_mediaUpsertWithWhereUniqueWithoutUserInput | file_user_on_mediaUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: file_user_on_mediaCreateManyUserInputEnvelope
    set?: file_user_on_mediaWhereUniqueInput | file_user_on_mediaWhereUniqueInput[]
    disconnect?: file_user_on_mediaWhereUniqueInput | file_user_on_mediaWhereUniqueInput[]
    delete?: file_user_on_mediaWhereUniqueInput | file_user_on_mediaWhereUniqueInput[]
    connect?: file_user_on_mediaWhereUniqueInput | file_user_on_mediaWhereUniqueInput[]
    update?: file_user_on_mediaUpdateWithWhereUniqueWithoutUserInput | file_user_on_mediaUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: file_user_on_mediaUpdateManyWithWhereWithoutUserInput | file_user_on_mediaUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: file_user_on_mediaScalarWhereInput | file_user_on_mediaScalarWhereInput[]
  }

  export type file_folderUpdateManyWithoutUserNestedInput = {
    create?: XOR<file_folderCreateWithoutUserInput, file_folderUncheckedCreateWithoutUserInput> | file_folderCreateWithoutUserInput[] | file_folderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: file_folderCreateOrConnectWithoutUserInput | file_folderCreateOrConnectWithoutUserInput[]
    upsert?: file_folderUpsertWithWhereUniqueWithoutUserInput | file_folderUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: file_folderCreateManyUserInputEnvelope
    set?: file_folderWhereUniqueInput | file_folderWhereUniqueInput[]
    disconnect?: file_folderWhereUniqueInput | file_folderWhereUniqueInput[]
    delete?: file_folderWhereUniqueInput | file_folderWhereUniqueInput[]
    connect?: file_folderWhereUniqueInput | file_folderWhereUniqueInput[]
    update?: file_folderUpdateWithWhereUniqueWithoutUserInput | file_folderUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: file_folderUpdateManyWithWhereWithoutUserInput | file_folderUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: file_folderScalarWhereInput | file_folderScalarWhereInput[]
  }

  export type file_configUpdateOneWithoutUserNestedInput = {
    create?: XOR<file_configCreateWithoutUserInput, file_configUncheckedCreateWithoutUserInput>
    connectOrCreate?: file_configCreateOrConnectWithoutUserInput
    upsert?: file_configUpsertWithoutUserInput
    disconnect?: file_configWhereInput | boolean
    delete?: file_configWhereInput | boolean
    connect?: file_configWhereUniqueInput
    update?: XOR<XOR<file_configUpdateToOneWithWhereWithoutUserInput, file_configUpdateWithoutUserInput>, file_configUncheckedUpdateWithoutUserInput>
  }

  export type file_keysUpdateManyWithoutUserNestedInput = {
    create?: XOR<file_keysCreateWithoutUserInput, file_keysUncheckedCreateWithoutUserInput> | file_keysCreateWithoutUserInput[] | file_keysUncheckedCreateWithoutUserInput[]
    connectOrCreate?: file_keysCreateOrConnectWithoutUserInput | file_keysCreateOrConnectWithoutUserInput[]
    upsert?: file_keysUpsertWithWhereUniqueWithoutUserInput | file_keysUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: file_keysCreateManyUserInputEnvelope
    set?: file_keysWhereUniqueInput | file_keysWhereUniqueInput[]
    disconnect?: file_keysWhereUniqueInput | file_keysWhereUniqueInput[]
    delete?: file_keysWhereUniqueInput | file_keysWhereUniqueInput[]
    connect?: file_keysWhereUniqueInput | file_keysWhereUniqueInput[]
    update?: file_keysUpdateWithWhereUniqueWithoutUserInput | file_keysUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: file_keysUpdateManyWithWhereWithoutUserInput | file_keysUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: file_keysScalarWhereInput | file_keysScalarWhereInput[]
  }

  export type file_user_on_mediaUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<file_user_on_mediaCreateWithoutUserInput, file_user_on_mediaUncheckedCreateWithoutUserInput> | file_user_on_mediaCreateWithoutUserInput[] | file_user_on_mediaUncheckedCreateWithoutUserInput[]
    connectOrCreate?: file_user_on_mediaCreateOrConnectWithoutUserInput | file_user_on_mediaCreateOrConnectWithoutUserInput[]
    upsert?: file_user_on_mediaUpsertWithWhereUniqueWithoutUserInput | file_user_on_mediaUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: file_user_on_mediaCreateManyUserInputEnvelope
    set?: file_user_on_mediaWhereUniqueInput | file_user_on_mediaWhereUniqueInput[]
    disconnect?: file_user_on_mediaWhereUniqueInput | file_user_on_mediaWhereUniqueInput[]
    delete?: file_user_on_mediaWhereUniqueInput | file_user_on_mediaWhereUniqueInput[]
    connect?: file_user_on_mediaWhereUniqueInput | file_user_on_mediaWhereUniqueInput[]
    update?: file_user_on_mediaUpdateWithWhereUniqueWithoutUserInput | file_user_on_mediaUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: file_user_on_mediaUpdateManyWithWhereWithoutUserInput | file_user_on_mediaUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: file_user_on_mediaScalarWhereInput | file_user_on_mediaScalarWhereInput[]
  }

  export type file_folderUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<file_folderCreateWithoutUserInput, file_folderUncheckedCreateWithoutUserInput> | file_folderCreateWithoutUserInput[] | file_folderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: file_folderCreateOrConnectWithoutUserInput | file_folderCreateOrConnectWithoutUserInput[]
    upsert?: file_folderUpsertWithWhereUniqueWithoutUserInput | file_folderUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: file_folderCreateManyUserInputEnvelope
    set?: file_folderWhereUniqueInput | file_folderWhereUniqueInput[]
    disconnect?: file_folderWhereUniqueInput | file_folderWhereUniqueInput[]
    delete?: file_folderWhereUniqueInput | file_folderWhereUniqueInput[]
    connect?: file_folderWhereUniqueInput | file_folderWhereUniqueInput[]
    update?: file_folderUpdateWithWhereUniqueWithoutUserInput | file_folderUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: file_folderUpdateManyWithWhereWithoutUserInput | file_folderUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: file_folderScalarWhereInput | file_folderScalarWhereInput[]
  }

  export type file_configUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<file_configCreateWithoutUserInput, file_configUncheckedCreateWithoutUserInput>
    connectOrCreate?: file_configCreateOrConnectWithoutUserInput
    upsert?: file_configUpsertWithoutUserInput
    disconnect?: file_configWhereInput | boolean
    delete?: file_configWhereInput | boolean
    connect?: file_configWhereUniqueInput
    update?: XOR<XOR<file_configUpdateToOneWithWhereWithoutUserInput, file_configUpdateWithoutUserInput>, file_configUncheckedUpdateWithoutUserInput>
  }

  export type file_keysUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<file_keysCreateWithoutUserInput, file_keysUncheckedCreateWithoutUserInput> | file_keysCreateWithoutUserInput[] | file_keysUncheckedCreateWithoutUserInput[]
    connectOrCreate?: file_keysCreateOrConnectWithoutUserInput | file_keysCreateOrConnectWithoutUserInput[]
    upsert?: file_keysUpsertWithWhereUniqueWithoutUserInput | file_keysUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: file_keysCreateManyUserInputEnvelope
    set?: file_keysWhereUniqueInput | file_keysWhereUniqueInput[]
    disconnect?: file_keysWhereUniqueInput | file_keysWhereUniqueInput[]
    delete?: file_keysWhereUniqueInput | file_keysWhereUniqueInput[]
    connect?: file_keysWhereUniqueInput | file_keysWhereUniqueInput[]
    update?: file_keysUpdateWithWhereUniqueWithoutUserInput | file_keysUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: file_keysUpdateManyWithWhereWithoutUserInput | file_keysUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: file_keysScalarWhereInput | file_keysScalarWhereInput[]
  }

  export type file_userCreateNestedOneWithoutKeysInput = {
    create?: XOR<file_userCreateWithoutKeysInput, file_userUncheckedCreateWithoutKeysInput>
    connectOrCreate?: file_userCreateOrConnectWithoutKeysInput
    connect?: file_userWhereUniqueInput
  }

  export type file_userUpdateOneRequiredWithoutKeysNestedInput = {
    create?: XOR<file_userCreateWithoutKeysInput, file_userUncheckedCreateWithoutKeysInput>
    connectOrCreate?: file_userCreateOrConnectWithoutKeysInput
    upsert?: file_userUpsertWithoutKeysInput
    connect?: file_userWhereUniqueInput
    update?: XOR<XOR<file_userUpdateToOneWithWhereWithoutKeysInput, file_userUpdateWithoutKeysInput>, file_userUncheckedUpdateWithoutKeysInput>
  }

  export type file_userCreateNestedOneWithoutFile_configInput = {
    create?: XOR<file_userCreateWithoutFile_configInput, file_userUncheckedCreateWithoutFile_configInput>
    connectOrCreate?: file_userCreateOrConnectWithoutFile_configInput
    connect?: file_userWhereUniqueInput
  }

  export type file_userUpdateOneRequiredWithoutFile_configNestedInput = {
    create?: XOR<file_userCreateWithoutFile_configInput, file_userUncheckedCreateWithoutFile_configInput>
    connectOrCreate?: file_userCreateOrConnectWithoutFile_configInput
    upsert?: file_userUpsertWithoutFile_configInput
    connect?: file_userWhereUniqueInput
    update?: XOR<XOR<file_userUpdateToOneWithWhereWithoutFile_configInput, file_userUpdateWithoutFile_configInput>, file_userUncheckedUpdateWithoutFile_configInput>
  }

  export type file_userCreateNestedOneWithoutMediasInput = {
    create?: XOR<file_userCreateWithoutMediasInput, file_userUncheckedCreateWithoutMediasInput>
    connectOrCreate?: file_userCreateOrConnectWithoutMediasInput
    connect?: file_userWhereUniqueInput
  }

  export type file_mediaCreateNestedOneWithoutUsersInput = {
    create?: XOR<file_mediaCreateWithoutUsersInput, file_mediaUncheckedCreateWithoutUsersInput>
    connectOrCreate?: file_mediaCreateOrConnectWithoutUsersInput
    connect?: file_mediaWhereUniqueInput
  }

  export type file_userUpdateOneRequiredWithoutMediasNestedInput = {
    create?: XOR<file_userCreateWithoutMediasInput, file_userUncheckedCreateWithoutMediasInput>
    connectOrCreate?: file_userCreateOrConnectWithoutMediasInput
    upsert?: file_userUpsertWithoutMediasInput
    connect?: file_userWhereUniqueInput
    update?: XOR<XOR<file_userUpdateToOneWithWhereWithoutMediasInput, file_userUpdateWithoutMediasInput>, file_userUncheckedUpdateWithoutMediasInput>
  }

  export type file_mediaUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<file_mediaCreateWithoutUsersInput, file_mediaUncheckedCreateWithoutUsersInput>
    connectOrCreate?: file_mediaCreateOrConnectWithoutUsersInput
    upsert?: file_mediaUpsertWithoutUsersInput
    connect?: file_mediaWhereUniqueInput
    update?: XOR<XOR<file_mediaUpdateToOneWithWhereWithoutUsersInput, file_mediaUpdateWithoutUsersInput>, file_mediaUncheckedUpdateWithoutUsersInput>
  }

  export type file_mediaCreateNestedOneWithoutBlocksInput = {
    create?: XOR<file_mediaCreateWithoutBlocksInput, file_mediaUncheckedCreateWithoutBlocksInput>
    connectOrCreate?: file_mediaCreateOrConnectWithoutBlocksInput
    connect?: file_mediaWhereUniqueInput
  }

  export type file_mediaUpdateOneRequiredWithoutBlocksNestedInput = {
    create?: XOR<file_mediaCreateWithoutBlocksInput, file_mediaUncheckedCreateWithoutBlocksInput>
    connectOrCreate?: file_mediaCreateOrConnectWithoutBlocksInput
    upsert?: file_mediaUpsertWithoutBlocksInput
    connect?: file_mediaWhereUniqueInput
    update?: XOR<XOR<file_mediaUpdateToOneWithWhereWithoutBlocksInput, file_mediaUpdateWithoutBlocksInput>, file_mediaUncheckedUpdateWithoutBlocksInput>
  }

  export type file_blockCreateNestedManyWithoutMediaInput = {
    create?: XOR<file_blockCreateWithoutMediaInput, file_blockUncheckedCreateWithoutMediaInput> | file_blockCreateWithoutMediaInput[] | file_blockUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: file_blockCreateOrConnectWithoutMediaInput | file_blockCreateOrConnectWithoutMediaInput[]
    createMany?: file_blockCreateManyMediaInputEnvelope
    connect?: file_blockWhereUniqueInput | file_blockWhereUniqueInput[]
  }

  export type file_user_on_mediaCreateNestedManyWithoutMediaInput = {
    create?: XOR<file_user_on_mediaCreateWithoutMediaInput, file_user_on_mediaUncheckedCreateWithoutMediaInput> | file_user_on_mediaCreateWithoutMediaInput[] | file_user_on_mediaUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: file_user_on_mediaCreateOrConnectWithoutMediaInput | file_user_on_mediaCreateOrConnectWithoutMediaInput[]
    createMany?: file_user_on_mediaCreateManyMediaInputEnvelope
    connect?: file_user_on_mediaWhereUniqueInput | file_user_on_mediaWhereUniqueInput[]
  }

  export type file_media_on_folderCreateNestedManyWithoutMediaInput = {
    create?: XOR<file_media_on_folderCreateWithoutMediaInput, file_media_on_folderUncheckedCreateWithoutMediaInput> | file_media_on_folderCreateWithoutMediaInput[] | file_media_on_folderUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: file_media_on_folderCreateOrConnectWithoutMediaInput | file_media_on_folderCreateOrConnectWithoutMediaInput[]
    createMany?: file_media_on_folderCreateManyMediaInputEnvelope
    connect?: file_media_on_folderWhereUniqueInput | file_media_on_folderWhereUniqueInput[]
  }

  export type file_blockUncheckedCreateNestedManyWithoutMediaInput = {
    create?: XOR<file_blockCreateWithoutMediaInput, file_blockUncheckedCreateWithoutMediaInput> | file_blockCreateWithoutMediaInput[] | file_blockUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: file_blockCreateOrConnectWithoutMediaInput | file_blockCreateOrConnectWithoutMediaInput[]
    createMany?: file_blockCreateManyMediaInputEnvelope
    connect?: file_blockWhereUniqueInput | file_blockWhereUniqueInput[]
  }

  export type file_user_on_mediaUncheckedCreateNestedManyWithoutMediaInput = {
    create?: XOR<file_user_on_mediaCreateWithoutMediaInput, file_user_on_mediaUncheckedCreateWithoutMediaInput> | file_user_on_mediaCreateWithoutMediaInput[] | file_user_on_mediaUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: file_user_on_mediaCreateOrConnectWithoutMediaInput | file_user_on_mediaCreateOrConnectWithoutMediaInput[]
    createMany?: file_user_on_mediaCreateManyMediaInputEnvelope
    connect?: file_user_on_mediaWhereUniqueInput | file_user_on_mediaWhereUniqueInput[]
  }

  export type file_media_on_folderUncheckedCreateNestedManyWithoutMediaInput = {
    create?: XOR<file_media_on_folderCreateWithoutMediaInput, file_media_on_folderUncheckedCreateWithoutMediaInput> | file_media_on_folderCreateWithoutMediaInput[] | file_media_on_folderUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: file_media_on_folderCreateOrConnectWithoutMediaInput | file_media_on_folderCreateOrConnectWithoutMediaInput[]
    createMany?: file_media_on_folderCreateManyMediaInputEnvelope
    connect?: file_media_on_folderWhereUniqueInput | file_media_on_folderWhereUniqueInput[]
  }

  export type Enumfile_typeFieldUpdateOperationsInput = {
    set?: $Enums.file_type
  }

  export type file_blockUpdateManyWithoutMediaNestedInput = {
    create?: XOR<file_blockCreateWithoutMediaInput, file_blockUncheckedCreateWithoutMediaInput> | file_blockCreateWithoutMediaInput[] | file_blockUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: file_blockCreateOrConnectWithoutMediaInput | file_blockCreateOrConnectWithoutMediaInput[]
    upsert?: file_blockUpsertWithWhereUniqueWithoutMediaInput | file_blockUpsertWithWhereUniqueWithoutMediaInput[]
    createMany?: file_blockCreateManyMediaInputEnvelope
    set?: file_blockWhereUniqueInput | file_blockWhereUniqueInput[]
    disconnect?: file_blockWhereUniqueInput | file_blockWhereUniqueInput[]
    delete?: file_blockWhereUniqueInput | file_blockWhereUniqueInput[]
    connect?: file_blockWhereUniqueInput | file_blockWhereUniqueInput[]
    update?: file_blockUpdateWithWhereUniqueWithoutMediaInput | file_blockUpdateWithWhereUniqueWithoutMediaInput[]
    updateMany?: file_blockUpdateManyWithWhereWithoutMediaInput | file_blockUpdateManyWithWhereWithoutMediaInput[]
    deleteMany?: file_blockScalarWhereInput | file_blockScalarWhereInput[]
  }

  export type file_user_on_mediaUpdateManyWithoutMediaNestedInput = {
    create?: XOR<file_user_on_mediaCreateWithoutMediaInput, file_user_on_mediaUncheckedCreateWithoutMediaInput> | file_user_on_mediaCreateWithoutMediaInput[] | file_user_on_mediaUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: file_user_on_mediaCreateOrConnectWithoutMediaInput | file_user_on_mediaCreateOrConnectWithoutMediaInput[]
    upsert?: file_user_on_mediaUpsertWithWhereUniqueWithoutMediaInput | file_user_on_mediaUpsertWithWhereUniqueWithoutMediaInput[]
    createMany?: file_user_on_mediaCreateManyMediaInputEnvelope
    set?: file_user_on_mediaWhereUniqueInput | file_user_on_mediaWhereUniqueInput[]
    disconnect?: file_user_on_mediaWhereUniqueInput | file_user_on_mediaWhereUniqueInput[]
    delete?: file_user_on_mediaWhereUniqueInput | file_user_on_mediaWhereUniqueInput[]
    connect?: file_user_on_mediaWhereUniqueInput | file_user_on_mediaWhereUniqueInput[]
    update?: file_user_on_mediaUpdateWithWhereUniqueWithoutMediaInput | file_user_on_mediaUpdateWithWhereUniqueWithoutMediaInput[]
    updateMany?: file_user_on_mediaUpdateManyWithWhereWithoutMediaInput | file_user_on_mediaUpdateManyWithWhereWithoutMediaInput[]
    deleteMany?: file_user_on_mediaScalarWhereInput | file_user_on_mediaScalarWhereInput[]
  }

  export type file_media_on_folderUpdateManyWithoutMediaNestedInput = {
    create?: XOR<file_media_on_folderCreateWithoutMediaInput, file_media_on_folderUncheckedCreateWithoutMediaInput> | file_media_on_folderCreateWithoutMediaInput[] | file_media_on_folderUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: file_media_on_folderCreateOrConnectWithoutMediaInput | file_media_on_folderCreateOrConnectWithoutMediaInput[]
    upsert?: file_media_on_folderUpsertWithWhereUniqueWithoutMediaInput | file_media_on_folderUpsertWithWhereUniqueWithoutMediaInput[]
    createMany?: file_media_on_folderCreateManyMediaInputEnvelope
    set?: file_media_on_folderWhereUniqueInput | file_media_on_folderWhereUniqueInput[]
    disconnect?: file_media_on_folderWhereUniqueInput | file_media_on_folderWhereUniqueInput[]
    delete?: file_media_on_folderWhereUniqueInput | file_media_on_folderWhereUniqueInput[]
    connect?: file_media_on_folderWhereUniqueInput | file_media_on_folderWhereUniqueInput[]
    update?: file_media_on_folderUpdateWithWhereUniqueWithoutMediaInput | file_media_on_folderUpdateWithWhereUniqueWithoutMediaInput[]
    updateMany?: file_media_on_folderUpdateManyWithWhereWithoutMediaInput | file_media_on_folderUpdateManyWithWhereWithoutMediaInput[]
    deleteMany?: file_media_on_folderScalarWhereInput | file_media_on_folderScalarWhereInput[]
  }

  export type file_blockUncheckedUpdateManyWithoutMediaNestedInput = {
    create?: XOR<file_blockCreateWithoutMediaInput, file_blockUncheckedCreateWithoutMediaInput> | file_blockCreateWithoutMediaInput[] | file_blockUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: file_blockCreateOrConnectWithoutMediaInput | file_blockCreateOrConnectWithoutMediaInput[]
    upsert?: file_blockUpsertWithWhereUniqueWithoutMediaInput | file_blockUpsertWithWhereUniqueWithoutMediaInput[]
    createMany?: file_blockCreateManyMediaInputEnvelope
    set?: file_blockWhereUniqueInput | file_blockWhereUniqueInput[]
    disconnect?: file_blockWhereUniqueInput | file_blockWhereUniqueInput[]
    delete?: file_blockWhereUniqueInput | file_blockWhereUniqueInput[]
    connect?: file_blockWhereUniqueInput | file_blockWhereUniqueInput[]
    update?: file_blockUpdateWithWhereUniqueWithoutMediaInput | file_blockUpdateWithWhereUniqueWithoutMediaInput[]
    updateMany?: file_blockUpdateManyWithWhereWithoutMediaInput | file_blockUpdateManyWithWhereWithoutMediaInput[]
    deleteMany?: file_blockScalarWhereInput | file_blockScalarWhereInput[]
  }

  export type file_user_on_mediaUncheckedUpdateManyWithoutMediaNestedInput = {
    create?: XOR<file_user_on_mediaCreateWithoutMediaInput, file_user_on_mediaUncheckedCreateWithoutMediaInput> | file_user_on_mediaCreateWithoutMediaInput[] | file_user_on_mediaUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: file_user_on_mediaCreateOrConnectWithoutMediaInput | file_user_on_mediaCreateOrConnectWithoutMediaInput[]
    upsert?: file_user_on_mediaUpsertWithWhereUniqueWithoutMediaInput | file_user_on_mediaUpsertWithWhereUniqueWithoutMediaInput[]
    createMany?: file_user_on_mediaCreateManyMediaInputEnvelope
    set?: file_user_on_mediaWhereUniqueInput | file_user_on_mediaWhereUniqueInput[]
    disconnect?: file_user_on_mediaWhereUniqueInput | file_user_on_mediaWhereUniqueInput[]
    delete?: file_user_on_mediaWhereUniqueInput | file_user_on_mediaWhereUniqueInput[]
    connect?: file_user_on_mediaWhereUniqueInput | file_user_on_mediaWhereUniqueInput[]
    update?: file_user_on_mediaUpdateWithWhereUniqueWithoutMediaInput | file_user_on_mediaUpdateWithWhereUniqueWithoutMediaInput[]
    updateMany?: file_user_on_mediaUpdateManyWithWhereWithoutMediaInput | file_user_on_mediaUpdateManyWithWhereWithoutMediaInput[]
    deleteMany?: file_user_on_mediaScalarWhereInput | file_user_on_mediaScalarWhereInput[]
  }

  export type file_media_on_folderUncheckedUpdateManyWithoutMediaNestedInput = {
    create?: XOR<file_media_on_folderCreateWithoutMediaInput, file_media_on_folderUncheckedCreateWithoutMediaInput> | file_media_on_folderCreateWithoutMediaInput[] | file_media_on_folderUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: file_media_on_folderCreateOrConnectWithoutMediaInput | file_media_on_folderCreateOrConnectWithoutMediaInput[]
    upsert?: file_media_on_folderUpsertWithWhereUniqueWithoutMediaInput | file_media_on_folderUpsertWithWhereUniqueWithoutMediaInput[]
    createMany?: file_media_on_folderCreateManyMediaInputEnvelope
    set?: file_media_on_folderWhereUniqueInput | file_media_on_folderWhereUniqueInput[]
    disconnect?: file_media_on_folderWhereUniqueInput | file_media_on_folderWhereUniqueInput[]
    delete?: file_media_on_folderWhereUniqueInput | file_media_on_folderWhereUniqueInput[]
    connect?: file_media_on_folderWhereUniqueInput | file_media_on_folderWhereUniqueInput[]
    update?: file_media_on_folderUpdateWithWhereUniqueWithoutMediaInput | file_media_on_folderUpdateWithWhereUniqueWithoutMediaInput[]
    updateMany?: file_media_on_folderUpdateManyWithWhereWithoutMediaInput | file_media_on_folderUpdateManyWithWhereWithoutMediaInput[]
    deleteMany?: file_media_on_folderScalarWhereInput | file_media_on_folderScalarWhereInput[]
  }

  export type file_mediaCreateNestedOneWithoutFoldersInput = {
    create?: XOR<file_mediaCreateWithoutFoldersInput, file_mediaUncheckedCreateWithoutFoldersInput>
    connectOrCreate?: file_mediaCreateOrConnectWithoutFoldersInput
    connect?: file_mediaWhereUniqueInput
  }

  export type file_folderCreateNestedOneWithoutMediasInput = {
    create?: XOR<file_folderCreateWithoutMediasInput, file_folderUncheckedCreateWithoutMediasInput>
    connectOrCreate?: file_folderCreateOrConnectWithoutMediasInput
    connect?: file_folderWhereUniqueInput
  }

  export type file_mediaUpdateOneRequiredWithoutFoldersNestedInput = {
    create?: XOR<file_mediaCreateWithoutFoldersInput, file_mediaUncheckedCreateWithoutFoldersInput>
    connectOrCreate?: file_mediaCreateOrConnectWithoutFoldersInput
    upsert?: file_mediaUpsertWithoutFoldersInput
    connect?: file_mediaWhereUniqueInput
    update?: XOR<XOR<file_mediaUpdateToOneWithWhereWithoutFoldersInput, file_mediaUpdateWithoutFoldersInput>, file_mediaUncheckedUpdateWithoutFoldersInput>
  }

  export type file_folderUpdateOneRequiredWithoutMediasNestedInput = {
    create?: XOR<file_folderCreateWithoutMediasInput, file_folderUncheckedCreateWithoutMediasInput>
    connectOrCreate?: file_folderCreateOrConnectWithoutMediasInput
    upsert?: file_folderUpsertWithoutMediasInput
    connect?: file_folderWhereUniqueInput
    update?: XOR<XOR<file_folderUpdateToOneWithWhereWithoutMediasInput, file_folderUpdateWithoutMediasInput>, file_folderUncheckedUpdateWithoutMediasInput>
  }

  export type file_userCreateNestedOneWithoutFoldersInput = {
    create?: XOR<file_userCreateWithoutFoldersInput, file_userUncheckedCreateWithoutFoldersInput>
    connectOrCreate?: file_userCreateOrConnectWithoutFoldersInput
    connect?: file_userWhereUniqueInput
  }

  export type file_folderCreateNestedOneWithoutChildrenInput = {
    create?: XOR<file_folderCreateWithoutChildrenInput, file_folderUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: file_folderCreateOrConnectWithoutChildrenInput
    connect?: file_folderWhereUniqueInput
  }

  export type file_folderCreateNestedManyWithoutParentInput = {
    create?: XOR<file_folderCreateWithoutParentInput, file_folderUncheckedCreateWithoutParentInput> | file_folderCreateWithoutParentInput[] | file_folderUncheckedCreateWithoutParentInput[]
    connectOrCreate?: file_folderCreateOrConnectWithoutParentInput | file_folderCreateOrConnectWithoutParentInput[]
    createMany?: file_folderCreateManyParentInputEnvelope
    connect?: file_folderWhereUniqueInput | file_folderWhereUniqueInput[]
  }

  export type file_media_on_folderCreateNestedManyWithoutFolderInput = {
    create?: XOR<file_media_on_folderCreateWithoutFolderInput, file_media_on_folderUncheckedCreateWithoutFolderInput> | file_media_on_folderCreateWithoutFolderInput[] | file_media_on_folderUncheckedCreateWithoutFolderInput[]
    connectOrCreate?: file_media_on_folderCreateOrConnectWithoutFolderInput | file_media_on_folderCreateOrConnectWithoutFolderInput[]
    createMany?: file_media_on_folderCreateManyFolderInputEnvelope
    connect?: file_media_on_folderWhereUniqueInput | file_media_on_folderWhereUniqueInput[]
  }

  export type file_folderUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<file_folderCreateWithoutParentInput, file_folderUncheckedCreateWithoutParentInput> | file_folderCreateWithoutParentInput[] | file_folderUncheckedCreateWithoutParentInput[]
    connectOrCreate?: file_folderCreateOrConnectWithoutParentInput | file_folderCreateOrConnectWithoutParentInput[]
    createMany?: file_folderCreateManyParentInputEnvelope
    connect?: file_folderWhereUniqueInput | file_folderWhereUniqueInput[]
  }

  export type file_media_on_folderUncheckedCreateNestedManyWithoutFolderInput = {
    create?: XOR<file_media_on_folderCreateWithoutFolderInput, file_media_on_folderUncheckedCreateWithoutFolderInput> | file_media_on_folderCreateWithoutFolderInput[] | file_media_on_folderUncheckedCreateWithoutFolderInput[]
    connectOrCreate?: file_media_on_folderCreateOrConnectWithoutFolderInput | file_media_on_folderCreateOrConnectWithoutFolderInput[]
    createMany?: file_media_on_folderCreateManyFolderInputEnvelope
    connect?: file_media_on_folderWhereUniqueInput | file_media_on_folderWhereUniqueInput[]
  }

  export type file_userUpdateOneRequiredWithoutFoldersNestedInput = {
    create?: XOR<file_userCreateWithoutFoldersInput, file_userUncheckedCreateWithoutFoldersInput>
    connectOrCreate?: file_userCreateOrConnectWithoutFoldersInput
    upsert?: file_userUpsertWithoutFoldersInput
    connect?: file_userWhereUniqueInput
    update?: XOR<XOR<file_userUpdateToOneWithWhereWithoutFoldersInput, file_userUpdateWithoutFoldersInput>, file_userUncheckedUpdateWithoutFoldersInput>
  }

  export type file_folderUpdateOneWithoutChildrenNestedInput = {
    create?: XOR<file_folderCreateWithoutChildrenInput, file_folderUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: file_folderCreateOrConnectWithoutChildrenInput
    upsert?: file_folderUpsertWithoutChildrenInput
    disconnect?: file_folderWhereInput | boolean
    delete?: file_folderWhereInput | boolean
    connect?: file_folderWhereUniqueInput
    update?: XOR<XOR<file_folderUpdateToOneWithWhereWithoutChildrenInput, file_folderUpdateWithoutChildrenInput>, file_folderUncheckedUpdateWithoutChildrenInput>
  }

  export type file_folderUpdateManyWithoutParentNestedInput = {
    create?: XOR<file_folderCreateWithoutParentInput, file_folderUncheckedCreateWithoutParentInput> | file_folderCreateWithoutParentInput[] | file_folderUncheckedCreateWithoutParentInput[]
    connectOrCreate?: file_folderCreateOrConnectWithoutParentInput | file_folderCreateOrConnectWithoutParentInput[]
    upsert?: file_folderUpsertWithWhereUniqueWithoutParentInput | file_folderUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: file_folderCreateManyParentInputEnvelope
    set?: file_folderWhereUniqueInput | file_folderWhereUniqueInput[]
    disconnect?: file_folderWhereUniqueInput | file_folderWhereUniqueInput[]
    delete?: file_folderWhereUniqueInput | file_folderWhereUniqueInput[]
    connect?: file_folderWhereUniqueInput | file_folderWhereUniqueInput[]
    update?: file_folderUpdateWithWhereUniqueWithoutParentInput | file_folderUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: file_folderUpdateManyWithWhereWithoutParentInput | file_folderUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: file_folderScalarWhereInput | file_folderScalarWhereInput[]
  }

  export type file_media_on_folderUpdateManyWithoutFolderNestedInput = {
    create?: XOR<file_media_on_folderCreateWithoutFolderInput, file_media_on_folderUncheckedCreateWithoutFolderInput> | file_media_on_folderCreateWithoutFolderInput[] | file_media_on_folderUncheckedCreateWithoutFolderInput[]
    connectOrCreate?: file_media_on_folderCreateOrConnectWithoutFolderInput | file_media_on_folderCreateOrConnectWithoutFolderInput[]
    upsert?: file_media_on_folderUpsertWithWhereUniqueWithoutFolderInput | file_media_on_folderUpsertWithWhereUniqueWithoutFolderInput[]
    createMany?: file_media_on_folderCreateManyFolderInputEnvelope
    set?: file_media_on_folderWhereUniqueInput | file_media_on_folderWhereUniqueInput[]
    disconnect?: file_media_on_folderWhereUniqueInput | file_media_on_folderWhereUniqueInput[]
    delete?: file_media_on_folderWhereUniqueInput | file_media_on_folderWhereUniqueInput[]
    connect?: file_media_on_folderWhereUniqueInput | file_media_on_folderWhereUniqueInput[]
    update?: file_media_on_folderUpdateWithWhereUniqueWithoutFolderInput | file_media_on_folderUpdateWithWhereUniqueWithoutFolderInput[]
    updateMany?: file_media_on_folderUpdateManyWithWhereWithoutFolderInput | file_media_on_folderUpdateManyWithWhereWithoutFolderInput[]
    deleteMany?: file_media_on_folderScalarWhereInput | file_media_on_folderScalarWhereInput[]
  }

  export type file_folderUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<file_folderCreateWithoutParentInput, file_folderUncheckedCreateWithoutParentInput> | file_folderCreateWithoutParentInput[] | file_folderUncheckedCreateWithoutParentInput[]
    connectOrCreate?: file_folderCreateOrConnectWithoutParentInput | file_folderCreateOrConnectWithoutParentInput[]
    upsert?: file_folderUpsertWithWhereUniqueWithoutParentInput | file_folderUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: file_folderCreateManyParentInputEnvelope
    set?: file_folderWhereUniqueInput | file_folderWhereUniqueInput[]
    disconnect?: file_folderWhereUniqueInput | file_folderWhereUniqueInput[]
    delete?: file_folderWhereUniqueInput | file_folderWhereUniqueInput[]
    connect?: file_folderWhereUniqueInput | file_folderWhereUniqueInput[]
    update?: file_folderUpdateWithWhereUniqueWithoutParentInput | file_folderUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: file_folderUpdateManyWithWhereWithoutParentInput | file_folderUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: file_folderScalarWhereInput | file_folderScalarWhereInput[]
  }

  export type file_media_on_folderUncheckedUpdateManyWithoutFolderNestedInput = {
    create?: XOR<file_media_on_folderCreateWithoutFolderInput, file_media_on_folderUncheckedCreateWithoutFolderInput> | file_media_on_folderCreateWithoutFolderInput[] | file_media_on_folderUncheckedCreateWithoutFolderInput[]
    connectOrCreate?: file_media_on_folderCreateOrConnectWithoutFolderInput | file_media_on_folderCreateOrConnectWithoutFolderInput[]
    upsert?: file_media_on_folderUpsertWithWhereUniqueWithoutFolderInput | file_media_on_folderUpsertWithWhereUniqueWithoutFolderInput[]
    createMany?: file_media_on_folderCreateManyFolderInputEnvelope
    set?: file_media_on_folderWhereUniqueInput | file_media_on_folderWhereUniqueInput[]
    disconnect?: file_media_on_folderWhereUniqueInput | file_media_on_folderWhereUniqueInput[]
    delete?: file_media_on_folderWhereUniqueInput | file_media_on_folderWhereUniqueInput[]
    connect?: file_media_on_folderWhereUniqueInput | file_media_on_folderWhereUniqueInput[]
    update?: file_media_on_folderUpdateWithWhereUniqueWithoutFolderInput | file_media_on_folderUpdateWithWhereUniqueWithoutFolderInput[]
    updateMany?: file_media_on_folderUpdateManyWithWhereWithoutFolderInput | file_media_on_folderUpdateManyWithWhereWithoutFolderInput[]
    deleteMany?: file_media_on_folderScalarWhereInput | file_media_on_folderScalarWhereInput[]
  }

  export type book_borrowedCreateNestedManyWithoutUserInput = {
    create?: XOR<book_borrowedCreateWithoutUserInput, book_borrowedUncheckedCreateWithoutUserInput> | book_borrowedCreateWithoutUserInput[] | book_borrowedUncheckedCreateWithoutUserInput[]
    connectOrCreate?: book_borrowedCreateOrConnectWithoutUserInput | book_borrowedCreateOrConnectWithoutUserInput[]
    createMany?: book_borrowedCreateManyUserInputEnvelope
    connect?: book_borrowedWhereUniqueInput | book_borrowedWhereUniqueInput[]
  }

  export type book_borrow_historyCreateNestedManyWithoutUserInput = {
    create?: XOR<book_borrow_historyCreateWithoutUserInput, book_borrow_historyUncheckedCreateWithoutUserInput> | book_borrow_historyCreateWithoutUserInput[] | book_borrow_historyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: book_borrow_historyCreateOrConnectWithoutUserInput | book_borrow_historyCreateOrConnectWithoutUserInput[]
    createMany?: book_borrow_historyCreateManyUserInputEnvelope
    connect?: book_borrow_historyWhereUniqueInput | book_borrow_historyWhereUniqueInput[]
  }

  export type book_ratingCreateNestedManyWithoutUserInput = {
    create?: XOR<book_ratingCreateWithoutUserInput, book_ratingUncheckedCreateWithoutUserInput> | book_ratingCreateWithoutUserInput[] | book_ratingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: book_ratingCreateOrConnectWithoutUserInput | book_ratingCreateOrConnectWithoutUserInput[]
    createMany?: book_ratingCreateManyUserInputEnvelope
    connect?: book_ratingWhereUniqueInput | book_ratingWhereUniqueInput[]
  }

  export type book_borrowedUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<book_borrowedCreateWithoutUserInput, book_borrowedUncheckedCreateWithoutUserInput> | book_borrowedCreateWithoutUserInput[] | book_borrowedUncheckedCreateWithoutUserInput[]
    connectOrCreate?: book_borrowedCreateOrConnectWithoutUserInput | book_borrowedCreateOrConnectWithoutUserInput[]
    createMany?: book_borrowedCreateManyUserInputEnvelope
    connect?: book_borrowedWhereUniqueInput | book_borrowedWhereUniqueInput[]
  }

  export type book_borrow_historyUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<book_borrow_historyCreateWithoutUserInput, book_borrow_historyUncheckedCreateWithoutUserInput> | book_borrow_historyCreateWithoutUserInput[] | book_borrow_historyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: book_borrow_historyCreateOrConnectWithoutUserInput | book_borrow_historyCreateOrConnectWithoutUserInput[]
    createMany?: book_borrow_historyCreateManyUserInputEnvelope
    connect?: book_borrow_historyWhereUniqueInput | book_borrow_historyWhereUniqueInput[]
  }

  export type book_ratingUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<book_ratingCreateWithoutUserInput, book_ratingUncheckedCreateWithoutUserInput> | book_ratingCreateWithoutUserInput[] | book_ratingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: book_ratingCreateOrConnectWithoutUserInput | book_ratingCreateOrConnectWithoutUserInput[]
    createMany?: book_ratingCreateManyUserInputEnvelope
    connect?: book_ratingWhereUniqueInput | book_ratingWhereUniqueInput[]
  }

  export type Enumbook_roleFieldUpdateOperationsInput = {
    set?: $Enums.book_role
  }

  export type book_borrowedUpdateManyWithoutUserNestedInput = {
    create?: XOR<book_borrowedCreateWithoutUserInput, book_borrowedUncheckedCreateWithoutUserInput> | book_borrowedCreateWithoutUserInput[] | book_borrowedUncheckedCreateWithoutUserInput[]
    connectOrCreate?: book_borrowedCreateOrConnectWithoutUserInput | book_borrowedCreateOrConnectWithoutUserInput[]
    upsert?: book_borrowedUpsertWithWhereUniqueWithoutUserInput | book_borrowedUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: book_borrowedCreateManyUserInputEnvelope
    set?: book_borrowedWhereUniqueInput | book_borrowedWhereUniqueInput[]
    disconnect?: book_borrowedWhereUniqueInput | book_borrowedWhereUniqueInput[]
    delete?: book_borrowedWhereUniqueInput | book_borrowedWhereUniqueInput[]
    connect?: book_borrowedWhereUniqueInput | book_borrowedWhereUniqueInput[]
    update?: book_borrowedUpdateWithWhereUniqueWithoutUserInput | book_borrowedUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: book_borrowedUpdateManyWithWhereWithoutUserInput | book_borrowedUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: book_borrowedScalarWhereInput | book_borrowedScalarWhereInput[]
  }

  export type book_borrow_historyUpdateManyWithoutUserNestedInput = {
    create?: XOR<book_borrow_historyCreateWithoutUserInput, book_borrow_historyUncheckedCreateWithoutUserInput> | book_borrow_historyCreateWithoutUserInput[] | book_borrow_historyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: book_borrow_historyCreateOrConnectWithoutUserInput | book_borrow_historyCreateOrConnectWithoutUserInput[]
    upsert?: book_borrow_historyUpsertWithWhereUniqueWithoutUserInput | book_borrow_historyUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: book_borrow_historyCreateManyUserInputEnvelope
    set?: book_borrow_historyWhereUniqueInput | book_borrow_historyWhereUniqueInput[]
    disconnect?: book_borrow_historyWhereUniqueInput | book_borrow_historyWhereUniqueInput[]
    delete?: book_borrow_historyWhereUniqueInput | book_borrow_historyWhereUniqueInput[]
    connect?: book_borrow_historyWhereUniqueInput | book_borrow_historyWhereUniqueInput[]
    update?: book_borrow_historyUpdateWithWhereUniqueWithoutUserInput | book_borrow_historyUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: book_borrow_historyUpdateManyWithWhereWithoutUserInput | book_borrow_historyUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: book_borrow_historyScalarWhereInput | book_borrow_historyScalarWhereInput[]
  }

  export type book_ratingUpdateManyWithoutUserNestedInput = {
    create?: XOR<book_ratingCreateWithoutUserInput, book_ratingUncheckedCreateWithoutUserInput> | book_ratingCreateWithoutUserInput[] | book_ratingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: book_ratingCreateOrConnectWithoutUserInput | book_ratingCreateOrConnectWithoutUserInput[]
    upsert?: book_ratingUpsertWithWhereUniqueWithoutUserInput | book_ratingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: book_ratingCreateManyUserInputEnvelope
    set?: book_ratingWhereUniqueInput | book_ratingWhereUniqueInput[]
    disconnect?: book_ratingWhereUniqueInput | book_ratingWhereUniqueInput[]
    delete?: book_ratingWhereUniqueInput | book_ratingWhereUniqueInput[]
    connect?: book_ratingWhereUniqueInput | book_ratingWhereUniqueInput[]
    update?: book_ratingUpdateWithWhereUniqueWithoutUserInput | book_ratingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: book_ratingUpdateManyWithWhereWithoutUserInput | book_ratingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: book_ratingScalarWhereInput | book_ratingScalarWhereInput[]
  }

  export type book_borrowedUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<book_borrowedCreateWithoutUserInput, book_borrowedUncheckedCreateWithoutUserInput> | book_borrowedCreateWithoutUserInput[] | book_borrowedUncheckedCreateWithoutUserInput[]
    connectOrCreate?: book_borrowedCreateOrConnectWithoutUserInput | book_borrowedCreateOrConnectWithoutUserInput[]
    upsert?: book_borrowedUpsertWithWhereUniqueWithoutUserInput | book_borrowedUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: book_borrowedCreateManyUserInputEnvelope
    set?: book_borrowedWhereUniqueInput | book_borrowedWhereUniqueInput[]
    disconnect?: book_borrowedWhereUniqueInput | book_borrowedWhereUniqueInput[]
    delete?: book_borrowedWhereUniqueInput | book_borrowedWhereUniqueInput[]
    connect?: book_borrowedWhereUniqueInput | book_borrowedWhereUniqueInput[]
    update?: book_borrowedUpdateWithWhereUniqueWithoutUserInput | book_borrowedUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: book_borrowedUpdateManyWithWhereWithoutUserInput | book_borrowedUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: book_borrowedScalarWhereInput | book_borrowedScalarWhereInput[]
  }

  export type book_borrow_historyUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<book_borrow_historyCreateWithoutUserInput, book_borrow_historyUncheckedCreateWithoutUserInput> | book_borrow_historyCreateWithoutUserInput[] | book_borrow_historyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: book_borrow_historyCreateOrConnectWithoutUserInput | book_borrow_historyCreateOrConnectWithoutUserInput[]
    upsert?: book_borrow_historyUpsertWithWhereUniqueWithoutUserInput | book_borrow_historyUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: book_borrow_historyCreateManyUserInputEnvelope
    set?: book_borrow_historyWhereUniqueInput | book_borrow_historyWhereUniqueInput[]
    disconnect?: book_borrow_historyWhereUniqueInput | book_borrow_historyWhereUniqueInput[]
    delete?: book_borrow_historyWhereUniqueInput | book_borrow_historyWhereUniqueInput[]
    connect?: book_borrow_historyWhereUniqueInput | book_borrow_historyWhereUniqueInput[]
    update?: book_borrow_historyUpdateWithWhereUniqueWithoutUserInput | book_borrow_historyUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: book_borrow_historyUpdateManyWithWhereWithoutUserInput | book_borrow_historyUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: book_borrow_historyScalarWhereInput | book_borrow_historyScalarWhereInput[]
  }

  export type book_ratingUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<book_ratingCreateWithoutUserInput, book_ratingUncheckedCreateWithoutUserInput> | book_ratingCreateWithoutUserInput[] | book_ratingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: book_ratingCreateOrConnectWithoutUserInput | book_ratingCreateOrConnectWithoutUserInput[]
    upsert?: book_ratingUpsertWithWhereUniqueWithoutUserInput | book_ratingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: book_ratingCreateManyUserInputEnvelope
    set?: book_ratingWhereUniqueInput | book_ratingWhereUniqueInput[]
    disconnect?: book_ratingWhereUniqueInput | book_ratingWhereUniqueInput[]
    delete?: book_ratingWhereUniqueInput | book_ratingWhereUniqueInput[]
    connect?: book_ratingWhereUniqueInput | book_ratingWhereUniqueInput[]
    update?: book_ratingUpdateWithWhereUniqueWithoutUserInput | book_ratingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: book_ratingUpdateManyWithWhereWithoutUserInput | book_ratingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: book_ratingScalarWhereInput | book_ratingScalarWhereInput[]
  }

  export type book_categoryCreateNestedOneWithoutBooksInput = {
    create?: XOR<book_categoryCreateWithoutBooksInput, book_categoryUncheckedCreateWithoutBooksInput>
    connectOrCreate?: book_categoryCreateOrConnectWithoutBooksInput
    connect?: book_categoryWhereUniqueInput
  }

  export type book_borrowedCreateNestedManyWithoutBookInput = {
    create?: XOR<book_borrowedCreateWithoutBookInput, book_borrowedUncheckedCreateWithoutBookInput> | book_borrowedCreateWithoutBookInput[] | book_borrowedUncheckedCreateWithoutBookInput[]
    connectOrCreate?: book_borrowedCreateOrConnectWithoutBookInput | book_borrowedCreateOrConnectWithoutBookInput[]
    createMany?: book_borrowedCreateManyBookInputEnvelope
    connect?: book_borrowedWhereUniqueInput | book_borrowedWhereUniqueInput[]
  }

  export type book_borrow_historyCreateNestedManyWithoutBookInput = {
    create?: XOR<book_borrow_historyCreateWithoutBookInput, book_borrow_historyUncheckedCreateWithoutBookInput> | book_borrow_historyCreateWithoutBookInput[] | book_borrow_historyUncheckedCreateWithoutBookInput[]
    connectOrCreate?: book_borrow_historyCreateOrConnectWithoutBookInput | book_borrow_historyCreateOrConnectWithoutBookInput[]
    createMany?: book_borrow_historyCreateManyBookInputEnvelope
    connect?: book_borrow_historyWhereUniqueInput | book_borrow_historyWhereUniqueInput[]
  }

  export type book_ratingCreateNestedManyWithoutBookInput = {
    create?: XOR<book_ratingCreateWithoutBookInput, book_ratingUncheckedCreateWithoutBookInput> | book_ratingCreateWithoutBookInput[] | book_ratingUncheckedCreateWithoutBookInput[]
    connectOrCreate?: book_ratingCreateOrConnectWithoutBookInput | book_ratingCreateOrConnectWithoutBookInput[]
    createMany?: book_ratingCreateManyBookInputEnvelope
    connect?: book_ratingWhereUniqueInput | book_ratingWhereUniqueInput[]
  }

  export type book_borrowedUncheckedCreateNestedManyWithoutBookInput = {
    create?: XOR<book_borrowedCreateWithoutBookInput, book_borrowedUncheckedCreateWithoutBookInput> | book_borrowedCreateWithoutBookInput[] | book_borrowedUncheckedCreateWithoutBookInput[]
    connectOrCreate?: book_borrowedCreateOrConnectWithoutBookInput | book_borrowedCreateOrConnectWithoutBookInput[]
    createMany?: book_borrowedCreateManyBookInputEnvelope
    connect?: book_borrowedWhereUniqueInput | book_borrowedWhereUniqueInput[]
  }

  export type book_borrow_historyUncheckedCreateNestedManyWithoutBookInput = {
    create?: XOR<book_borrow_historyCreateWithoutBookInput, book_borrow_historyUncheckedCreateWithoutBookInput> | book_borrow_historyCreateWithoutBookInput[] | book_borrow_historyUncheckedCreateWithoutBookInput[]
    connectOrCreate?: book_borrow_historyCreateOrConnectWithoutBookInput | book_borrow_historyCreateOrConnectWithoutBookInput[]
    createMany?: book_borrow_historyCreateManyBookInputEnvelope
    connect?: book_borrow_historyWhereUniqueInput | book_borrow_historyWhereUniqueInput[]
  }

  export type book_ratingUncheckedCreateNestedManyWithoutBookInput = {
    create?: XOR<book_ratingCreateWithoutBookInput, book_ratingUncheckedCreateWithoutBookInput> | book_ratingCreateWithoutBookInput[] | book_ratingUncheckedCreateWithoutBookInput[]
    connectOrCreate?: book_ratingCreateOrConnectWithoutBookInput | book_ratingCreateOrConnectWithoutBookInput[]
    createMany?: book_ratingCreateManyBookInputEnvelope
    connect?: book_ratingWhereUniqueInput | book_ratingWhereUniqueInput[]
  }

  export type book_categoryUpdateOneRequiredWithoutBooksNestedInput = {
    create?: XOR<book_categoryCreateWithoutBooksInput, book_categoryUncheckedCreateWithoutBooksInput>
    connectOrCreate?: book_categoryCreateOrConnectWithoutBooksInput
    upsert?: book_categoryUpsertWithoutBooksInput
    connect?: book_categoryWhereUniqueInput
    update?: XOR<XOR<book_categoryUpdateToOneWithWhereWithoutBooksInput, book_categoryUpdateWithoutBooksInput>, book_categoryUncheckedUpdateWithoutBooksInput>
  }

  export type book_borrowedUpdateManyWithoutBookNestedInput = {
    create?: XOR<book_borrowedCreateWithoutBookInput, book_borrowedUncheckedCreateWithoutBookInput> | book_borrowedCreateWithoutBookInput[] | book_borrowedUncheckedCreateWithoutBookInput[]
    connectOrCreate?: book_borrowedCreateOrConnectWithoutBookInput | book_borrowedCreateOrConnectWithoutBookInput[]
    upsert?: book_borrowedUpsertWithWhereUniqueWithoutBookInput | book_borrowedUpsertWithWhereUniqueWithoutBookInput[]
    createMany?: book_borrowedCreateManyBookInputEnvelope
    set?: book_borrowedWhereUniqueInput | book_borrowedWhereUniqueInput[]
    disconnect?: book_borrowedWhereUniqueInput | book_borrowedWhereUniqueInput[]
    delete?: book_borrowedWhereUniqueInput | book_borrowedWhereUniqueInput[]
    connect?: book_borrowedWhereUniqueInput | book_borrowedWhereUniqueInput[]
    update?: book_borrowedUpdateWithWhereUniqueWithoutBookInput | book_borrowedUpdateWithWhereUniqueWithoutBookInput[]
    updateMany?: book_borrowedUpdateManyWithWhereWithoutBookInput | book_borrowedUpdateManyWithWhereWithoutBookInput[]
    deleteMany?: book_borrowedScalarWhereInput | book_borrowedScalarWhereInput[]
  }

  export type book_borrow_historyUpdateManyWithoutBookNestedInput = {
    create?: XOR<book_borrow_historyCreateWithoutBookInput, book_borrow_historyUncheckedCreateWithoutBookInput> | book_borrow_historyCreateWithoutBookInput[] | book_borrow_historyUncheckedCreateWithoutBookInput[]
    connectOrCreate?: book_borrow_historyCreateOrConnectWithoutBookInput | book_borrow_historyCreateOrConnectWithoutBookInput[]
    upsert?: book_borrow_historyUpsertWithWhereUniqueWithoutBookInput | book_borrow_historyUpsertWithWhereUniqueWithoutBookInput[]
    createMany?: book_borrow_historyCreateManyBookInputEnvelope
    set?: book_borrow_historyWhereUniqueInput | book_borrow_historyWhereUniqueInput[]
    disconnect?: book_borrow_historyWhereUniqueInput | book_borrow_historyWhereUniqueInput[]
    delete?: book_borrow_historyWhereUniqueInput | book_borrow_historyWhereUniqueInput[]
    connect?: book_borrow_historyWhereUniqueInput | book_borrow_historyWhereUniqueInput[]
    update?: book_borrow_historyUpdateWithWhereUniqueWithoutBookInput | book_borrow_historyUpdateWithWhereUniqueWithoutBookInput[]
    updateMany?: book_borrow_historyUpdateManyWithWhereWithoutBookInput | book_borrow_historyUpdateManyWithWhereWithoutBookInput[]
    deleteMany?: book_borrow_historyScalarWhereInput | book_borrow_historyScalarWhereInput[]
  }

  export type book_ratingUpdateManyWithoutBookNestedInput = {
    create?: XOR<book_ratingCreateWithoutBookInput, book_ratingUncheckedCreateWithoutBookInput> | book_ratingCreateWithoutBookInput[] | book_ratingUncheckedCreateWithoutBookInput[]
    connectOrCreate?: book_ratingCreateOrConnectWithoutBookInput | book_ratingCreateOrConnectWithoutBookInput[]
    upsert?: book_ratingUpsertWithWhereUniqueWithoutBookInput | book_ratingUpsertWithWhereUniqueWithoutBookInput[]
    createMany?: book_ratingCreateManyBookInputEnvelope
    set?: book_ratingWhereUniqueInput | book_ratingWhereUniqueInput[]
    disconnect?: book_ratingWhereUniqueInput | book_ratingWhereUniqueInput[]
    delete?: book_ratingWhereUniqueInput | book_ratingWhereUniqueInput[]
    connect?: book_ratingWhereUniqueInput | book_ratingWhereUniqueInput[]
    update?: book_ratingUpdateWithWhereUniqueWithoutBookInput | book_ratingUpdateWithWhereUniqueWithoutBookInput[]
    updateMany?: book_ratingUpdateManyWithWhereWithoutBookInput | book_ratingUpdateManyWithWhereWithoutBookInput[]
    deleteMany?: book_ratingScalarWhereInput | book_ratingScalarWhereInput[]
  }

  export type book_borrowedUncheckedUpdateManyWithoutBookNestedInput = {
    create?: XOR<book_borrowedCreateWithoutBookInput, book_borrowedUncheckedCreateWithoutBookInput> | book_borrowedCreateWithoutBookInput[] | book_borrowedUncheckedCreateWithoutBookInput[]
    connectOrCreate?: book_borrowedCreateOrConnectWithoutBookInput | book_borrowedCreateOrConnectWithoutBookInput[]
    upsert?: book_borrowedUpsertWithWhereUniqueWithoutBookInput | book_borrowedUpsertWithWhereUniqueWithoutBookInput[]
    createMany?: book_borrowedCreateManyBookInputEnvelope
    set?: book_borrowedWhereUniqueInput | book_borrowedWhereUniqueInput[]
    disconnect?: book_borrowedWhereUniqueInput | book_borrowedWhereUniqueInput[]
    delete?: book_borrowedWhereUniqueInput | book_borrowedWhereUniqueInput[]
    connect?: book_borrowedWhereUniqueInput | book_borrowedWhereUniqueInput[]
    update?: book_borrowedUpdateWithWhereUniqueWithoutBookInput | book_borrowedUpdateWithWhereUniqueWithoutBookInput[]
    updateMany?: book_borrowedUpdateManyWithWhereWithoutBookInput | book_borrowedUpdateManyWithWhereWithoutBookInput[]
    deleteMany?: book_borrowedScalarWhereInput | book_borrowedScalarWhereInput[]
  }

  export type book_borrow_historyUncheckedUpdateManyWithoutBookNestedInput = {
    create?: XOR<book_borrow_historyCreateWithoutBookInput, book_borrow_historyUncheckedCreateWithoutBookInput> | book_borrow_historyCreateWithoutBookInput[] | book_borrow_historyUncheckedCreateWithoutBookInput[]
    connectOrCreate?: book_borrow_historyCreateOrConnectWithoutBookInput | book_borrow_historyCreateOrConnectWithoutBookInput[]
    upsert?: book_borrow_historyUpsertWithWhereUniqueWithoutBookInput | book_borrow_historyUpsertWithWhereUniqueWithoutBookInput[]
    createMany?: book_borrow_historyCreateManyBookInputEnvelope
    set?: book_borrow_historyWhereUniqueInput | book_borrow_historyWhereUniqueInput[]
    disconnect?: book_borrow_historyWhereUniqueInput | book_borrow_historyWhereUniqueInput[]
    delete?: book_borrow_historyWhereUniqueInput | book_borrow_historyWhereUniqueInput[]
    connect?: book_borrow_historyWhereUniqueInput | book_borrow_historyWhereUniqueInput[]
    update?: book_borrow_historyUpdateWithWhereUniqueWithoutBookInput | book_borrow_historyUpdateWithWhereUniqueWithoutBookInput[]
    updateMany?: book_borrow_historyUpdateManyWithWhereWithoutBookInput | book_borrow_historyUpdateManyWithWhereWithoutBookInput[]
    deleteMany?: book_borrow_historyScalarWhereInput | book_borrow_historyScalarWhereInput[]
  }

  export type book_ratingUncheckedUpdateManyWithoutBookNestedInput = {
    create?: XOR<book_ratingCreateWithoutBookInput, book_ratingUncheckedCreateWithoutBookInput> | book_ratingCreateWithoutBookInput[] | book_ratingUncheckedCreateWithoutBookInput[]
    connectOrCreate?: book_ratingCreateOrConnectWithoutBookInput | book_ratingCreateOrConnectWithoutBookInput[]
    upsert?: book_ratingUpsertWithWhereUniqueWithoutBookInput | book_ratingUpsertWithWhereUniqueWithoutBookInput[]
    createMany?: book_ratingCreateManyBookInputEnvelope
    set?: book_ratingWhereUniqueInput | book_ratingWhereUniqueInput[]
    disconnect?: book_ratingWhereUniqueInput | book_ratingWhereUniqueInput[]
    delete?: book_ratingWhereUniqueInput | book_ratingWhereUniqueInput[]
    connect?: book_ratingWhereUniqueInput | book_ratingWhereUniqueInput[]
    update?: book_ratingUpdateWithWhereUniqueWithoutBookInput | book_ratingUpdateWithWhereUniqueWithoutBookInput[]
    updateMany?: book_ratingUpdateManyWithWhereWithoutBookInput | book_ratingUpdateManyWithWhereWithoutBookInput[]
    deleteMany?: book_ratingScalarWhereInput | book_ratingScalarWhereInput[]
  }

  export type book_bookCreateNestedManyWithoutCategoryInput = {
    create?: XOR<book_bookCreateWithoutCategoryInput, book_bookUncheckedCreateWithoutCategoryInput> | book_bookCreateWithoutCategoryInput[] | book_bookUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: book_bookCreateOrConnectWithoutCategoryInput | book_bookCreateOrConnectWithoutCategoryInput[]
    createMany?: book_bookCreateManyCategoryInputEnvelope
    connect?: book_bookWhereUniqueInput | book_bookWhereUniqueInput[]
  }

  export type book_bookUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<book_bookCreateWithoutCategoryInput, book_bookUncheckedCreateWithoutCategoryInput> | book_bookCreateWithoutCategoryInput[] | book_bookUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: book_bookCreateOrConnectWithoutCategoryInput | book_bookCreateOrConnectWithoutCategoryInput[]
    createMany?: book_bookCreateManyCategoryInputEnvelope
    connect?: book_bookWhereUniqueInput | book_bookWhereUniqueInput[]
  }

  export type book_bookUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<book_bookCreateWithoutCategoryInput, book_bookUncheckedCreateWithoutCategoryInput> | book_bookCreateWithoutCategoryInput[] | book_bookUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: book_bookCreateOrConnectWithoutCategoryInput | book_bookCreateOrConnectWithoutCategoryInput[]
    upsert?: book_bookUpsertWithWhereUniqueWithoutCategoryInput | book_bookUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: book_bookCreateManyCategoryInputEnvelope
    set?: book_bookWhereUniqueInput | book_bookWhereUniqueInput[]
    disconnect?: book_bookWhereUniqueInput | book_bookWhereUniqueInput[]
    delete?: book_bookWhereUniqueInput | book_bookWhereUniqueInput[]
    connect?: book_bookWhereUniqueInput | book_bookWhereUniqueInput[]
    update?: book_bookUpdateWithWhereUniqueWithoutCategoryInput | book_bookUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: book_bookUpdateManyWithWhereWithoutCategoryInput | book_bookUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: book_bookScalarWhereInput | book_bookScalarWhereInput[]
  }

  export type book_bookUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<book_bookCreateWithoutCategoryInput, book_bookUncheckedCreateWithoutCategoryInput> | book_bookCreateWithoutCategoryInput[] | book_bookUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: book_bookCreateOrConnectWithoutCategoryInput | book_bookCreateOrConnectWithoutCategoryInput[]
    upsert?: book_bookUpsertWithWhereUniqueWithoutCategoryInput | book_bookUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: book_bookCreateManyCategoryInputEnvelope
    set?: book_bookWhereUniqueInput | book_bookWhereUniqueInput[]
    disconnect?: book_bookWhereUniqueInput | book_bookWhereUniqueInput[]
    delete?: book_bookWhereUniqueInput | book_bookWhereUniqueInput[]
    connect?: book_bookWhereUniqueInput | book_bookWhereUniqueInput[]
    update?: book_bookUpdateWithWhereUniqueWithoutCategoryInput | book_bookUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: book_bookUpdateManyWithWhereWithoutCategoryInput | book_bookUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: book_bookScalarWhereInput | book_bookScalarWhereInput[]
  }

  export type book_userCreateNestedOneWithoutBorrowedInput = {
    create?: XOR<book_userCreateWithoutBorrowedInput, book_userUncheckedCreateWithoutBorrowedInput>
    connectOrCreate?: book_userCreateOrConnectWithoutBorrowedInput
    connect?: book_userWhereUniqueInput
  }

  export type book_bookCreateNestedOneWithoutBorrowedInput = {
    create?: XOR<book_bookCreateWithoutBorrowedInput, book_bookUncheckedCreateWithoutBorrowedInput>
    connectOrCreate?: book_bookCreateOrConnectWithoutBorrowedInput
    connect?: book_bookWhereUniqueInput
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type book_userUpdateOneRequiredWithoutBorrowedNestedInput = {
    create?: XOR<book_userCreateWithoutBorrowedInput, book_userUncheckedCreateWithoutBorrowedInput>
    connectOrCreate?: book_userCreateOrConnectWithoutBorrowedInput
    upsert?: book_userUpsertWithoutBorrowedInput
    connect?: book_userWhereUniqueInput
    update?: XOR<XOR<book_userUpdateToOneWithWhereWithoutBorrowedInput, book_userUpdateWithoutBorrowedInput>, book_userUncheckedUpdateWithoutBorrowedInput>
  }

  export type book_bookUpdateOneRequiredWithoutBorrowedNestedInput = {
    create?: XOR<book_bookCreateWithoutBorrowedInput, book_bookUncheckedCreateWithoutBorrowedInput>
    connectOrCreate?: book_bookCreateOrConnectWithoutBorrowedInput
    upsert?: book_bookUpsertWithoutBorrowedInput
    connect?: book_bookWhereUniqueInput
    update?: XOR<XOR<book_bookUpdateToOneWithWhereWithoutBorrowedInput, book_bookUpdateWithoutBorrowedInput>, book_bookUncheckedUpdateWithoutBorrowedInput>
  }

  export type book_userCreateNestedOneWithoutBook_borrow_historyInput = {
    create?: XOR<book_userCreateWithoutBook_borrow_historyInput, book_userUncheckedCreateWithoutBook_borrow_historyInput>
    connectOrCreate?: book_userCreateOrConnectWithoutBook_borrow_historyInput
    connect?: book_userWhereUniqueInput
  }

  export type book_bookCreateNestedOneWithoutBook_borrow_historyInput = {
    create?: XOR<book_bookCreateWithoutBook_borrow_historyInput, book_bookUncheckedCreateWithoutBook_borrow_historyInput>
    connectOrCreate?: book_bookCreateOrConnectWithoutBook_borrow_historyInput
    connect?: book_bookWhereUniqueInput
  }

  export type book_userUpdateOneRequiredWithoutBook_borrow_historyNestedInput = {
    create?: XOR<book_userCreateWithoutBook_borrow_historyInput, book_userUncheckedCreateWithoutBook_borrow_historyInput>
    connectOrCreate?: book_userCreateOrConnectWithoutBook_borrow_historyInput
    upsert?: book_userUpsertWithoutBook_borrow_historyInput
    connect?: book_userWhereUniqueInput
    update?: XOR<XOR<book_userUpdateToOneWithWhereWithoutBook_borrow_historyInput, book_userUpdateWithoutBook_borrow_historyInput>, book_userUncheckedUpdateWithoutBook_borrow_historyInput>
  }

  export type book_bookUpdateOneRequiredWithoutBook_borrow_historyNestedInput = {
    create?: XOR<book_bookCreateWithoutBook_borrow_historyInput, book_bookUncheckedCreateWithoutBook_borrow_historyInput>
    connectOrCreate?: book_bookCreateOrConnectWithoutBook_borrow_historyInput
    upsert?: book_bookUpsertWithoutBook_borrow_historyInput
    connect?: book_bookWhereUniqueInput
    update?: XOR<XOR<book_bookUpdateToOneWithWhereWithoutBook_borrow_historyInput, book_bookUpdateWithoutBook_borrow_historyInput>, book_bookUncheckedUpdateWithoutBook_borrow_historyInput>
  }

  export type book_userCreateNestedOneWithoutBook_ratingInput = {
    create?: XOR<book_userCreateWithoutBook_ratingInput, book_userUncheckedCreateWithoutBook_ratingInput>
    connectOrCreate?: book_userCreateOrConnectWithoutBook_ratingInput
    connect?: book_userWhereUniqueInput
  }

  export type book_bookCreateNestedOneWithoutBook_ratingInput = {
    create?: XOR<book_bookCreateWithoutBook_ratingInput, book_bookUncheckedCreateWithoutBook_ratingInput>
    connectOrCreate?: book_bookCreateOrConnectWithoutBook_ratingInput
    connect?: book_bookWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type book_userUpdateOneRequiredWithoutBook_ratingNestedInput = {
    create?: XOR<book_userCreateWithoutBook_ratingInput, book_userUncheckedCreateWithoutBook_ratingInput>
    connectOrCreate?: book_userCreateOrConnectWithoutBook_ratingInput
    upsert?: book_userUpsertWithoutBook_ratingInput
    connect?: book_userWhereUniqueInput
    update?: XOR<XOR<book_userUpdateToOneWithWhereWithoutBook_ratingInput, book_userUpdateWithoutBook_ratingInput>, book_userUncheckedUpdateWithoutBook_ratingInput>
  }

  export type book_bookUpdateOneRequiredWithoutBook_ratingNestedInput = {
    create?: XOR<book_bookCreateWithoutBook_ratingInput, book_bookUncheckedCreateWithoutBook_ratingInput>
    connectOrCreate?: book_bookCreateOrConnectWithoutBook_ratingInput
    upsert?: book_bookUpsertWithoutBook_ratingInput
    connect?: book_bookWhereUniqueInput
    update?: XOR<XOR<book_bookUpdateToOneWithWhereWithoutBook_ratingInput, book_bookUpdateWithoutBook_ratingInput>, book_bookUncheckedUpdateWithoutBook_ratingInput>
  }

  export type study_reservationCreateNestedManyWithoutUserInput = {
    create?: XOR<study_reservationCreateWithoutUserInput, study_reservationUncheckedCreateWithoutUserInput> | study_reservationCreateWithoutUserInput[] | study_reservationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: study_reservationCreateOrConnectWithoutUserInput | study_reservationCreateOrConnectWithoutUserInput[]
    createMany?: study_reservationCreateManyUserInputEnvelope
    connect?: study_reservationWhereUniqueInput | study_reservationWhereUniqueInput[]
  }

  export type study_messageCreateNestedManyWithoutUserInput = {
    create?: XOR<study_messageCreateWithoutUserInput, study_messageUncheckedCreateWithoutUserInput> | study_messageCreateWithoutUserInput[] | study_messageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: study_messageCreateOrConnectWithoutUserInput | study_messageCreateOrConnectWithoutUserInput[]
    createMany?: study_messageCreateManyUserInputEnvelope
    connect?: study_messageWhereUniqueInput | study_messageWhereUniqueInput[]
  }

  export type study_reservationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<study_reservationCreateWithoutUserInput, study_reservationUncheckedCreateWithoutUserInput> | study_reservationCreateWithoutUserInput[] | study_reservationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: study_reservationCreateOrConnectWithoutUserInput | study_reservationCreateOrConnectWithoutUserInput[]
    createMany?: study_reservationCreateManyUserInputEnvelope
    connect?: study_reservationWhereUniqueInput | study_reservationWhereUniqueInput[]
  }

  export type study_messageUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<study_messageCreateWithoutUserInput, study_messageUncheckedCreateWithoutUserInput> | study_messageCreateWithoutUserInput[] | study_messageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: study_messageCreateOrConnectWithoutUserInput | study_messageCreateOrConnectWithoutUserInput[]
    createMany?: study_messageCreateManyUserInputEnvelope
    connect?: study_messageWhereUniqueInput | study_messageWhereUniqueInput[]
  }

  export type study_reservationUpdateManyWithoutUserNestedInput = {
    create?: XOR<study_reservationCreateWithoutUserInput, study_reservationUncheckedCreateWithoutUserInput> | study_reservationCreateWithoutUserInput[] | study_reservationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: study_reservationCreateOrConnectWithoutUserInput | study_reservationCreateOrConnectWithoutUserInput[]
    upsert?: study_reservationUpsertWithWhereUniqueWithoutUserInput | study_reservationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: study_reservationCreateManyUserInputEnvelope
    set?: study_reservationWhereUniqueInput | study_reservationWhereUniqueInput[]
    disconnect?: study_reservationWhereUniqueInput | study_reservationWhereUniqueInput[]
    delete?: study_reservationWhereUniqueInput | study_reservationWhereUniqueInput[]
    connect?: study_reservationWhereUniqueInput | study_reservationWhereUniqueInput[]
    update?: study_reservationUpdateWithWhereUniqueWithoutUserInput | study_reservationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: study_reservationUpdateManyWithWhereWithoutUserInput | study_reservationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: study_reservationScalarWhereInput | study_reservationScalarWhereInput[]
  }

  export type study_messageUpdateManyWithoutUserNestedInput = {
    create?: XOR<study_messageCreateWithoutUserInput, study_messageUncheckedCreateWithoutUserInput> | study_messageCreateWithoutUserInput[] | study_messageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: study_messageCreateOrConnectWithoutUserInput | study_messageCreateOrConnectWithoutUserInput[]
    upsert?: study_messageUpsertWithWhereUniqueWithoutUserInput | study_messageUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: study_messageCreateManyUserInputEnvelope
    set?: study_messageWhereUniqueInput | study_messageWhereUniqueInput[]
    disconnect?: study_messageWhereUniqueInput | study_messageWhereUniqueInput[]
    delete?: study_messageWhereUniqueInput | study_messageWhereUniqueInput[]
    connect?: study_messageWhereUniqueInput | study_messageWhereUniqueInput[]
    update?: study_messageUpdateWithWhereUniqueWithoutUserInput | study_messageUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: study_messageUpdateManyWithWhereWithoutUserInput | study_messageUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: study_messageScalarWhereInput | study_messageScalarWhereInput[]
  }

  export type study_reservationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<study_reservationCreateWithoutUserInput, study_reservationUncheckedCreateWithoutUserInput> | study_reservationCreateWithoutUserInput[] | study_reservationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: study_reservationCreateOrConnectWithoutUserInput | study_reservationCreateOrConnectWithoutUserInput[]
    upsert?: study_reservationUpsertWithWhereUniqueWithoutUserInput | study_reservationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: study_reservationCreateManyUserInputEnvelope
    set?: study_reservationWhereUniqueInput | study_reservationWhereUniqueInput[]
    disconnect?: study_reservationWhereUniqueInput | study_reservationWhereUniqueInput[]
    delete?: study_reservationWhereUniqueInput | study_reservationWhereUniqueInput[]
    connect?: study_reservationWhereUniqueInput | study_reservationWhereUniqueInput[]
    update?: study_reservationUpdateWithWhereUniqueWithoutUserInput | study_reservationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: study_reservationUpdateManyWithWhereWithoutUserInput | study_reservationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: study_reservationScalarWhereInput | study_reservationScalarWhereInput[]
  }

  export type study_messageUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<study_messageCreateWithoutUserInput, study_messageUncheckedCreateWithoutUserInput> | study_messageCreateWithoutUserInput[] | study_messageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: study_messageCreateOrConnectWithoutUserInput | study_messageCreateOrConnectWithoutUserInput[]
    upsert?: study_messageUpsertWithWhereUniqueWithoutUserInput | study_messageUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: study_messageCreateManyUserInputEnvelope
    set?: study_messageWhereUniqueInput | study_messageWhereUniqueInput[]
    disconnect?: study_messageWhereUniqueInput | study_messageWhereUniqueInput[]
    delete?: study_messageWhereUniqueInput | study_messageWhereUniqueInput[]
    connect?: study_messageWhereUniqueInput | study_messageWhereUniqueInput[]
    update?: study_messageUpdateWithWhereUniqueWithoutUserInput | study_messageUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: study_messageUpdateManyWithWhereWithoutUserInput | study_messageUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: study_messageScalarWhereInput | study_messageScalarWhereInput[]
  }

  export type study_floorCreateNestedManyWithoutStoreInput = {
    create?: XOR<study_floorCreateWithoutStoreInput, study_floorUncheckedCreateWithoutStoreInput> | study_floorCreateWithoutStoreInput[] | study_floorUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: study_floorCreateOrConnectWithoutStoreInput | study_floorCreateOrConnectWithoutStoreInput[]
    createMany?: study_floorCreateManyStoreInputEnvelope
    connect?: study_floorWhereUniqueInput | study_floorWhereUniqueInput[]
  }

  export type study_floorUncheckedCreateNestedManyWithoutStoreInput = {
    create?: XOR<study_floorCreateWithoutStoreInput, study_floorUncheckedCreateWithoutStoreInput> | study_floorCreateWithoutStoreInput[] | study_floorUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: study_floorCreateOrConnectWithoutStoreInput | study_floorCreateOrConnectWithoutStoreInput[]
    createMany?: study_floorCreateManyStoreInputEnvelope
    connect?: study_floorWhereUniqueInput | study_floorWhereUniqueInput[]
  }

  export type study_floorUpdateManyWithoutStoreNestedInput = {
    create?: XOR<study_floorCreateWithoutStoreInput, study_floorUncheckedCreateWithoutStoreInput> | study_floorCreateWithoutStoreInput[] | study_floorUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: study_floorCreateOrConnectWithoutStoreInput | study_floorCreateOrConnectWithoutStoreInput[]
    upsert?: study_floorUpsertWithWhereUniqueWithoutStoreInput | study_floorUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: study_floorCreateManyStoreInputEnvelope
    set?: study_floorWhereUniqueInput | study_floorWhereUniqueInput[]
    disconnect?: study_floorWhereUniqueInput | study_floorWhereUniqueInput[]
    delete?: study_floorWhereUniqueInput | study_floorWhereUniqueInput[]
    connect?: study_floorWhereUniqueInput | study_floorWhereUniqueInput[]
    update?: study_floorUpdateWithWhereUniqueWithoutStoreInput | study_floorUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: study_floorUpdateManyWithWhereWithoutStoreInput | study_floorUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: study_floorScalarWhereInput | study_floorScalarWhereInput[]
  }

  export type study_floorUncheckedUpdateManyWithoutStoreNestedInput = {
    create?: XOR<study_floorCreateWithoutStoreInput, study_floorUncheckedCreateWithoutStoreInput> | study_floorCreateWithoutStoreInput[] | study_floorUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: study_floorCreateOrConnectWithoutStoreInput | study_floorCreateOrConnectWithoutStoreInput[]
    upsert?: study_floorUpsertWithWhereUniqueWithoutStoreInput | study_floorUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: study_floorCreateManyStoreInputEnvelope
    set?: study_floorWhereUniqueInput | study_floorWhereUniqueInput[]
    disconnect?: study_floorWhereUniqueInput | study_floorWhereUniqueInput[]
    delete?: study_floorWhereUniqueInput | study_floorWhereUniqueInput[]
    connect?: study_floorWhereUniqueInput | study_floorWhereUniqueInput[]
    update?: study_floorUpdateWithWhereUniqueWithoutStoreInput | study_floorUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: study_floorUpdateManyWithWhereWithoutStoreInput | study_floorUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: study_floorScalarWhereInput | study_floorScalarWhereInput[]
  }

  export type study_storeCreateNestedOneWithoutFloorsInput = {
    create?: XOR<study_storeCreateWithoutFloorsInput, study_storeUncheckedCreateWithoutFloorsInput>
    connectOrCreate?: study_storeCreateOrConnectWithoutFloorsInput
    connect?: study_storeWhereUniqueInput
  }

  export type study_roomCreateNestedManyWithoutFloorInput = {
    create?: XOR<study_roomCreateWithoutFloorInput, study_roomUncheckedCreateWithoutFloorInput> | study_roomCreateWithoutFloorInput[] | study_roomUncheckedCreateWithoutFloorInput[]
    connectOrCreate?: study_roomCreateOrConnectWithoutFloorInput | study_roomCreateOrConnectWithoutFloorInput[]
    createMany?: study_roomCreateManyFloorInputEnvelope
    connect?: study_roomWhereUniqueInput | study_roomWhereUniqueInput[]
  }

  export type study_roomUncheckedCreateNestedManyWithoutFloorInput = {
    create?: XOR<study_roomCreateWithoutFloorInput, study_roomUncheckedCreateWithoutFloorInput> | study_roomCreateWithoutFloorInput[] | study_roomUncheckedCreateWithoutFloorInput[]
    connectOrCreate?: study_roomCreateOrConnectWithoutFloorInput | study_roomCreateOrConnectWithoutFloorInput[]
    createMany?: study_roomCreateManyFloorInputEnvelope
    connect?: study_roomWhereUniqueInput | study_roomWhereUniqueInput[]
  }

  export type study_storeUpdateOneRequiredWithoutFloorsNestedInput = {
    create?: XOR<study_storeCreateWithoutFloorsInput, study_storeUncheckedCreateWithoutFloorsInput>
    connectOrCreate?: study_storeCreateOrConnectWithoutFloorsInput
    upsert?: study_storeUpsertWithoutFloorsInput
    connect?: study_storeWhereUniqueInput
    update?: XOR<XOR<study_storeUpdateToOneWithWhereWithoutFloorsInput, study_storeUpdateWithoutFloorsInput>, study_storeUncheckedUpdateWithoutFloorsInput>
  }

  export type study_roomUpdateManyWithoutFloorNestedInput = {
    create?: XOR<study_roomCreateWithoutFloorInput, study_roomUncheckedCreateWithoutFloorInput> | study_roomCreateWithoutFloorInput[] | study_roomUncheckedCreateWithoutFloorInput[]
    connectOrCreate?: study_roomCreateOrConnectWithoutFloorInput | study_roomCreateOrConnectWithoutFloorInput[]
    upsert?: study_roomUpsertWithWhereUniqueWithoutFloorInput | study_roomUpsertWithWhereUniqueWithoutFloorInput[]
    createMany?: study_roomCreateManyFloorInputEnvelope
    set?: study_roomWhereUniqueInput | study_roomWhereUniqueInput[]
    disconnect?: study_roomWhereUniqueInput | study_roomWhereUniqueInput[]
    delete?: study_roomWhereUniqueInput | study_roomWhereUniqueInput[]
    connect?: study_roomWhereUniqueInput | study_roomWhereUniqueInput[]
    update?: study_roomUpdateWithWhereUniqueWithoutFloorInput | study_roomUpdateWithWhereUniqueWithoutFloorInput[]
    updateMany?: study_roomUpdateManyWithWhereWithoutFloorInput | study_roomUpdateManyWithWhereWithoutFloorInput[]
    deleteMany?: study_roomScalarWhereInput | study_roomScalarWhereInput[]
  }

  export type study_roomUncheckedUpdateManyWithoutFloorNestedInput = {
    create?: XOR<study_roomCreateWithoutFloorInput, study_roomUncheckedCreateWithoutFloorInput> | study_roomCreateWithoutFloorInput[] | study_roomUncheckedCreateWithoutFloorInput[]
    connectOrCreate?: study_roomCreateOrConnectWithoutFloorInput | study_roomCreateOrConnectWithoutFloorInput[]
    upsert?: study_roomUpsertWithWhereUniqueWithoutFloorInput | study_roomUpsertWithWhereUniqueWithoutFloorInput[]
    createMany?: study_roomCreateManyFloorInputEnvelope
    set?: study_roomWhereUniqueInput | study_roomWhereUniqueInput[]
    disconnect?: study_roomWhereUniqueInput | study_roomWhereUniqueInput[]
    delete?: study_roomWhereUniqueInput | study_roomWhereUniqueInput[]
    connect?: study_roomWhereUniqueInput | study_roomWhereUniqueInput[]
    update?: study_roomUpdateWithWhereUniqueWithoutFloorInput | study_roomUpdateWithWhereUniqueWithoutFloorInput[]
    updateMany?: study_roomUpdateManyWithWhereWithoutFloorInput | study_roomUpdateManyWithWhereWithoutFloorInput[]
    deleteMany?: study_roomScalarWhereInput | study_roomScalarWhereInput[]
  }

  export type study_floorCreateNestedOneWithoutStudyRoomsInput = {
    create?: XOR<study_floorCreateWithoutStudyRoomsInput, study_floorUncheckedCreateWithoutStudyRoomsInput>
    connectOrCreate?: study_floorCreateOrConnectWithoutStudyRoomsInput
    connect?: study_floorWhereUniqueInput
  }

  export type study_seatCreateNestedManyWithoutRoomInput = {
    create?: XOR<study_seatCreateWithoutRoomInput, study_seatUncheckedCreateWithoutRoomInput> | study_seatCreateWithoutRoomInput[] | study_seatUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: study_seatCreateOrConnectWithoutRoomInput | study_seatCreateOrConnectWithoutRoomInput[]
    createMany?: study_seatCreateManyRoomInputEnvelope
    connect?: study_seatWhereUniqueInput | study_seatWhereUniqueInput[]
  }

  export type study_seatUncheckedCreateNestedManyWithoutRoomInput = {
    create?: XOR<study_seatCreateWithoutRoomInput, study_seatUncheckedCreateWithoutRoomInput> | study_seatCreateWithoutRoomInput[] | study_seatUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: study_seatCreateOrConnectWithoutRoomInput | study_seatCreateOrConnectWithoutRoomInput[]
    createMany?: study_seatCreateManyRoomInputEnvelope
    connect?: study_seatWhereUniqueInput | study_seatWhereUniqueInput[]
  }

  export type study_floorUpdateOneRequiredWithoutStudyRoomsNestedInput = {
    create?: XOR<study_floorCreateWithoutStudyRoomsInput, study_floorUncheckedCreateWithoutStudyRoomsInput>
    connectOrCreate?: study_floorCreateOrConnectWithoutStudyRoomsInput
    upsert?: study_floorUpsertWithoutStudyRoomsInput
    connect?: study_floorWhereUniqueInput
    update?: XOR<XOR<study_floorUpdateToOneWithWhereWithoutStudyRoomsInput, study_floorUpdateWithoutStudyRoomsInput>, study_floorUncheckedUpdateWithoutStudyRoomsInput>
  }

  export type study_seatUpdateManyWithoutRoomNestedInput = {
    create?: XOR<study_seatCreateWithoutRoomInput, study_seatUncheckedCreateWithoutRoomInput> | study_seatCreateWithoutRoomInput[] | study_seatUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: study_seatCreateOrConnectWithoutRoomInput | study_seatCreateOrConnectWithoutRoomInput[]
    upsert?: study_seatUpsertWithWhereUniqueWithoutRoomInput | study_seatUpsertWithWhereUniqueWithoutRoomInput[]
    createMany?: study_seatCreateManyRoomInputEnvelope
    set?: study_seatWhereUniqueInput | study_seatWhereUniqueInput[]
    disconnect?: study_seatWhereUniqueInput | study_seatWhereUniqueInput[]
    delete?: study_seatWhereUniqueInput | study_seatWhereUniqueInput[]
    connect?: study_seatWhereUniqueInput | study_seatWhereUniqueInput[]
    update?: study_seatUpdateWithWhereUniqueWithoutRoomInput | study_seatUpdateWithWhereUniqueWithoutRoomInput[]
    updateMany?: study_seatUpdateManyWithWhereWithoutRoomInput | study_seatUpdateManyWithWhereWithoutRoomInput[]
    deleteMany?: study_seatScalarWhereInput | study_seatScalarWhereInput[]
  }

  export type study_seatUncheckedUpdateManyWithoutRoomNestedInput = {
    create?: XOR<study_seatCreateWithoutRoomInput, study_seatUncheckedCreateWithoutRoomInput> | study_seatCreateWithoutRoomInput[] | study_seatUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: study_seatCreateOrConnectWithoutRoomInput | study_seatCreateOrConnectWithoutRoomInput[]
    upsert?: study_seatUpsertWithWhereUniqueWithoutRoomInput | study_seatUpsertWithWhereUniqueWithoutRoomInput[]
    createMany?: study_seatCreateManyRoomInputEnvelope
    set?: study_seatWhereUniqueInput | study_seatWhereUniqueInput[]
    disconnect?: study_seatWhereUniqueInput | study_seatWhereUniqueInput[]
    delete?: study_seatWhereUniqueInput | study_seatWhereUniqueInput[]
    connect?: study_seatWhereUniqueInput | study_seatWhereUniqueInput[]
    update?: study_seatUpdateWithWhereUniqueWithoutRoomInput | study_seatUpdateWithWhereUniqueWithoutRoomInput[]
    updateMany?: study_seatUpdateManyWithWhereWithoutRoomInput | study_seatUpdateManyWithWhereWithoutRoomInput[]
    deleteMany?: study_seatScalarWhereInput | study_seatScalarWhereInput[]
  }

  export type study_roomCreateNestedOneWithoutSeatsInput = {
    create?: XOR<study_roomCreateWithoutSeatsInput, study_roomUncheckedCreateWithoutSeatsInput>
    connectOrCreate?: study_roomCreateOrConnectWithoutSeatsInput
    connect?: study_roomWhereUniqueInput
  }

  export type study_reservationCreateNestedManyWithoutSeatInput = {
    create?: XOR<study_reservationCreateWithoutSeatInput, study_reservationUncheckedCreateWithoutSeatInput> | study_reservationCreateWithoutSeatInput[] | study_reservationUncheckedCreateWithoutSeatInput[]
    connectOrCreate?: study_reservationCreateOrConnectWithoutSeatInput | study_reservationCreateOrConnectWithoutSeatInput[]
    createMany?: study_reservationCreateManySeatInputEnvelope
    connect?: study_reservationWhereUniqueInput | study_reservationWhereUniqueInput[]
  }

  export type study_reservationUncheckedCreateNestedManyWithoutSeatInput = {
    create?: XOR<study_reservationCreateWithoutSeatInput, study_reservationUncheckedCreateWithoutSeatInput> | study_reservationCreateWithoutSeatInput[] | study_reservationUncheckedCreateWithoutSeatInput[]
    connectOrCreate?: study_reservationCreateOrConnectWithoutSeatInput | study_reservationCreateOrConnectWithoutSeatInput[]
    createMany?: study_reservationCreateManySeatInputEnvelope
    connect?: study_reservationWhereUniqueInput | study_reservationWhereUniqueInput[]
  }

  export type study_roomUpdateOneRequiredWithoutSeatsNestedInput = {
    create?: XOR<study_roomCreateWithoutSeatsInput, study_roomUncheckedCreateWithoutSeatsInput>
    connectOrCreate?: study_roomCreateOrConnectWithoutSeatsInput
    upsert?: study_roomUpsertWithoutSeatsInput
    connect?: study_roomWhereUniqueInput
    update?: XOR<XOR<study_roomUpdateToOneWithWhereWithoutSeatsInput, study_roomUpdateWithoutSeatsInput>, study_roomUncheckedUpdateWithoutSeatsInput>
  }

  export type study_reservationUpdateManyWithoutSeatNestedInput = {
    create?: XOR<study_reservationCreateWithoutSeatInput, study_reservationUncheckedCreateWithoutSeatInput> | study_reservationCreateWithoutSeatInput[] | study_reservationUncheckedCreateWithoutSeatInput[]
    connectOrCreate?: study_reservationCreateOrConnectWithoutSeatInput | study_reservationCreateOrConnectWithoutSeatInput[]
    upsert?: study_reservationUpsertWithWhereUniqueWithoutSeatInput | study_reservationUpsertWithWhereUniqueWithoutSeatInput[]
    createMany?: study_reservationCreateManySeatInputEnvelope
    set?: study_reservationWhereUniqueInput | study_reservationWhereUniqueInput[]
    disconnect?: study_reservationWhereUniqueInput | study_reservationWhereUniqueInput[]
    delete?: study_reservationWhereUniqueInput | study_reservationWhereUniqueInput[]
    connect?: study_reservationWhereUniqueInput | study_reservationWhereUniqueInput[]
    update?: study_reservationUpdateWithWhereUniqueWithoutSeatInput | study_reservationUpdateWithWhereUniqueWithoutSeatInput[]
    updateMany?: study_reservationUpdateManyWithWhereWithoutSeatInput | study_reservationUpdateManyWithWhereWithoutSeatInput[]
    deleteMany?: study_reservationScalarWhereInput | study_reservationScalarWhereInput[]
  }

  export type study_reservationUncheckedUpdateManyWithoutSeatNestedInput = {
    create?: XOR<study_reservationCreateWithoutSeatInput, study_reservationUncheckedCreateWithoutSeatInput> | study_reservationCreateWithoutSeatInput[] | study_reservationUncheckedCreateWithoutSeatInput[]
    connectOrCreate?: study_reservationCreateOrConnectWithoutSeatInput | study_reservationCreateOrConnectWithoutSeatInput[]
    upsert?: study_reservationUpsertWithWhereUniqueWithoutSeatInput | study_reservationUpsertWithWhereUniqueWithoutSeatInput[]
    createMany?: study_reservationCreateManySeatInputEnvelope
    set?: study_reservationWhereUniqueInput | study_reservationWhereUniqueInput[]
    disconnect?: study_reservationWhereUniqueInput | study_reservationWhereUniqueInput[]
    delete?: study_reservationWhereUniqueInput | study_reservationWhereUniqueInput[]
    connect?: study_reservationWhereUniqueInput | study_reservationWhereUniqueInput[]
    update?: study_reservationUpdateWithWhereUniqueWithoutSeatInput | study_reservationUpdateWithWhereUniqueWithoutSeatInput[]
    updateMany?: study_reservationUpdateManyWithWhereWithoutSeatInput | study_reservationUpdateManyWithWhereWithoutSeatInput[]
    deleteMany?: study_reservationScalarWhereInput | study_reservationScalarWhereInput[]
  }

  export type study_userCreateNestedOneWithoutReservationInput = {
    create?: XOR<study_userCreateWithoutReservationInput, study_userUncheckedCreateWithoutReservationInput>
    connectOrCreate?: study_userCreateOrConnectWithoutReservationInput
    connect?: study_userWhereUniqueInput
  }

  export type study_seatCreateNestedOneWithoutReservationsInput = {
    create?: XOR<study_seatCreateWithoutReservationsInput, study_seatUncheckedCreateWithoutReservationsInput>
    connectOrCreate?: study_seatCreateOrConnectWithoutReservationsInput
    connect?: study_seatWhereUniqueInput
  }

  export type study_userUpdateOneRequiredWithoutReservationNestedInput = {
    create?: XOR<study_userCreateWithoutReservationInput, study_userUncheckedCreateWithoutReservationInput>
    connectOrCreate?: study_userCreateOrConnectWithoutReservationInput
    upsert?: study_userUpsertWithoutReservationInput
    connect?: study_userWhereUniqueInput
    update?: XOR<XOR<study_userUpdateToOneWithWhereWithoutReservationInput, study_userUpdateWithoutReservationInput>, study_userUncheckedUpdateWithoutReservationInput>
  }

  export type study_seatUpdateOneRequiredWithoutReservationsNestedInput = {
    create?: XOR<study_seatCreateWithoutReservationsInput, study_seatUncheckedCreateWithoutReservationsInput>
    connectOrCreate?: study_seatCreateOrConnectWithoutReservationsInput
    upsert?: study_seatUpsertWithoutReservationsInput
    connect?: study_seatWhereUniqueInput
    update?: XOR<XOR<study_seatUpdateToOneWithWhereWithoutReservationsInput, study_seatUpdateWithoutReservationsInput>, study_seatUncheckedUpdateWithoutReservationsInput>
  }

  export type study_userCreateNestedOneWithoutMessageInput = {
    create?: XOR<study_userCreateWithoutMessageInput, study_userUncheckedCreateWithoutMessageInput>
    connectOrCreate?: study_userCreateOrConnectWithoutMessageInput
    connect?: study_userWhereUniqueInput
  }

  export type study_userUpdateOneRequiredWithoutMessageNestedInput = {
    create?: XOR<study_userCreateWithoutMessageInput, study_userUncheckedCreateWithoutMessageInput>
    connectOrCreate?: study_userCreateOrConnectWithoutMessageInput
    upsert?: study_userUpsertWithoutMessageInput
    connect?: study_userWhereUniqueInput
    update?: XOR<XOR<study_userUpdateToOneWithWhereWithoutMessageInput, study_userUpdateWithoutMessageInput>, study_userUncheckedUpdateWithoutMessageInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumsys_account_providerFilter<$PrismaModel = never> = {
    equals?: $Enums.sys_account_provider | Enumsys_account_providerFieldRefInput<$PrismaModel>
    in?: $Enums.sys_account_provider[]
    notIn?: $Enums.sys_account_provider[]
    not?: NestedEnumsys_account_providerFilter<$PrismaModel> | $Enums.sys_account_provider
  }

  export type NestedEnumsys_account_providerWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.sys_account_provider | Enumsys_account_providerFieldRefInput<$PrismaModel>
    in?: $Enums.sys_account_provider[]
    notIn?: $Enums.sys_account_provider[]
    not?: NestedEnumsys_account_providerWithAggregatesFilter<$PrismaModel> | $Enums.sys_account_provider
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumsys_account_providerFilter<$PrismaModel>
    _max?: NestedEnumsys_account_providerFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedBigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[]
    notIn?: bigint[] | number[]
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type NestedBigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[]
    notIn?: bigint[] | number[]
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumfile_typeFilter<$PrismaModel = never> = {
    equals?: $Enums.file_type | Enumfile_typeFieldRefInput<$PrismaModel>
    in?: $Enums.file_type[]
    notIn?: $Enums.file_type[]
    not?: NestedEnumfile_typeFilter<$PrismaModel> | $Enums.file_type
  }

  export type NestedEnumfile_typeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.file_type | Enumfile_typeFieldRefInput<$PrismaModel>
    in?: $Enums.file_type[]
    notIn?: $Enums.file_type[]
    not?: NestedEnumfile_typeWithAggregatesFilter<$PrismaModel> | $Enums.file_type
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumfile_typeFilter<$PrismaModel>
    _max?: NestedEnumfile_typeFilter<$PrismaModel>
  }

  export type NestedEnumbook_roleFilter<$PrismaModel = never> = {
    equals?: $Enums.book_role | Enumbook_roleFieldRefInput<$PrismaModel>
    in?: $Enums.book_role[]
    notIn?: $Enums.book_role[]
    not?: NestedEnumbook_roleFilter<$PrismaModel> | $Enums.book_role
  }

  export type NestedEnumbook_roleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.book_role | Enumbook_roleFieldRefInput<$PrismaModel>
    in?: $Enums.book_role[]
    notIn?: $Enums.book_role[]
    not?: NestedEnumbook_roleWithAggregatesFilter<$PrismaModel> | $Enums.book_role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumbook_roleFilter<$PrismaModel>
    _max?: NestedEnumbook_roleFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type sys_accountCreateWithoutUserInput = {
    createAt?: Date | string
    updateAt?: Date | string
    provider: $Enums.sys_account_provider
    provider_id: string
  }

  export type sys_accountUncheckedCreateWithoutUserInput = {
    createAt?: Date | string
    updateAt?: Date | string
    provider: $Enums.sys_account_provider
    provider_id: string
  }

  export type sys_accountCreateOrConnectWithoutUserInput = {
    where: sys_accountWhereUniqueInput
    create: XOR<sys_accountCreateWithoutUserInput, sys_accountUncheckedCreateWithoutUserInput>
  }

  export type sys_accountCreateManyUserInputEnvelope = {
    data: sys_accountCreateManyUserInput | sys_accountCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type sys_roleCreateWithoutUsersInput = {
    uid?: string
    createAt?: Date | string
    updateAt?: Date | string
    name: string
    status?: boolean
    comment?: string | null
    menus?: sys_menu_on_roleCreateNestedManyWithoutRoleInput
  }

  export type sys_roleUncheckedCreateWithoutUsersInput = {
    uid?: string
    createAt?: Date | string
    updateAt?: Date | string
    name: string
    status?: boolean
    comment?: string | null
    menus?: sys_menu_on_roleUncheckedCreateNestedManyWithoutRoleInput
  }

  export type sys_roleCreateOrConnectWithoutUsersInput = {
    where: sys_roleWhereUniqueInput
    create: XOR<sys_roleCreateWithoutUsersInput, sys_roleUncheckedCreateWithoutUsersInput>
  }

  export type sys_user_ban_menuCreateWithoutUserInput = {
    menu: sys_menuCreateNestedOneWithoutUser_bansInput
  }

  export type sys_user_ban_menuUncheckedCreateWithoutUserInput = {
    menuId: string
  }

  export type sys_user_ban_menuCreateOrConnectWithoutUserInput = {
    where: sys_user_ban_menuWhereUniqueInput
    create: XOR<sys_user_ban_menuCreateWithoutUserInput, sys_user_ban_menuUncheckedCreateWithoutUserInput>
  }

  export type sys_user_ban_menuCreateManyUserInputEnvelope = {
    data: sys_user_ban_menuCreateManyUserInput | sys_user_ban_menuCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type sys_accountUpsertWithWhereUniqueWithoutUserInput = {
    where: sys_accountWhereUniqueInput
    update: XOR<sys_accountUpdateWithoutUserInput, sys_accountUncheckedUpdateWithoutUserInput>
    create: XOR<sys_accountCreateWithoutUserInput, sys_accountUncheckedCreateWithoutUserInput>
  }

  export type sys_accountUpdateWithWhereUniqueWithoutUserInput = {
    where: sys_accountWhereUniqueInput
    data: XOR<sys_accountUpdateWithoutUserInput, sys_accountUncheckedUpdateWithoutUserInput>
  }

  export type sys_accountUpdateManyWithWhereWithoutUserInput = {
    where: sys_accountScalarWhereInput
    data: XOR<sys_accountUpdateManyMutationInput, sys_accountUncheckedUpdateManyWithoutUserInput>
  }

  export type sys_accountScalarWhereInput = {
    AND?: sys_accountScalarWhereInput | sys_accountScalarWhereInput[]
    OR?: sys_accountScalarWhereInput[]
    NOT?: sys_accountScalarWhereInput | sys_accountScalarWhereInput[]
    createAt?: DateTimeFilter<"sys_account"> | Date | string
    updateAt?: DateTimeFilter<"sys_account"> | Date | string
    provider?: Enumsys_account_providerFilter<"sys_account"> | $Enums.sys_account_provider
    provider_id?: StringFilter<"sys_account"> | string
    userId?: StringNullableFilter<"sys_account"> | string | null
  }

  export type sys_roleUpsertWithoutUsersInput = {
    update: XOR<sys_roleUpdateWithoutUsersInput, sys_roleUncheckedUpdateWithoutUsersInput>
    create: XOR<sys_roleCreateWithoutUsersInput, sys_roleUncheckedCreateWithoutUsersInput>
    where?: sys_roleWhereInput
  }

  export type sys_roleUpdateToOneWithWhereWithoutUsersInput = {
    where?: sys_roleWhereInput
    data: XOR<sys_roleUpdateWithoutUsersInput, sys_roleUncheckedUpdateWithoutUsersInput>
  }

  export type sys_roleUpdateWithoutUsersInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    menus?: sys_menu_on_roleUpdateManyWithoutRoleNestedInput
  }

  export type sys_roleUncheckedUpdateWithoutUsersInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    menus?: sys_menu_on_roleUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type sys_user_ban_menuUpsertWithWhereUniqueWithoutUserInput = {
    where: sys_user_ban_menuWhereUniqueInput
    update: XOR<sys_user_ban_menuUpdateWithoutUserInput, sys_user_ban_menuUncheckedUpdateWithoutUserInput>
    create: XOR<sys_user_ban_menuCreateWithoutUserInput, sys_user_ban_menuUncheckedCreateWithoutUserInput>
  }

  export type sys_user_ban_menuUpdateWithWhereUniqueWithoutUserInput = {
    where: sys_user_ban_menuWhereUniqueInput
    data: XOR<sys_user_ban_menuUpdateWithoutUserInput, sys_user_ban_menuUncheckedUpdateWithoutUserInput>
  }

  export type sys_user_ban_menuUpdateManyWithWhereWithoutUserInput = {
    where: sys_user_ban_menuScalarWhereInput
    data: XOR<sys_user_ban_menuUpdateManyMutationInput, sys_user_ban_menuUncheckedUpdateManyWithoutUserInput>
  }

  export type sys_user_ban_menuScalarWhereInput = {
    AND?: sys_user_ban_menuScalarWhereInput | sys_user_ban_menuScalarWhereInput[]
    OR?: sys_user_ban_menuScalarWhereInput[]
    NOT?: sys_user_ban_menuScalarWhereInput | sys_user_ban_menuScalarWhereInput[]
    userId?: StringFilter<"sys_user_ban_menu"> | string
    menuId?: StringFilter<"sys_user_ban_menu"> | string
  }

  export type sys_userCreateWithoutAccountsInput = {
    uid?: string
    createAt?: Date | string
    updateAt?: Date | string
    name: string
    password: string
    salt: string
    role?: sys_roleCreateNestedOneWithoutUsersInput
    ban_menus?: sys_user_ban_menuCreateNestedManyWithoutUserInput
  }

  export type sys_userUncheckedCreateWithoutAccountsInput = {
    uid?: string
    createAt?: Date | string
    updateAt?: Date | string
    name: string
    password: string
    salt: string
    roleId?: string | null
    ban_menus?: sys_user_ban_menuUncheckedCreateNestedManyWithoutUserInput
  }

  export type sys_userCreateOrConnectWithoutAccountsInput = {
    where: sys_userWhereUniqueInput
    create: XOR<sys_userCreateWithoutAccountsInput, sys_userUncheckedCreateWithoutAccountsInput>
  }

  export type sys_userUpsertWithoutAccountsInput = {
    update: XOR<sys_userUpdateWithoutAccountsInput, sys_userUncheckedUpdateWithoutAccountsInput>
    create: XOR<sys_userCreateWithoutAccountsInput, sys_userUncheckedCreateWithoutAccountsInput>
    where?: sys_userWhereInput
  }

  export type sys_userUpdateToOneWithWhereWithoutAccountsInput = {
    where?: sys_userWhereInput
    data: XOR<sys_userUpdateWithoutAccountsInput, sys_userUncheckedUpdateWithoutAccountsInput>
  }

  export type sys_userUpdateWithoutAccountsInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    salt?: StringFieldUpdateOperationsInput | string
    role?: sys_roleUpdateOneWithoutUsersNestedInput
    ban_menus?: sys_user_ban_menuUpdateManyWithoutUserNestedInput
  }

  export type sys_userUncheckedUpdateWithoutAccountsInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    salt?: StringFieldUpdateOperationsInput | string
    roleId?: NullableStringFieldUpdateOperationsInput | string | null
    ban_menus?: sys_user_ban_menuUncheckedUpdateManyWithoutUserNestedInput
  }

  export type sys_menuCreateWithoutChildrenInput = {
    uid?: string
    createAt?: Date | string
    updateAt?: Date | string
    name: string
    path: string
    powers: number
    comment?: string | null
    parent?: sys_menuCreateNestedOneWithoutChildrenInput
    roles?: sys_menu_on_roleCreateNestedManyWithoutMenuInput
    user_bans?: sys_user_ban_menuCreateNestedManyWithoutMenuInput
  }

  export type sys_menuUncheckedCreateWithoutChildrenInput = {
    uid?: string
    createAt?: Date | string
    updateAt?: Date | string
    name: string
    path: string
    powers: number
    comment?: string | null
    parentId?: string | null
    roles?: sys_menu_on_roleUncheckedCreateNestedManyWithoutMenuInput
    user_bans?: sys_user_ban_menuUncheckedCreateNestedManyWithoutMenuInput
  }

  export type sys_menuCreateOrConnectWithoutChildrenInput = {
    where: sys_menuWhereUniqueInput
    create: XOR<sys_menuCreateWithoutChildrenInput, sys_menuUncheckedCreateWithoutChildrenInput>
  }

  export type sys_menuCreateWithoutParentInput = {
    uid?: string
    createAt?: Date | string
    updateAt?: Date | string
    name: string
    path: string
    powers: number
    comment?: string | null
    children?: sys_menuCreateNestedManyWithoutParentInput
    roles?: sys_menu_on_roleCreateNestedManyWithoutMenuInput
    user_bans?: sys_user_ban_menuCreateNestedManyWithoutMenuInput
  }

  export type sys_menuUncheckedCreateWithoutParentInput = {
    uid?: string
    createAt?: Date | string
    updateAt?: Date | string
    name: string
    path: string
    powers: number
    comment?: string | null
    children?: sys_menuUncheckedCreateNestedManyWithoutParentInput
    roles?: sys_menu_on_roleUncheckedCreateNestedManyWithoutMenuInput
    user_bans?: sys_user_ban_menuUncheckedCreateNestedManyWithoutMenuInput
  }

  export type sys_menuCreateOrConnectWithoutParentInput = {
    where: sys_menuWhereUniqueInput
    create: XOR<sys_menuCreateWithoutParentInput, sys_menuUncheckedCreateWithoutParentInput>
  }

  export type sys_menuCreateManyParentInputEnvelope = {
    data: sys_menuCreateManyParentInput | sys_menuCreateManyParentInput[]
    skipDuplicates?: boolean
  }

  export type sys_menu_on_roleCreateWithoutMenuInput = {
    power?: bigint | number
    role: sys_roleCreateNestedOneWithoutMenusInput
  }

  export type sys_menu_on_roleUncheckedCreateWithoutMenuInput = {
    roleId: string
    power?: bigint | number
  }

  export type sys_menu_on_roleCreateOrConnectWithoutMenuInput = {
    where: sys_menu_on_roleWhereUniqueInput
    create: XOR<sys_menu_on_roleCreateWithoutMenuInput, sys_menu_on_roleUncheckedCreateWithoutMenuInput>
  }

  export type sys_menu_on_roleCreateManyMenuInputEnvelope = {
    data: sys_menu_on_roleCreateManyMenuInput | sys_menu_on_roleCreateManyMenuInput[]
    skipDuplicates?: boolean
  }

  export type sys_user_ban_menuCreateWithoutMenuInput = {
    user: sys_userCreateNestedOneWithoutBan_menusInput
  }

  export type sys_user_ban_menuUncheckedCreateWithoutMenuInput = {
    userId: string
  }

  export type sys_user_ban_menuCreateOrConnectWithoutMenuInput = {
    where: sys_user_ban_menuWhereUniqueInput
    create: XOR<sys_user_ban_menuCreateWithoutMenuInput, sys_user_ban_menuUncheckedCreateWithoutMenuInput>
  }

  export type sys_user_ban_menuCreateManyMenuInputEnvelope = {
    data: sys_user_ban_menuCreateManyMenuInput | sys_user_ban_menuCreateManyMenuInput[]
    skipDuplicates?: boolean
  }

  export type sys_menuUpsertWithoutChildrenInput = {
    update: XOR<sys_menuUpdateWithoutChildrenInput, sys_menuUncheckedUpdateWithoutChildrenInput>
    create: XOR<sys_menuCreateWithoutChildrenInput, sys_menuUncheckedCreateWithoutChildrenInput>
    where?: sys_menuWhereInput
  }

  export type sys_menuUpdateToOneWithWhereWithoutChildrenInput = {
    where?: sys_menuWhereInput
    data: XOR<sys_menuUpdateWithoutChildrenInput, sys_menuUncheckedUpdateWithoutChildrenInput>
  }

  export type sys_menuUpdateWithoutChildrenInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    powers?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    parent?: sys_menuUpdateOneWithoutChildrenNestedInput
    roles?: sys_menu_on_roleUpdateManyWithoutMenuNestedInput
    user_bans?: sys_user_ban_menuUpdateManyWithoutMenuNestedInput
  }

  export type sys_menuUncheckedUpdateWithoutChildrenInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    powers?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    roles?: sys_menu_on_roleUncheckedUpdateManyWithoutMenuNestedInput
    user_bans?: sys_user_ban_menuUncheckedUpdateManyWithoutMenuNestedInput
  }

  export type sys_menuUpsertWithWhereUniqueWithoutParentInput = {
    where: sys_menuWhereUniqueInput
    update: XOR<sys_menuUpdateWithoutParentInput, sys_menuUncheckedUpdateWithoutParentInput>
    create: XOR<sys_menuCreateWithoutParentInput, sys_menuUncheckedCreateWithoutParentInput>
  }

  export type sys_menuUpdateWithWhereUniqueWithoutParentInput = {
    where: sys_menuWhereUniqueInput
    data: XOR<sys_menuUpdateWithoutParentInput, sys_menuUncheckedUpdateWithoutParentInput>
  }

  export type sys_menuUpdateManyWithWhereWithoutParentInput = {
    where: sys_menuScalarWhereInput
    data: XOR<sys_menuUpdateManyMutationInput, sys_menuUncheckedUpdateManyWithoutParentInput>
  }

  export type sys_menuScalarWhereInput = {
    AND?: sys_menuScalarWhereInput | sys_menuScalarWhereInput[]
    OR?: sys_menuScalarWhereInput[]
    NOT?: sys_menuScalarWhereInput | sys_menuScalarWhereInput[]
    uid?: StringFilter<"sys_menu"> | string
    createAt?: DateTimeFilter<"sys_menu"> | Date | string
    updateAt?: DateTimeFilter<"sys_menu"> | Date | string
    name?: StringFilter<"sys_menu"> | string
    path?: StringFilter<"sys_menu"> | string
    powers?: IntFilter<"sys_menu"> | number
    comment?: StringNullableFilter<"sys_menu"> | string | null
    parentId?: StringNullableFilter<"sys_menu"> | string | null
  }

  export type sys_menu_on_roleUpsertWithWhereUniqueWithoutMenuInput = {
    where: sys_menu_on_roleWhereUniqueInput
    update: XOR<sys_menu_on_roleUpdateWithoutMenuInput, sys_menu_on_roleUncheckedUpdateWithoutMenuInput>
    create: XOR<sys_menu_on_roleCreateWithoutMenuInput, sys_menu_on_roleUncheckedCreateWithoutMenuInput>
  }

  export type sys_menu_on_roleUpdateWithWhereUniqueWithoutMenuInput = {
    where: sys_menu_on_roleWhereUniqueInput
    data: XOR<sys_menu_on_roleUpdateWithoutMenuInput, sys_menu_on_roleUncheckedUpdateWithoutMenuInput>
  }

  export type sys_menu_on_roleUpdateManyWithWhereWithoutMenuInput = {
    where: sys_menu_on_roleScalarWhereInput
    data: XOR<sys_menu_on_roleUpdateManyMutationInput, sys_menu_on_roleUncheckedUpdateManyWithoutMenuInput>
  }

  export type sys_menu_on_roleScalarWhereInput = {
    AND?: sys_menu_on_roleScalarWhereInput | sys_menu_on_roleScalarWhereInput[]
    OR?: sys_menu_on_roleScalarWhereInput[]
    NOT?: sys_menu_on_roleScalarWhereInput | sys_menu_on_roleScalarWhereInput[]
    roleId?: StringFilter<"sys_menu_on_role"> | string
    menuId?: StringFilter<"sys_menu_on_role"> | string
    power?: BigIntFilter<"sys_menu_on_role"> | bigint | number
  }

  export type sys_user_ban_menuUpsertWithWhereUniqueWithoutMenuInput = {
    where: sys_user_ban_menuWhereUniqueInput
    update: XOR<sys_user_ban_menuUpdateWithoutMenuInput, sys_user_ban_menuUncheckedUpdateWithoutMenuInput>
    create: XOR<sys_user_ban_menuCreateWithoutMenuInput, sys_user_ban_menuUncheckedCreateWithoutMenuInput>
  }

  export type sys_user_ban_menuUpdateWithWhereUniqueWithoutMenuInput = {
    where: sys_user_ban_menuWhereUniqueInput
    data: XOR<sys_user_ban_menuUpdateWithoutMenuInput, sys_user_ban_menuUncheckedUpdateWithoutMenuInput>
  }

  export type sys_user_ban_menuUpdateManyWithWhereWithoutMenuInput = {
    where: sys_user_ban_menuScalarWhereInput
    data: XOR<sys_user_ban_menuUpdateManyMutationInput, sys_user_ban_menuUncheckedUpdateManyWithoutMenuInput>
  }

  export type sys_userCreateWithoutBan_menusInput = {
    uid?: string
    createAt?: Date | string
    updateAt?: Date | string
    name: string
    password: string
    salt: string
    accounts?: sys_accountCreateNestedManyWithoutUserInput
    role?: sys_roleCreateNestedOneWithoutUsersInput
  }

  export type sys_userUncheckedCreateWithoutBan_menusInput = {
    uid?: string
    createAt?: Date | string
    updateAt?: Date | string
    name: string
    password: string
    salt: string
    roleId?: string | null
    accounts?: sys_accountUncheckedCreateNestedManyWithoutUserInput
  }

  export type sys_userCreateOrConnectWithoutBan_menusInput = {
    where: sys_userWhereUniqueInput
    create: XOR<sys_userCreateWithoutBan_menusInput, sys_userUncheckedCreateWithoutBan_menusInput>
  }

  export type sys_menuCreateWithoutUser_bansInput = {
    uid?: string
    createAt?: Date | string
    updateAt?: Date | string
    name: string
    path: string
    powers: number
    comment?: string | null
    parent?: sys_menuCreateNestedOneWithoutChildrenInput
    children?: sys_menuCreateNestedManyWithoutParentInput
    roles?: sys_menu_on_roleCreateNestedManyWithoutMenuInput
  }

  export type sys_menuUncheckedCreateWithoutUser_bansInput = {
    uid?: string
    createAt?: Date | string
    updateAt?: Date | string
    name: string
    path: string
    powers: number
    comment?: string | null
    parentId?: string | null
    children?: sys_menuUncheckedCreateNestedManyWithoutParentInput
    roles?: sys_menu_on_roleUncheckedCreateNestedManyWithoutMenuInput
  }

  export type sys_menuCreateOrConnectWithoutUser_bansInput = {
    where: sys_menuWhereUniqueInput
    create: XOR<sys_menuCreateWithoutUser_bansInput, sys_menuUncheckedCreateWithoutUser_bansInput>
  }

  export type sys_userUpsertWithoutBan_menusInput = {
    update: XOR<sys_userUpdateWithoutBan_menusInput, sys_userUncheckedUpdateWithoutBan_menusInput>
    create: XOR<sys_userCreateWithoutBan_menusInput, sys_userUncheckedCreateWithoutBan_menusInput>
    where?: sys_userWhereInput
  }

  export type sys_userUpdateToOneWithWhereWithoutBan_menusInput = {
    where?: sys_userWhereInput
    data: XOR<sys_userUpdateWithoutBan_menusInput, sys_userUncheckedUpdateWithoutBan_menusInput>
  }

  export type sys_userUpdateWithoutBan_menusInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    salt?: StringFieldUpdateOperationsInput | string
    accounts?: sys_accountUpdateManyWithoutUserNestedInput
    role?: sys_roleUpdateOneWithoutUsersNestedInput
  }

  export type sys_userUncheckedUpdateWithoutBan_menusInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    salt?: StringFieldUpdateOperationsInput | string
    roleId?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: sys_accountUncheckedUpdateManyWithoutUserNestedInput
  }

  export type sys_menuUpsertWithoutUser_bansInput = {
    update: XOR<sys_menuUpdateWithoutUser_bansInput, sys_menuUncheckedUpdateWithoutUser_bansInput>
    create: XOR<sys_menuCreateWithoutUser_bansInput, sys_menuUncheckedCreateWithoutUser_bansInput>
    where?: sys_menuWhereInput
  }

  export type sys_menuUpdateToOneWithWhereWithoutUser_bansInput = {
    where?: sys_menuWhereInput
    data: XOR<sys_menuUpdateWithoutUser_bansInput, sys_menuUncheckedUpdateWithoutUser_bansInput>
  }

  export type sys_menuUpdateWithoutUser_bansInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    powers?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    parent?: sys_menuUpdateOneWithoutChildrenNestedInput
    children?: sys_menuUpdateManyWithoutParentNestedInput
    roles?: sys_menu_on_roleUpdateManyWithoutMenuNestedInput
  }

  export type sys_menuUncheckedUpdateWithoutUser_bansInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    powers?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    children?: sys_menuUncheckedUpdateManyWithoutParentNestedInput
    roles?: sys_menu_on_roleUncheckedUpdateManyWithoutMenuNestedInput
  }

  export type sys_menuCreateWithoutRolesInput = {
    uid?: string
    createAt?: Date | string
    updateAt?: Date | string
    name: string
    path: string
    powers: number
    comment?: string | null
    parent?: sys_menuCreateNestedOneWithoutChildrenInput
    children?: sys_menuCreateNestedManyWithoutParentInput
    user_bans?: sys_user_ban_menuCreateNestedManyWithoutMenuInput
  }

  export type sys_menuUncheckedCreateWithoutRolesInput = {
    uid?: string
    createAt?: Date | string
    updateAt?: Date | string
    name: string
    path: string
    powers: number
    comment?: string | null
    parentId?: string | null
    children?: sys_menuUncheckedCreateNestedManyWithoutParentInput
    user_bans?: sys_user_ban_menuUncheckedCreateNestedManyWithoutMenuInput
  }

  export type sys_menuCreateOrConnectWithoutRolesInput = {
    where: sys_menuWhereUniqueInput
    create: XOR<sys_menuCreateWithoutRolesInput, sys_menuUncheckedCreateWithoutRolesInput>
  }

  export type sys_roleCreateWithoutMenusInput = {
    uid?: string
    createAt?: Date | string
    updateAt?: Date | string
    name: string
    status?: boolean
    comment?: string | null
    users?: sys_userCreateNestedManyWithoutRoleInput
  }

  export type sys_roleUncheckedCreateWithoutMenusInput = {
    uid?: string
    createAt?: Date | string
    updateAt?: Date | string
    name: string
    status?: boolean
    comment?: string | null
    users?: sys_userUncheckedCreateNestedManyWithoutRoleInput
  }

  export type sys_roleCreateOrConnectWithoutMenusInput = {
    where: sys_roleWhereUniqueInput
    create: XOR<sys_roleCreateWithoutMenusInput, sys_roleUncheckedCreateWithoutMenusInput>
  }

  export type sys_menuUpsertWithoutRolesInput = {
    update: XOR<sys_menuUpdateWithoutRolesInput, sys_menuUncheckedUpdateWithoutRolesInput>
    create: XOR<sys_menuCreateWithoutRolesInput, sys_menuUncheckedCreateWithoutRolesInput>
    where?: sys_menuWhereInput
  }

  export type sys_menuUpdateToOneWithWhereWithoutRolesInput = {
    where?: sys_menuWhereInput
    data: XOR<sys_menuUpdateWithoutRolesInput, sys_menuUncheckedUpdateWithoutRolesInput>
  }

  export type sys_menuUpdateWithoutRolesInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    powers?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    parent?: sys_menuUpdateOneWithoutChildrenNestedInput
    children?: sys_menuUpdateManyWithoutParentNestedInput
    user_bans?: sys_user_ban_menuUpdateManyWithoutMenuNestedInput
  }

  export type sys_menuUncheckedUpdateWithoutRolesInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    powers?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    children?: sys_menuUncheckedUpdateManyWithoutParentNestedInput
    user_bans?: sys_user_ban_menuUncheckedUpdateManyWithoutMenuNestedInput
  }

  export type sys_roleUpsertWithoutMenusInput = {
    update: XOR<sys_roleUpdateWithoutMenusInput, sys_roleUncheckedUpdateWithoutMenusInput>
    create: XOR<sys_roleCreateWithoutMenusInput, sys_roleUncheckedCreateWithoutMenusInput>
    where?: sys_roleWhereInput
  }

  export type sys_roleUpdateToOneWithWhereWithoutMenusInput = {
    where?: sys_roleWhereInput
    data: XOR<sys_roleUpdateWithoutMenusInput, sys_roleUncheckedUpdateWithoutMenusInput>
  }

  export type sys_roleUpdateWithoutMenusInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    users?: sys_userUpdateManyWithoutRoleNestedInput
  }

  export type sys_roleUncheckedUpdateWithoutMenusInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    users?: sys_userUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type sys_menu_on_roleCreateWithoutRoleInput = {
    power?: bigint | number
    menu: sys_menuCreateNestedOneWithoutRolesInput
  }

  export type sys_menu_on_roleUncheckedCreateWithoutRoleInput = {
    menuId: string
    power?: bigint | number
  }

  export type sys_menu_on_roleCreateOrConnectWithoutRoleInput = {
    where: sys_menu_on_roleWhereUniqueInput
    create: XOR<sys_menu_on_roleCreateWithoutRoleInput, sys_menu_on_roleUncheckedCreateWithoutRoleInput>
  }

  export type sys_menu_on_roleCreateManyRoleInputEnvelope = {
    data: sys_menu_on_roleCreateManyRoleInput | sys_menu_on_roleCreateManyRoleInput[]
    skipDuplicates?: boolean
  }

  export type sys_userCreateWithoutRoleInput = {
    uid?: string
    createAt?: Date | string
    updateAt?: Date | string
    name: string
    password: string
    salt: string
    accounts?: sys_accountCreateNestedManyWithoutUserInput
    ban_menus?: sys_user_ban_menuCreateNestedManyWithoutUserInput
  }

  export type sys_userUncheckedCreateWithoutRoleInput = {
    uid?: string
    createAt?: Date | string
    updateAt?: Date | string
    name: string
    password: string
    salt: string
    accounts?: sys_accountUncheckedCreateNestedManyWithoutUserInput
    ban_menus?: sys_user_ban_menuUncheckedCreateNestedManyWithoutUserInput
  }

  export type sys_userCreateOrConnectWithoutRoleInput = {
    where: sys_userWhereUniqueInput
    create: XOR<sys_userCreateWithoutRoleInput, sys_userUncheckedCreateWithoutRoleInput>
  }

  export type sys_userCreateManyRoleInputEnvelope = {
    data: sys_userCreateManyRoleInput | sys_userCreateManyRoleInput[]
    skipDuplicates?: boolean
  }

  export type sys_menu_on_roleUpsertWithWhereUniqueWithoutRoleInput = {
    where: sys_menu_on_roleWhereUniqueInput
    update: XOR<sys_menu_on_roleUpdateWithoutRoleInput, sys_menu_on_roleUncheckedUpdateWithoutRoleInput>
    create: XOR<sys_menu_on_roleCreateWithoutRoleInput, sys_menu_on_roleUncheckedCreateWithoutRoleInput>
  }

  export type sys_menu_on_roleUpdateWithWhereUniqueWithoutRoleInput = {
    where: sys_menu_on_roleWhereUniqueInput
    data: XOR<sys_menu_on_roleUpdateWithoutRoleInput, sys_menu_on_roleUncheckedUpdateWithoutRoleInput>
  }

  export type sys_menu_on_roleUpdateManyWithWhereWithoutRoleInput = {
    where: sys_menu_on_roleScalarWhereInput
    data: XOR<sys_menu_on_roleUpdateManyMutationInput, sys_menu_on_roleUncheckedUpdateManyWithoutRoleInput>
  }

  export type sys_userUpsertWithWhereUniqueWithoutRoleInput = {
    where: sys_userWhereUniqueInput
    update: XOR<sys_userUpdateWithoutRoleInput, sys_userUncheckedUpdateWithoutRoleInput>
    create: XOR<sys_userCreateWithoutRoleInput, sys_userUncheckedCreateWithoutRoleInput>
  }

  export type sys_userUpdateWithWhereUniqueWithoutRoleInput = {
    where: sys_userWhereUniqueInput
    data: XOR<sys_userUpdateWithoutRoleInput, sys_userUncheckedUpdateWithoutRoleInput>
  }

  export type sys_userUpdateManyWithWhereWithoutRoleInput = {
    where: sys_userScalarWhereInput
    data: XOR<sys_userUpdateManyMutationInput, sys_userUncheckedUpdateManyWithoutRoleInput>
  }

  export type sys_userScalarWhereInput = {
    AND?: sys_userScalarWhereInput | sys_userScalarWhereInput[]
    OR?: sys_userScalarWhereInput[]
    NOT?: sys_userScalarWhereInput | sys_userScalarWhereInput[]
    uid?: StringFilter<"sys_user"> | string
    createAt?: DateTimeFilter<"sys_user"> | Date | string
    updateAt?: DateTimeFilter<"sys_user"> | Date | string
    name?: StringFilter<"sys_user"> | string
    password?: StringFilter<"sys_user"> | string
    salt?: StringFilter<"sys_user"> | string
    roleId?: StringNullableFilter<"sys_user"> | string | null
  }

  export type blog_postsCreateWithoutUserInput = {
    uid?: string
    createAt?: Date | string
    updateAt?: Date | string
    title: string
    content: string
    categories?: blog_categoriesCreateNestedOneWithoutPostsInput
    tags?: blog_posts_on_tagsCreateNestedManyWithoutPostsInput
  }

  export type blog_postsUncheckedCreateWithoutUserInput = {
    uid?: string
    createAt?: Date | string
    updateAt?: Date | string
    title: string
    content: string
    categoriesId?: string | null
    tags?: blog_posts_on_tagsUncheckedCreateNestedManyWithoutPostsInput
  }

  export type blog_postsCreateOrConnectWithoutUserInput = {
    where: blog_postsWhereUniqueInput
    create: XOR<blog_postsCreateWithoutUserInput, blog_postsUncheckedCreateWithoutUserInput>
  }

  export type blog_postsCreateManyUserInputEnvelope = {
    data: blog_postsCreateManyUserInput | blog_postsCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type blog_postsUpsertWithWhereUniqueWithoutUserInput = {
    where: blog_postsWhereUniqueInput
    update: XOR<blog_postsUpdateWithoutUserInput, blog_postsUncheckedUpdateWithoutUserInput>
    create: XOR<blog_postsCreateWithoutUserInput, blog_postsUncheckedCreateWithoutUserInput>
  }

  export type blog_postsUpdateWithWhereUniqueWithoutUserInput = {
    where: blog_postsWhereUniqueInput
    data: XOR<blog_postsUpdateWithoutUserInput, blog_postsUncheckedUpdateWithoutUserInput>
  }

  export type blog_postsUpdateManyWithWhereWithoutUserInput = {
    where: blog_postsScalarWhereInput
    data: XOR<blog_postsUpdateManyMutationInput, blog_postsUncheckedUpdateManyWithoutUserInput>
  }

  export type blog_postsScalarWhereInput = {
    AND?: blog_postsScalarWhereInput | blog_postsScalarWhereInput[]
    OR?: blog_postsScalarWhereInput[]
    NOT?: blog_postsScalarWhereInput | blog_postsScalarWhereInput[]
    uid?: StringFilter<"blog_posts"> | string
    createAt?: DateTimeFilter<"blog_posts"> | Date | string
    updateAt?: DateTimeFilter<"blog_posts"> | Date | string
    title?: StringFilter<"blog_posts"> | string
    content?: StringFilter<"blog_posts"> | string
    userId?: StringFilter<"blog_posts"> | string
    categoriesId?: StringNullableFilter<"blog_posts"> | string | null
  }

  export type blog_postsCreateWithoutCategoriesInput = {
    uid?: string
    createAt?: Date | string
    updateAt?: Date | string
    title: string
    content: string
    user: blog_userCreateNestedOneWithoutPostsInput
    tags?: blog_posts_on_tagsCreateNestedManyWithoutPostsInput
  }

  export type blog_postsUncheckedCreateWithoutCategoriesInput = {
    uid?: string
    createAt?: Date | string
    updateAt?: Date | string
    title: string
    content: string
    userId: string
    tags?: blog_posts_on_tagsUncheckedCreateNestedManyWithoutPostsInput
  }

  export type blog_postsCreateOrConnectWithoutCategoriesInput = {
    where: blog_postsWhereUniqueInput
    create: XOR<blog_postsCreateWithoutCategoriesInput, blog_postsUncheckedCreateWithoutCategoriesInput>
  }

  export type blog_postsCreateManyCategoriesInputEnvelope = {
    data: blog_postsCreateManyCategoriesInput | blog_postsCreateManyCategoriesInput[]
    skipDuplicates?: boolean
  }

  export type blog_postsUpsertWithWhereUniqueWithoutCategoriesInput = {
    where: blog_postsWhereUniqueInput
    update: XOR<blog_postsUpdateWithoutCategoriesInput, blog_postsUncheckedUpdateWithoutCategoriesInput>
    create: XOR<blog_postsCreateWithoutCategoriesInput, blog_postsUncheckedCreateWithoutCategoriesInput>
  }

  export type blog_postsUpdateWithWhereUniqueWithoutCategoriesInput = {
    where: blog_postsWhereUniqueInput
    data: XOR<blog_postsUpdateWithoutCategoriesInput, blog_postsUncheckedUpdateWithoutCategoriesInput>
  }

  export type blog_postsUpdateManyWithWhereWithoutCategoriesInput = {
    where: blog_postsScalarWhereInput
    data: XOR<blog_postsUpdateManyMutationInput, blog_postsUncheckedUpdateManyWithoutCategoriesInput>
  }

  export type blog_categoriesCreateWithoutPostsInput = {
    uid?: string
    createAt?: Date | string
    updateAt?: Date | string
    name: string
  }

  export type blog_categoriesUncheckedCreateWithoutPostsInput = {
    uid?: string
    createAt?: Date | string
    updateAt?: Date | string
    name: string
  }

  export type blog_categoriesCreateOrConnectWithoutPostsInput = {
    where: blog_categoriesWhereUniqueInput
    create: XOR<blog_categoriesCreateWithoutPostsInput, blog_categoriesUncheckedCreateWithoutPostsInput>
  }

  export type blog_userCreateWithoutPostsInput = {
    uid?: string
    createAt?: Date | string
    updateAt?: Date | string
    name: string
  }

  export type blog_userUncheckedCreateWithoutPostsInput = {
    uid?: string
    createAt?: Date | string
    updateAt?: Date | string
    name: string
  }

  export type blog_userCreateOrConnectWithoutPostsInput = {
    where: blog_userWhereUniqueInput
    create: XOR<blog_userCreateWithoutPostsInput, blog_userUncheckedCreateWithoutPostsInput>
  }

  export type blog_posts_on_tagsCreateWithoutPostsInput = {
    tag: blog_tagCreateNestedOneWithoutBlog_posts_on_tagsInput
  }

  export type blog_posts_on_tagsUncheckedCreateWithoutPostsInput = {
    tagId: string
  }

  export type blog_posts_on_tagsCreateOrConnectWithoutPostsInput = {
    where: blog_posts_on_tagsWhereUniqueInput
    create: XOR<blog_posts_on_tagsCreateWithoutPostsInput, blog_posts_on_tagsUncheckedCreateWithoutPostsInput>
  }

  export type blog_posts_on_tagsCreateManyPostsInputEnvelope = {
    data: blog_posts_on_tagsCreateManyPostsInput | blog_posts_on_tagsCreateManyPostsInput[]
    skipDuplicates?: boolean
  }

  export type blog_categoriesUpsertWithoutPostsInput = {
    update: XOR<blog_categoriesUpdateWithoutPostsInput, blog_categoriesUncheckedUpdateWithoutPostsInput>
    create: XOR<blog_categoriesCreateWithoutPostsInput, blog_categoriesUncheckedCreateWithoutPostsInput>
    where?: blog_categoriesWhereInput
  }

  export type blog_categoriesUpdateToOneWithWhereWithoutPostsInput = {
    where?: blog_categoriesWhereInput
    data: XOR<blog_categoriesUpdateWithoutPostsInput, blog_categoriesUncheckedUpdateWithoutPostsInput>
  }

  export type blog_categoriesUpdateWithoutPostsInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type blog_categoriesUncheckedUpdateWithoutPostsInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type blog_userUpsertWithoutPostsInput = {
    update: XOR<blog_userUpdateWithoutPostsInput, blog_userUncheckedUpdateWithoutPostsInput>
    create: XOR<blog_userCreateWithoutPostsInput, blog_userUncheckedCreateWithoutPostsInput>
    where?: blog_userWhereInput
  }

  export type blog_userUpdateToOneWithWhereWithoutPostsInput = {
    where?: blog_userWhereInput
    data: XOR<blog_userUpdateWithoutPostsInput, blog_userUncheckedUpdateWithoutPostsInput>
  }

  export type blog_userUpdateWithoutPostsInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type blog_userUncheckedUpdateWithoutPostsInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type blog_posts_on_tagsUpsertWithWhereUniqueWithoutPostsInput = {
    where: blog_posts_on_tagsWhereUniqueInput
    update: XOR<blog_posts_on_tagsUpdateWithoutPostsInput, blog_posts_on_tagsUncheckedUpdateWithoutPostsInput>
    create: XOR<blog_posts_on_tagsCreateWithoutPostsInput, blog_posts_on_tagsUncheckedCreateWithoutPostsInput>
  }

  export type blog_posts_on_tagsUpdateWithWhereUniqueWithoutPostsInput = {
    where: blog_posts_on_tagsWhereUniqueInput
    data: XOR<blog_posts_on_tagsUpdateWithoutPostsInput, blog_posts_on_tagsUncheckedUpdateWithoutPostsInput>
  }

  export type blog_posts_on_tagsUpdateManyWithWhereWithoutPostsInput = {
    where: blog_posts_on_tagsScalarWhereInput
    data: XOR<blog_posts_on_tagsUpdateManyMutationInput, blog_posts_on_tagsUncheckedUpdateManyWithoutPostsInput>
  }

  export type blog_posts_on_tagsScalarWhereInput = {
    AND?: blog_posts_on_tagsScalarWhereInput | blog_posts_on_tagsScalarWhereInput[]
    OR?: blog_posts_on_tagsScalarWhereInput[]
    NOT?: blog_posts_on_tagsScalarWhereInput | blog_posts_on_tagsScalarWhereInput[]
    postsId?: StringFilter<"blog_posts_on_tags"> | string
    tagId?: StringFilter<"blog_posts_on_tags"> | string
  }

  export type blog_postsCreateWithoutTagsInput = {
    uid?: string
    createAt?: Date | string
    updateAt?: Date | string
    title: string
    content: string
    categories?: blog_categoriesCreateNestedOneWithoutPostsInput
    user: blog_userCreateNestedOneWithoutPostsInput
  }

  export type blog_postsUncheckedCreateWithoutTagsInput = {
    uid?: string
    createAt?: Date | string
    updateAt?: Date | string
    title: string
    content: string
    userId: string
    categoriesId?: string | null
  }

  export type blog_postsCreateOrConnectWithoutTagsInput = {
    where: blog_postsWhereUniqueInput
    create: XOR<blog_postsCreateWithoutTagsInput, blog_postsUncheckedCreateWithoutTagsInput>
  }

  export type blog_tagCreateWithoutBlog_posts_on_tagsInput = {
    uid?: string
    createAt?: Date | string
    updateAt?: Date | string
    name: string
  }

  export type blog_tagUncheckedCreateWithoutBlog_posts_on_tagsInput = {
    uid?: string
    createAt?: Date | string
    updateAt?: Date | string
    name: string
  }

  export type blog_tagCreateOrConnectWithoutBlog_posts_on_tagsInput = {
    where: blog_tagWhereUniqueInput
    create: XOR<blog_tagCreateWithoutBlog_posts_on_tagsInput, blog_tagUncheckedCreateWithoutBlog_posts_on_tagsInput>
  }

  export type blog_postsUpsertWithoutTagsInput = {
    update: XOR<blog_postsUpdateWithoutTagsInput, blog_postsUncheckedUpdateWithoutTagsInput>
    create: XOR<blog_postsCreateWithoutTagsInput, blog_postsUncheckedCreateWithoutTagsInput>
    where?: blog_postsWhereInput
  }

  export type blog_postsUpdateToOneWithWhereWithoutTagsInput = {
    where?: blog_postsWhereInput
    data: XOR<blog_postsUpdateWithoutTagsInput, blog_postsUncheckedUpdateWithoutTagsInput>
  }

  export type blog_postsUpdateWithoutTagsInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    categories?: blog_categoriesUpdateOneWithoutPostsNestedInput
    user?: blog_userUpdateOneRequiredWithoutPostsNestedInput
  }

  export type blog_postsUncheckedUpdateWithoutTagsInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    categoriesId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type blog_tagUpsertWithoutBlog_posts_on_tagsInput = {
    update: XOR<blog_tagUpdateWithoutBlog_posts_on_tagsInput, blog_tagUncheckedUpdateWithoutBlog_posts_on_tagsInput>
    create: XOR<blog_tagCreateWithoutBlog_posts_on_tagsInput, blog_tagUncheckedCreateWithoutBlog_posts_on_tagsInput>
    where?: blog_tagWhereInput
  }

  export type blog_tagUpdateToOneWithWhereWithoutBlog_posts_on_tagsInput = {
    where?: blog_tagWhereInput
    data: XOR<blog_tagUpdateWithoutBlog_posts_on_tagsInput, blog_tagUncheckedUpdateWithoutBlog_posts_on_tagsInput>
  }

  export type blog_tagUpdateWithoutBlog_posts_on_tagsInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type blog_tagUncheckedUpdateWithoutBlog_posts_on_tagsInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type blog_posts_on_tagsCreateWithoutTagInput = {
    posts: blog_postsCreateNestedOneWithoutTagsInput
  }

  export type blog_posts_on_tagsUncheckedCreateWithoutTagInput = {
    postsId: string
  }

  export type blog_posts_on_tagsCreateOrConnectWithoutTagInput = {
    where: blog_posts_on_tagsWhereUniqueInput
    create: XOR<blog_posts_on_tagsCreateWithoutTagInput, blog_posts_on_tagsUncheckedCreateWithoutTagInput>
  }

  export type blog_posts_on_tagsCreateManyTagInputEnvelope = {
    data: blog_posts_on_tagsCreateManyTagInput | blog_posts_on_tagsCreateManyTagInput[]
    skipDuplicates?: boolean
  }

  export type blog_posts_on_tagsUpsertWithWhereUniqueWithoutTagInput = {
    where: blog_posts_on_tagsWhereUniqueInput
    update: XOR<blog_posts_on_tagsUpdateWithoutTagInput, blog_posts_on_tagsUncheckedUpdateWithoutTagInput>
    create: XOR<blog_posts_on_tagsCreateWithoutTagInput, blog_posts_on_tagsUncheckedCreateWithoutTagInput>
  }

  export type blog_posts_on_tagsUpdateWithWhereUniqueWithoutTagInput = {
    where: blog_posts_on_tagsWhereUniqueInput
    data: XOR<blog_posts_on_tagsUpdateWithoutTagInput, blog_posts_on_tagsUncheckedUpdateWithoutTagInput>
  }

  export type blog_posts_on_tagsUpdateManyWithWhereWithoutTagInput = {
    where: blog_posts_on_tagsScalarWhereInput
    data: XOR<blog_posts_on_tagsUpdateManyMutationInput, blog_posts_on_tagsUncheckedUpdateManyWithoutTagInput>
  }

  export type file_user_on_mediaCreateWithoutUserInput = {
    comment?: string | null
    media: file_mediaCreateNestedOneWithoutUsersInput
  }

  export type file_user_on_mediaUncheckedCreateWithoutUserInput = {
    mediaId: string
    comment?: string | null
  }

  export type file_user_on_mediaCreateOrConnectWithoutUserInput = {
    where: file_user_on_mediaWhereUniqueInput
    create: XOR<file_user_on_mediaCreateWithoutUserInput, file_user_on_mediaUncheckedCreateWithoutUserInput>
  }

  export type file_user_on_mediaCreateManyUserInputEnvelope = {
    data: file_user_on_mediaCreateManyUserInput | file_user_on_mediaCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type file_folderCreateWithoutUserInput = {
    uid?: string
    createAt?: Date | string
    updateAt?: Date | string
    name: string
    parent?: file_folderCreateNestedOneWithoutChildrenInput
    children?: file_folderCreateNestedManyWithoutParentInput
    medias?: file_media_on_folderCreateNestedManyWithoutFolderInput
  }

  export type file_folderUncheckedCreateWithoutUserInput = {
    uid?: string
    createAt?: Date | string
    updateAt?: Date | string
    name: string
    parentId?: string | null
    children?: file_folderUncheckedCreateNestedManyWithoutParentInput
    medias?: file_media_on_folderUncheckedCreateNestedManyWithoutFolderInput
  }

  export type file_folderCreateOrConnectWithoutUserInput = {
    where: file_folderWhereUniqueInput
    create: XOR<file_folderCreateWithoutUserInput, file_folderUncheckedCreateWithoutUserInput>
  }

  export type file_folderCreateManyUserInputEnvelope = {
    data: file_folderCreateManyUserInput | file_folderCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type file_configCreateWithoutUserInput = {
    uid?: string
  }

  export type file_configUncheckedCreateWithoutUserInput = {
    uid?: string
  }

  export type file_configCreateOrConnectWithoutUserInput = {
    where: file_configWhereUniqueInput
    create: XOR<file_configCreateWithoutUserInput, file_configUncheckedCreateWithoutUserInput>
  }

  export type file_keysCreateWithoutUserInput = {
    api_key: string
    api_secret: string
  }

  export type file_keysUncheckedCreateWithoutUserInput = {
    api_key: string
    api_secret: string
  }

  export type file_keysCreateOrConnectWithoutUserInput = {
    where: file_keysWhereUniqueInput
    create: XOR<file_keysCreateWithoutUserInput, file_keysUncheckedCreateWithoutUserInput>
  }

  export type file_keysCreateManyUserInputEnvelope = {
    data: file_keysCreateManyUserInput | file_keysCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type file_user_on_mediaUpsertWithWhereUniqueWithoutUserInput = {
    where: file_user_on_mediaWhereUniqueInput
    update: XOR<file_user_on_mediaUpdateWithoutUserInput, file_user_on_mediaUncheckedUpdateWithoutUserInput>
    create: XOR<file_user_on_mediaCreateWithoutUserInput, file_user_on_mediaUncheckedCreateWithoutUserInput>
  }

  export type file_user_on_mediaUpdateWithWhereUniqueWithoutUserInput = {
    where: file_user_on_mediaWhereUniqueInput
    data: XOR<file_user_on_mediaUpdateWithoutUserInput, file_user_on_mediaUncheckedUpdateWithoutUserInput>
  }

  export type file_user_on_mediaUpdateManyWithWhereWithoutUserInput = {
    where: file_user_on_mediaScalarWhereInput
    data: XOR<file_user_on_mediaUpdateManyMutationInput, file_user_on_mediaUncheckedUpdateManyWithoutUserInput>
  }

  export type file_user_on_mediaScalarWhereInput = {
    AND?: file_user_on_mediaScalarWhereInput | file_user_on_mediaScalarWhereInput[]
    OR?: file_user_on_mediaScalarWhereInput[]
    NOT?: file_user_on_mediaScalarWhereInput | file_user_on_mediaScalarWhereInput[]
    userId?: StringFilter<"file_user_on_media"> | string
    mediaId?: StringFilter<"file_user_on_media"> | string
    comment?: StringNullableFilter<"file_user_on_media"> | string | null
  }

  export type file_folderUpsertWithWhereUniqueWithoutUserInput = {
    where: file_folderWhereUniqueInput
    update: XOR<file_folderUpdateWithoutUserInput, file_folderUncheckedUpdateWithoutUserInput>
    create: XOR<file_folderCreateWithoutUserInput, file_folderUncheckedCreateWithoutUserInput>
  }

  export type file_folderUpdateWithWhereUniqueWithoutUserInput = {
    where: file_folderWhereUniqueInput
    data: XOR<file_folderUpdateWithoutUserInput, file_folderUncheckedUpdateWithoutUserInput>
  }

  export type file_folderUpdateManyWithWhereWithoutUserInput = {
    where: file_folderScalarWhereInput
    data: XOR<file_folderUpdateManyMutationInput, file_folderUncheckedUpdateManyWithoutUserInput>
  }

  export type file_folderScalarWhereInput = {
    AND?: file_folderScalarWhereInput | file_folderScalarWhereInput[]
    OR?: file_folderScalarWhereInput[]
    NOT?: file_folderScalarWhereInput | file_folderScalarWhereInput[]
    uid?: StringFilter<"file_folder"> | string
    createAt?: DateTimeFilter<"file_folder"> | Date | string
    updateAt?: DateTimeFilter<"file_folder"> | Date | string
    name?: StringFilter<"file_folder"> | string
    userId?: StringFilter<"file_folder"> | string
    parentId?: StringNullableFilter<"file_folder"> | string | null
  }

  export type file_configUpsertWithoutUserInput = {
    update: XOR<file_configUpdateWithoutUserInput, file_configUncheckedUpdateWithoutUserInput>
    create: XOR<file_configCreateWithoutUserInput, file_configUncheckedCreateWithoutUserInput>
    where?: file_configWhereInput
  }

  export type file_configUpdateToOneWithWhereWithoutUserInput = {
    where?: file_configWhereInput
    data: XOR<file_configUpdateWithoutUserInput, file_configUncheckedUpdateWithoutUserInput>
  }

  export type file_configUpdateWithoutUserInput = {
    uid?: StringFieldUpdateOperationsInput | string
  }

  export type file_configUncheckedUpdateWithoutUserInput = {
    uid?: StringFieldUpdateOperationsInput | string
  }

  export type file_keysUpsertWithWhereUniqueWithoutUserInput = {
    where: file_keysWhereUniqueInput
    update: XOR<file_keysUpdateWithoutUserInput, file_keysUncheckedUpdateWithoutUserInput>
    create: XOR<file_keysCreateWithoutUserInput, file_keysUncheckedCreateWithoutUserInput>
  }

  export type file_keysUpdateWithWhereUniqueWithoutUserInput = {
    where: file_keysWhereUniqueInput
    data: XOR<file_keysUpdateWithoutUserInput, file_keysUncheckedUpdateWithoutUserInput>
  }

  export type file_keysUpdateManyWithWhereWithoutUserInput = {
    where: file_keysScalarWhereInput
    data: XOR<file_keysUpdateManyMutationInput, file_keysUncheckedUpdateManyWithoutUserInput>
  }

  export type file_keysScalarWhereInput = {
    AND?: file_keysScalarWhereInput | file_keysScalarWhereInput[]
    OR?: file_keysScalarWhereInput[]
    NOT?: file_keysScalarWhereInput | file_keysScalarWhereInput[]
    api_key?: StringFilter<"file_keys"> | string
    api_secret?: StringFilter<"file_keys"> | string
    userId?: StringFilter<"file_keys"> | string
  }

  export type file_userCreateWithoutKeysInput = {
    uid?: string
    createAt?: Date | string
    updateAt?: Date | string
    name: string
    is_admin?: boolean
    medias?: file_user_on_mediaCreateNestedManyWithoutUserInput
    folders?: file_folderCreateNestedManyWithoutUserInput
    file_config?: file_configCreateNestedOneWithoutUserInput
  }

  export type file_userUncheckedCreateWithoutKeysInput = {
    uid?: string
    createAt?: Date | string
    updateAt?: Date | string
    name: string
    is_admin?: boolean
    medias?: file_user_on_mediaUncheckedCreateNestedManyWithoutUserInput
    folders?: file_folderUncheckedCreateNestedManyWithoutUserInput
    file_config?: file_configUncheckedCreateNestedOneWithoutUserInput
  }

  export type file_userCreateOrConnectWithoutKeysInput = {
    where: file_userWhereUniqueInput
    create: XOR<file_userCreateWithoutKeysInput, file_userUncheckedCreateWithoutKeysInput>
  }

  export type file_userUpsertWithoutKeysInput = {
    update: XOR<file_userUpdateWithoutKeysInput, file_userUncheckedUpdateWithoutKeysInput>
    create: XOR<file_userCreateWithoutKeysInput, file_userUncheckedCreateWithoutKeysInput>
    where?: file_userWhereInput
  }

  export type file_userUpdateToOneWithWhereWithoutKeysInput = {
    where?: file_userWhereInput
    data: XOR<file_userUpdateWithoutKeysInput, file_userUncheckedUpdateWithoutKeysInput>
  }

  export type file_userUpdateWithoutKeysInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    is_admin?: BoolFieldUpdateOperationsInput | boolean
    medias?: file_user_on_mediaUpdateManyWithoutUserNestedInput
    folders?: file_folderUpdateManyWithoutUserNestedInput
    file_config?: file_configUpdateOneWithoutUserNestedInput
  }

  export type file_userUncheckedUpdateWithoutKeysInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    is_admin?: BoolFieldUpdateOperationsInput | boolean
    medias?: file_user_on_mediaUncheckedUpdateManyWithoutUserNestedInput
    folders?: file_folderUncheckedUpdateManyWithoutUserNestedInput
    file_config?: file_configUncheckedUpdateOneWithoutUserNestedInput
  }

  export type file_userCreateWithoutFile_configInput = {
    uid?: string
    createAt?: Date | string
    updateAt?: Date | string
    name: string
    is_admin?: boolean
    medias?: file_user_on_mediaCreateNestedManyWithoutUserInput
    folders?: file_folderCreateNestedManyWithoutUserInput
    keys?: file_keysCreateNestedManyWithoutUserInput
  }

  export type file_userUncheckedCreateWithoutFile_configInput = {
    uid?: string
    createAt?: Date | string
    updateAt?: Date | string
    name: string
    is_admin?: boolean
    medias?: file_user_on_mediaUncheckedCreateNestedManyWithoutUserInput
    folders?: file_folderUncheckedCreateNestedManyWithoutUserInput
    keys?: file_keysUncheckedCreateNestedManyWithoutUserInput
  }

  export type file_userCreateOrConnectWithoutFile_configInput = {
    where: file_userWhereUniqueInput
    create: XOR<file_userCreateWithoutFile_configInput, file_userUncheckedCreateWithoutFile_configInput>
  }

  export type file_userUpsertWithoutFile_configInput = {
    update: XOR<file_userUpdateWithoutFile_configInput, file_userUncheckedUpdateWithoutFile_configInput>
    create: XOR<file_userCreateWithoutFile_configInput, file_userUncheckedCreateWithoutFile_configInput>
    where?: file_userWhereInput
  }

  export type file_userUpdateToOneWithWhereWithoutFile_configInput = {
    where?: file_userWhereInput
    data: XOR<file_userUpdateWithoutFile_configInput, file_userUncheckedUpdateWithoutFile_configInput>
  }

  export type file_userUpdateWithoutFile_configInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    is_admin?: BoolFieldUpdateOperationsInput | boolean
    medias?: file_user_on_mediaUpdateManyWithoutUserNestedInput
    folders?: file_folderUpdateManyWithoutUserNestedInput
    keys?: file_keysUpdateManyWithoutUserNestedInput
  }

  export type file_userUncheckedUpdateWithoutFile_configInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    is_admin?: BoolFieldUpdateOperationsInput | boolean
    medias?: file_user_on_mediaUncheckedUpdateManyWithoutUserNestedInput
    folders?: file_folderUncheckedUpdateManyWithoutUserNestedInput
    keys?: file_keysUncheckedUpdateManyWithoutUserNestedInput
  }

  export type file_userCreateWithoutMediasInput = {
    uid?: string
    createAt?: Date | string
    updateAt?: Date | string
    name: string
    is_admin?: boolean
    folders?: file_folderCreateNestedManyWithoutUserInput
    file_config?: file_configCreateNestedOneWithoutUserInput
    keys?: file_keysCreateNestedManyWithoutUserInput
  }

  export type file_userUncheckedCreateWithoutMediasInput = {
    uid?: string
    createAt?: Date | string
    updateAt?: Date | string
    name: string
    is_admin?: boolean
    folders?: file_folderUncheckedCreateNestedManyWithoutUserInput
    file_config?: file_configUncheckedCreateNestedOneWithoutUserInput
    keys?: file_keysUncheckedCreateNestedManyWithoutUserInput
  }

  export type file_userCreateOrConnectWithoutMediasInput = {
    where: file_userWhereUniqueInput
    create: XOR<file_userCreateWithoutMediasInput, file_userUncheckedCreateWithoutMediasInput>
  }

  export type file_mediaCreateWithoutUsersInput = {
    uid?: string
    createAt?: Date | string
    updateAt?: Date | string
    type: $Enums.file_type
    name: string
    hash_key: string
    size: number
    disable?: boolean
    comment?: string | null
    blocks?: file_blockCreateNestedManyWithoutMediaInput
    folders?: file_media_on_folderCreateNestedManyWithoutMediaInput
  }

  export type file_mediaUncheckedCreateWithoutUsersInput = {
    uid?: string
    createAt?: Date | string
    updateAt?: Date | string
    type: $Enums.file_type
    name: string
    hash_key: string
    size: number
    disable?: boolean
    comment?: string | null
    blocks?: file_blockUncheckedCreateNestedManyWithoutMediaInput
    folders?: file_media_on_folderUncheckedCreateNestedManyWithoutMediaInput
  }

  export type file_mediaCreateOrConnectWithoutUsersInput = {
    where: file_mediaWhereUniqueInput
    create: XOR<file_mediaCreateWithoutUsersInput, file_mediaUncheckedCreateWithoutUsersInput>
  }

  export type file_userUpsertWithoutMediasInput = {
    update: XOR<file_userUpdateWithoutMediasInput, file_userUncheckedUpdateWithoutMediasInput>
    create: XOR<file_userCreateWithoutMediasInput, file_userUncheckedCreateWithoutMediasInput>
    where?: file_userWhereInput
  }

  export type file_userUpdateToOneWithWhereWithoutMediasInput = {
    where?: file_userWhereInput
    data: XOR<file_userUpdateWithoutMediasInput, file_userUncheckedUpdateWithoutMediasInput>
  }

  export type file_userUpdateWithoutMediasInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    is_admin?: BoolFieldUpdateOperationsInput | boolean
    folders?: file_folderUpdateManyWithoutUserNestedInput
    file_config?: file_configUpdateOneWithoutUserNestedInput
    keys?: file_keysUpdateManyWithoutUserNestedInput
  }

  export type file_userUncheckedUpdateWithoutMediasInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    is_admin?: BoolFieldUpdateOperationsInput | boolean
    folders?: file_folderUncheckedUpdateManyWithoutUserNestedInput
    file_config?: file_configUncheckedUpdateOneWithoutUserNestedInput
    keys?: file_keysUncheckedUpdateManyWithoutUserNestedInput
  }

  export type file_mediaUpsertWithoutUsersInput = {
    update: XOR<file_mediaUpdateWithoutUsersInput, file_mediaUncheckedUpdateWithoutUsersInput>
    create: XOR<file_mediaCreateWithoutUsersInput, file_mediaUncheckedCreateWithoutUsersInput>
    where?: file_mediaWhereInput
  }

  export type file_mediaUpdateToOneWithWhereWithoutUsersInput = {
    where?: file_mediaWhereInput
    data: XOR<file_mediaUpdateWithoutUsersInput, file_mediaUncheckedUpdateWithoutUsersInput>
  }

  export type file_mediaUpdateWithoutUsersInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: Enumfile_typeFieldUpdateOperationsInput | $Enums.file_type
    name?: StringFieldUpdateOperationsInput | string
    hash_key?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    disable?: BoolFieldUpdateOperationsInput | boolean
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    blocks?: file_blockUpdateManyWithoutMediaNestedInput
    folders?: file_media_on_folderUpdateManyWithoutMediaNestedInput
  }

  export type file_mediaUncheckedUpdateWithoutUsersInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: Enumfile_typeFieldUpdateOperationsInput | $Enums.file_type
    name?: StringFieldUpdateOperationsInput | string
    hash_key?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    disable?: BoolFieldUpdateOperationsInput | boolean
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    blocks?: file_blockUncheckedUpdateManyWithoutMediaNestedInput
    folders?: file_media_on_folderUncheckedUpdateManyWithoutMediaNestedInput
  }

  export type file_mediaCreateWithoutBlocksInput = {
    uid?: string
    createAt?: Date | string
    updateAt?: Date | string
    type: $Enums.file_type
    name: string
    hash_key: string
    size: number
    disable?: boolean
    comment?: string | null
    users?: file_user_on_mediaCreateNestedManyWithoutMediaInput
    folders?: file_media_on_folderCreateNestedManyWithoutMediaInput
  }

  export type file_mediaUncheckedCreateWithoutBlocksInput = {
    uid?: string
    createAt?: Date | string
    updateAt?: Date | string
    type: $Enums.file_type
    name: string
    hash_key: string
    size: number
    disable?: boolean
    comment?: string | null
    users?: file_user_on_mediaUncheckedCreateNestedManyWithoutMediaInput
    folders?: file_media_on_folderUncheckedCreateNestedManyWithoutMediaInput
  }

  export type file_mediaCreateOrConnectWithoutBlocksInput = {
    where: file_mediaWhereUniqueInput
    create: XOR<file_mediaCreateWithoutBlocksInput, file_mediaUncheckedCreateWithoutBlocksInput>
  }

  export type file_mediaUpsertWithoutBlocksInput = {
    update: XOR<file_mediaUpdateWithoutBlocksInput, file_mediaUncheckedUpdateWithoutBlocksInput>
    create: XOR<file_mediaCreateWithoutBlocksInput, file_mediaUncheckedCreateWithoutBlocksInput>
    where?: file_mediaWhereInput
  }

  export type file_mediaUpdateToOneWithWhereWithoutBlocksInput = {
    where?: file_mediaWhereInput
    data: XOR<file_mediaUpdateWithoutBlocksInput, file_mediaUncheckedUpdateWithoutBlocksInput>
  }

  export type file_mediaUpdateWithoutBlocksInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: Enumfile_typeFieldUpdateOperationsInput | $Enums.file_type
    name?: StringFieldUpdateOperationsInput | string
    hash_key?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    disable?: BoolFieldUpdateOperationsInput | boolean
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    users?: file_user_on_mediaUpdateManyWithoutMediaNestedInput
    folders?: file_media_on_folderUpdateManyWithoutMediaNestedInput
  }

  export type file_mediaUncheckedUpdateWithoutBlocksInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: Enumfile_typeFieldUpdateOperationsInput | $Enums.file_type
    name?: StringFieldUpdateOperationsInput | string
    hash_key?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    disable?: BoolFieldUpdateOperationsInput | boolean
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    users?: file_user_on_mediaUncheckedUpdateManyWithoutMediaNestedInput
    folders?: file_media_on_folderUncheckedUpdateManyWithoutMediaNestedInput
  }

  export type file_blockCreateWithoutMediaInput = {
    uid?: string
    createAt?: Date | string
    updateAt?: Date | string
    hash_key: string
    size: number
  }

  export type file_blockUncheckedCreateWithoutMediaInput = {
    uid?: string
    createAt?: Date | string
    updateAt?: Date | string
    hash_key: string
    size: number
  }

  export type file_blockCreateOrConnectWithoutMediaInput = {
    where: file_blockWhereUniqueInput
    create: XOR<file_blockCreateWithoutMediaInput, file_blockUncheckedCreateWithoutMediaInput>
  }

  export type file_blockCreateManyMediaInputEnvelope = {
    data: file_blockCreateManyMediaInput | file_blockCreateManyMediaInput[]
    skipDuplicates?: boolean
  }

  export type file_user_on_mediaCreateWithoutMediaInput = {
    comment?: string | null
    user: file_userCreateNestedOneWithoutMediasInput
  }

  export type file_user_on_mediaUncheckedCreateWithoutMediaInput = {
    userId: string
    comment?: string | null
  }

  export type file_user_on_mediaCreateOrConnectWithoutMediaInput = {
    where: file_user_on_mediaWhereUniqueInput
    create: XOR<file_user_on_mediaCreateWithoutMediaInput, file_user_on_mediaUncheckedCreateWithoutMediaInput>
  }

  export type file_user_on_mediaCreateManyMediaInputEnvelope = {
    data: file_user_on_mediaCreateManyMediaInput | file_user_on_mediaCreateManyMediaInput[]
    skipDuplicates?: boolean
  }

  export type file_media_on_folderCreateWithoutMediaInput = {
    folder: file_folderCreateNestedOneWithoutMediasInput
  }

  export type file_media_on_folderUncheckedCreateWithoutMediaInput = {
    folderId: string
  }

  export type file_media_on_folderCreateOrConnectWithoutMediaInput = {
    where: file_media_on_folderWhereUniqueInput
    create: XOR<file_media_on_folderCreateWithoutMediaInput, file_media_on_folderUncheckedCreateWithoutMediaInput>
  }

  export type file_media_on_folderCreateManyMediaInputEnvelope = {
    data: file_media_on_folderCreateManyMediaInput | file_media_on_folderCreateManyMediaInput[]
    skipDuplicates?: boolean
  }

  export type file_blockUpsertWithWhereUniqueWithoutMediaInput = {
    where: file_blockWhereUniqueInput
    update: XOR<file_blockUpdateWithoutMediaInput, file_blockUncheckedUpdateWithoutMediaInput>
    create: XOR<file_blockCreateWithoutMediaInput, file_blockUncheckedCreateWithoutMediaInput>
  }

  export type file_blockUpdateWithWhereUniqueWithoutMediaInput = {
    where: file_blockWhereUniqueInput
    data: XOR<file_blockUpdateWithoutMediaInput, file_blockUncheckedUpdateWithoutMediaInput>
  }

  export type file_blockUpdateManyWithWhereWithoutMediaInput = {
    where: file_blockScalarWhereInput
    data: XOR<file_blockUpdateManyMutationInput, file_blockUncheckedUpdateManyWithoutMediaInput>
  }

  export type file_blockScalarWhereInput = {
    AND?: file_blockScalarWhereInput | file_blockScalarWhereInput[]
    OR?: file_blockScalarWhereInput[]
    NOT?: file_blockScalarWhereInput | file_blockScalarWhereInput[]
    uid?: StringFilter<"file_block"> | string
    createAt?: DateTimeFilter<"file_block"> | Date | string
    updateAt?: DateTimeFilter<"file_block"> | Date | string
    mediaId?: StringFilter<"file_block"> | string
    hash_key?: StringFilter<"file_block"> | string
    size?: IntFilter<"file_block"> | number
  }

  export type file_user_on_mediaUpsertWithWhereUniqueWithoutMediaInput = {
    where: file_user_on_mediaWhereUniqueInput
    update: XOR<file_user_on_mediaUpdateWithoutMediaInput, file_user_on_mediaUncheckedUpdateWithoutMediaInput>
    create: XOR<file_user_on_mediaCreateWithoutMediaInput, file_user_on_mediaUncheckedCreateWithoutMediaInput>
  }

  export type file_user_on_mediaUpdateWithWhereUniqueWithoutMediaInput = {
    where: file_user_on_mediaWhereUniqueInput
    data: XOR<file_user_on_mediaUpdateWithoutMediaInput, file_user_on_mediaUncheckedUpdateWithoutMediaInput>
  }

  export type file_user_on_mediaUpdateManyWithWhereWithoutMediaInput = {
    where: file_user_on_mediaScalarWhereInput
    data: XOR<file_user_on_mediaUpdateManyMutationInput, file_user_on_mediaUncheckedUpdateManyWithoutMediaInput>
  }

  export type file_media_on_folderUpsertWithWhereUniqueWithoutMediaInput = {
    where: file_media_on_folderWhereUniqueInput
    update: XOR<file_media_on_folderUpdateWithoutMediaInput, file_media_on_folderUncheckedUpdateWithoutMediaInput>
    create: XOR<file_media_on_folderCreateWithoutMediaInput, file_media_on_folderUncheckedCreateWithoutMediaInput>
  }

  export type file_media_on_folderUpdateWithWhereUniqueWithoutMediaInput = {
    where: file_media_on_folderWhereUniqueInput
    data: XOR<file_media_on_folderUpdateWithoutMediaInput, file_media_on_folderUncheckedUpdateWithoutMediaInput>
  }

  export type file_media_on_folderUpdateManyWithWhereWithoutMediaInput = {
    where: file_media_on_folderScalarWhereInput
    data: XOR<file_media_on_folderUpdateManyMutationInput, file_media_on_folderUncheckedUpdateManyWithoutMediaInput>
  }

  export type file_media_on_folderScalarWhereInput = {
    AND?: file_media_on_folderScalarWhereInput | file_media_on_folderScalarWhereInput[]
    OR?: file_media_on_folderScalarWhereInput[]
    NOT?: file_media_on_folderScalarWhereInput | file_media_on_folderScalarWhereInput[]
    mediaId?: StringFilter<"file_media_on_folder"> | string
    folderId?: StringFilter<"file_media_on_folder"> | string
  }

  export type file_mediaCreateWithoutFoldersInput = {
    uid?: string
    createAt?: Date | string
    updateAt?: Date | string
    type: $Enums.file_type
    name: string
    hash_key: string
    size: number
    disable?: boolean
    comment?: string | null
    blocks?: file_blockCreateNestedManyWithoutMediaInput
    users?: file_user_on_mediaCreateNestedManyWithoutMediaInput
  }

  export type file_mediaUncheckedCreateWithoutFoldersInput = {
    uid?: string
    createAt?: Date | string
    updateAt?: Date | string
    type: $Enums.file_type
    name: string
    hash_key: string
    size: number
    disable?: boolean
    comment?: string | null
    blocks?: file_blockUncheckedCreateNestedManyWithoutMediaInput
    users?: file_user_on_mediaUncheckedCreateNestedManyWithoutMediaInput
  }

  export type file_mediaCreateOrConnectWithoutFoldersInput = {
    where: file_mediaWhereUniqueInput
    create: XOR<file_mediaCreateWithoutFoldersInput, file_mediaUncheckedCreateWithoutFoldersInput>
  }

  export type file_folderCreateWithoutMediasInput = {
    uid?: string
    createAt?: Date | string
    updateAt?: Date | string
    name: string
    user: file_userCreateNestedOneWithoutFoldersInput
    parent?: file_folderCreateNestedOneWithoutChildrenInput
    children?: file_folderCreateNestedManyWithoutParentInput
  }

  export type file_folderUncheckedCreateWithoutMediasInput = {
    uid?: string
    createAt?: Date | string
    updateAt?: Date | string
    name: string
    userId: string
    parentId?: string | null
    children?: file_folderUncheckedCreateNestedManyWithoutParentInput
  }

  export type file_folderCreateOrConnectWithoutMediasInput = {
    where: file_folderWhereUniqueInput
    create: XOR<file_folderCreateWithoutMediasInput, file_folderUncheckedCreateWithoutMediasInput>
  }

  export type file_mediaUpsertWithoutFoldersInput = {
    update: XOR<file_mediaUpdateWithoutFoldersInput, file_mediaUncheckedUpdateWithoutFoldersInput>
    create: XOR<file_mediaCreateWithoutFoldersInput, file_mediaUncheckedCreateWithoutFoldersInput>
    where?: file_mediaWhereInput
  }

  export type file_mediaUpdateToOneWithWhereWithoutFoldersInput = {
    where?: file_mediaWhereInput
    data: XOR<file_mediaUpdateWithoutFoldersInput, file_mediaUncheckedUpdateWithoutFoldersInput>
  }

  export type file_mediaUpdateWithoutFoldersInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: Enumfile_typeFieldUpdateOperationsInput | $Enums.file_type
    name?: StringFieldUpdateOperationsInput | string
    hash_key?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    disable?: BoolFieldUpdateOperationsInput | boolean
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    blocks?: file_blockUpdateManyWithoutMediaNestedInput
    users?: file_user_on_mediaUpdateManyWithoutMediaNestedInput
  }

  export type file_mediaUncheckedUpdateWithoutFoldersInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: Enumfile_typeFieldUpdateOperationsInput | $Enums.file_type
    name?: StringFieldUpdateOperationsInput | string
    hash_key?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    disable?: BoolFieldUpdateOperationsInput | boolean
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    blocks?: file_blockUncheckedUpdateManyWithoutMediaNestedInput
    users?: file_user_on_mediaUncheckedUpdateManyWithoutMediaNestedInput
  }

  export type file_folderUpsertWithoutMediasInput = {
    update: XOR<file_folderUpdateWithoutMediasInput, file_folderUncheckedUpdateWithoutMediasInput>
    create: XOR<file_folderCreateWithoutMediasInput, file_folderUncheckedCreateWithoutMediasInput>
    where?: file_folderWhereInput
  }

  export type file_folderUpdateToOneWithWhereWithoutMediasInput = {
    where?: file_folderWhereInput
    data: XOR<file_folderUpdateWithoutMediasInput, file_folderUncheckedUpdateWithoutMediasInput>
  }

  export type file_folderUpdateWithoutMediasInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    user?: file_userUpdateOneRequiredWithoutFoldersNestedInput
    parent?: file_folderUpdateOneWithoutChildrenNestedInput
    children?: file_folderUpdateManyWithoutParentNestedInput
  }

  export type file_folderUncheckedUpdateWithoutMediasInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    children?: file_folderUncheckedUpdateManyWithoutParentNestedInput
  }

  export type file_userCreateWithoutFoldersInput = {
    uid?: string
    createAt?: Date | string
    updateAt?: Date | string
    name: string
    is_admin?: boolean
    medias?: file_user_on_mediaCreateNestedManyWithoutUserInput
    file_config?: file_configCreateNestedOneWithoutUserInput
    keys?: file_keysCreateNestedManyWithoutUserInput
  }

  export type file_userUncheckedCreateWithoutFoldersInput = {
    uid?: string
    createAt?: Date | string
    updateAt?: Date | string
    name: string
    is_admin?: boolean
    medias?: file_user_on_mediaUncheckedCreateNestedManyWithoutUserInput
    file_config?: file_configUncheckedCreateNestedOneWithoutUserInput
    keys?: file_keysUncheckedCreateNestedManyWithoutUserInput
  }

  export type file_userCreateOrConnectWithoutFoldersInput = {
    where: file_userWhereUniqueInput
    create: XOR<file_userCreateWithoutFoldersInput, file_userUncheckedCreateWithoutFoldersInput>
  }

  export type file_folderCreateWithoutChildrenInput = {
    uid?: string
    createAt?: Date | string
    updateAt?: Date | string
    name: string
    user: file_userCreateNestedOneWithoutFoldersInput
    parent?: file_folderCreateNestedOneWithoutChildrenInput
    medias?: file_media_on_folderCreateNestedManyWithoutFolderInput
  }

  export type file_folderUncheckedCreateWithoutChildrenInput = {
    uid?: string
    createAt?: Date | string
    updateAt?: Date | string
    name: string
    userId: string
    parentId?: string | null
    medias?: file_media_on_folderUncheckedCreateNestedManyWithoutFolderInput
  }

  export type file_folderCreateOrConnectWithoutChildrenInput = {
    where: file_folderWhereUniqueInput
    create: XOR<file_folderCreateWithoutChildrenInput, file_folderUncheckedCreateWithoutChildrenInput>
  }

  export type file_folderCreateWithoutParentInput = {
    uid?: string
    createAt?: Date | string
    updateAt?: Date | string
    name: string
    user: file_userCreateNestedOneWithoutFoldersInput
    children?: file_folderCreateNestedManyWithoutParentInput
    medias?: file_media_on_folderCreateNestedManyWithoutFolderInput
  }

  export type file_folderUncheckedCreateWithoutParentInput = {
    uid?: string
    createAt?: Date | string
    updateAt?: Date | string
    name: string
    userId: string
    children?: file_folderUncheckedCreateNestedManyWithoutParentInput
    medias?: file_media_on_folderUncheckedCreateNestedManyWithoutFolderInput
  }

  export type file_folderCreateOrConnectWithoutParentInput = {
    where: file_folderWhereUniqueInput
    create: XOR<file_folderCreateWithoutParentInput, file_folderUncheckedCreateWithoutParentInput>
  }

  export type file_folderCreateManyParentInputEnvelope = {
    data: file_folderCreateManyParentInput | file_folderCreateManyParentInput[]
    skipDuplicates?: boolean
  }

  export type file_media_on_folderCreateWithoutFolderInput = {
    media: file_mediaCreateNestedOneWithoutFoldersInput
  }

  export type file_media_on_folderUncheckedCreateWithoutFolderInput = {
    mediaId: string
  }

  export type file_media_on_folderCreateOrConnectWithoutFolderInput = {
    where: file_media_on_folderWhereUniqueInput
    create: XOR<file_media_on_folderCreateWithoutFolderInput, file_media_on_folderUncheckedCreateWithoutFolderInput>
  }

  export type file_media_on_folderCreateManyFolderInputEnvelope = {
    data: file_media_on_folderCreateManyFolderInput | file_media_on_folderCreateManyFolderInput[]
    skipDuplicates?: boolean
  }

  export type file_userUpsertWithoutFoldersInput = {
    update: XOR<file_userUpdateWithoutFoldersInput, file_userUncheckedUpdateWithoutFoldersInput>
    create: XOR<file_userCreateWithoutFoldersInput, file_userUncheckedCreateWithoutFoldersInput>
    where?: file_userWhereInput
  }

  export type file_userUpdateToOneWithWhereWithoutFoldersInput = {
    where?: file_userWhereInput
    data: XOR<file_userUpdateWithoutFoldersInput, file_userUncheckedUpdateWithoutFoldersInput>
  }

  export type file_userUpdateWithoutFoldersInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    is_admin?: BoolFieldUpdateOperationsInput | boolean
    medias?: file_user_on_mediaUpdateManyWithoutUserNestedInput
    file_config?: file_configUpdateOneWithoutUserNestedInput
    keys?: file_keysUpdateManyWithoutUserNestedInput
  }

  export type file_userUncheckedUpdateWithoutFoldersInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    is_admin?: BoolFieldUpdateOperationsInput | boolean
    medias?: file_user_on_mediaUncheckedUpdateManyWithoutUserNestedInput
    file_config?: file_configUncheckedUpdateOneWithoutUserNestedInput
    keys?: file_keysUncheckedUpdateManyWithoutUserNestedInput
  }

  export type file_folderUpsertWithoutChildrenInput = {
    update: XOR<file_folderUpdateWithoutChildrenInput, file_folderUncheckedUpdateWithoutChildrenInput>
    create: XOR<file_folderCreateWithoutChildrenInput, file_folderUncheckedCreateWithoutChildrenInput>
    where?: file_folderWhereInput
  }

  export type file_folderUpdateToOneWithWhereWithoutChildrenInput = {
    where?: file_folderWhereInput
    data: XOR<file_folderUpdateWithoutChildrenInput, file_folderUncheckedUpdateWithoutChildrenInput>
  }

  export type file_folderUpdateWithoutChildrenInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    user?: file_userUpdateOneRequiredWithoutFoldersNestedInput
    parent?: file_folderUpdateOneWithoutChildrenNestedInput
    medias?: file_media_on_folderUpdateManyWithoutFolderNestedInput
  }

  export type file_folderUncheckedUpdateWithoutChildrenInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    medias?: file_media_on_folderUncheckedUpdateManyWithoutFolderNestedInput
  }

  export type file_folderUpsertWithWhereUniqueWithoutParentInput = {
    where: file_folderWhereUniqueInput
    update: XOR<file_folderUpdateWithoutParentInput, file_folderUncheckedUpdateWithoutParentInput>
    create: XOR<file_folderCreateWithoutParentInput, file_folderUncheckedCreateWithoutParentInput>
  }

  export type file_folderUpdateWithWhereUniqueWithoutParentInput = {
    where: file_folderWhereUniqueInput
    data: XOR<file_folderUpdateWithoutParentInput, file_folderUncheckedUpdateWithoutParentInput>
  }

  export type file_folderUpdateManyWithWhereWithoutParentInput = {
    where: file_folderScalarWhereInput
    data: XOR<file_folderUpdateManyMutationInput, file_folderUncheckedUpdateManyWithoutParentInput>
  }

  export type file_media_on_folderUpsertWithWhereUniqueWithoutFolderInput = {
    where: file_media_on_folderWhereUniqueInput
    update: XOR<file_media_on_folderUpdateWithoutFolderInput, file_media_on_folderUncheckedUpdateWithoutFolderInput>
    create: XOR<file_media_on_folderCreateWithoutFolderInput, file_media_on_folderUncheckedCreateWithoutFolderInput>
  }

  export type file_media_on_folderUpdateWithWhereUniqueWithoutFolderInput = {
    where: file_media_on_folderWhereUniqueInput
    data: XOR<file_media_on_folderUpdateWithoutFolderInput, file_media_on_folderUncheckedUpdateWithoutFolderInput>
  }

  export type file_media_on_folderUpdateManyWithWhereWithoutFolderInput = {
    where: file_media_on_folderScalarWhereInput
    data: XOR<file_media_on_folderUpdateManyMutationInput, file_media_on_folderUncheckedUpdateManyWithoutFolderInput>
  }

  export type book_borrowedCreateWithoutUserInput = {
    id?: string
    borrowDate?: Date | string
    returnDate?: Date | string | null
    dueDate: Date | string
    returned?: boolean
    book: book_bookCreateNestedOneWithoutBorrowedInput
  }

  export type book_borrowedUncheckedCreateWithoutUserInput = {
    id?: string
    borrowDate?: Date | string
    returnDate?: Date | string | null
    dueDate: Date | string
    bookId: string
    returned?: boolean
  }

  export type book_borrowedCreateOrConnectWithoutUserInput = {
    where: book_borrowedWhereUniqueInput
    create: XOR<book_borrowedCreateWithoutUserInput, book_borrowedUncheckedCreateWithoutUserInput>
  }

  export type book_borrowedCreateManyUserInputEnvelope = {
    data: book_borrowedCreateManyUserInput | book_borrowedCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type book_borrow_historyCreateWithoutUserInput = {
    id?: string
    borrowDate?: Date | string
    returnDate?: Date | string | null
    returned?: boolean
    book: book_bookCreateNestedOneWithoutBook_borrow_historyInput
  }

  export type book_borrow_historyUncheckedCreateWithoutUserInput = {
    id?: string
    borrowDate?: Date | string
    returnDate?: Date | string | null
    bookId: string
    returned?: boolean
  }

  export type book_borrow_historyCreateOrConnectWithoutUserInput = {
    where: book_borrow_historyWhereUniqueInput
    create: XOR<book_borrow_historyCreateWithoutUserInput, book_borrow_historyUncheckedCreateWithoutUserInput>
  }

  export type book_borrow_historyCreateManyUserInputEnvelope = {
    data: book_borrow_historyCreateManyUserInput | book_borrow_historyCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type book_ratingCreateWithoutUserInput = {
    id?: string
    createAt?: Date | string
    updateAt?: Date | string
    rating: number
    review?: string | null
    book: book_bookCreateNestedOneWithoutBook_ratingInput
  }

  export type book_ratingUncheckedCreateWithoutUserInput = {
    id?: string
    createAt?: Date | string
    updateAt?: Date | string
    rating: number
    review?: string | null
    bookId: string
  }

  export type book_ratingCreateOrConnectWithoutUserInput = {
    where: book_ratingWhereUniqueInput
    create: XOR<book_ratingCreateWithoutUserInput, book_ratingUncheckedCreateWithoutUserInput>
  }

  export type book_ratingCreateManyUserInputEnvelope = {
    data: book_ratingCreateManyUserInput | book_ratingCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type book_borrowedUpsertWithWhereUniqueWithoutUserInput = {
    where: book_borrowedWhereUniqueInput
    update: XOR<book_borrowedUpdateWithoutUserInput, book_borrowedUncheckedUpdateWithoutUserInput>
    create: XOR<book_borrowedCreateWithoutUserInput, book_borrowedUncheckedCreateWithoutUserInput>
  }

  export type book_borrowedUpdateWithWhereUniqueWithoutUserInput = {
    where: book_borrowedWhereUniqueInput
    data: XOR<book_borrowedUpdateWithoutUserInput, book_borrowedUncheckedUpdateWithoutUserInput>
  }

  export type book_borrowedUpdateManyWithWhereWithoutUserInput = {
    where: book_borrowedScalarWhereInput
    data: XOR<book_borrowedUpdateManyMutationInput, book_borrowedUncheckedUpdateManyWithoutUserInput>
  }

  export type book_borrowedScalarWhereInput = {
    AND?: book_borrowedScalarWhereInput | book_borrowedScalarWhereInput[]
    OR?: book_borrowedScalarWhereInput[]
    NOT?: book_borrowedScalarWhereInput | book_borrowedScalarWhereInput[]
    id?: StringFilter<"book_borrowed"> | string
    borrowDate?: DateTimeFilter<"book_borrowed"> | Date | string
    returnDate?: DateTimeNullableFilter<"book_borrowed"> | Date | string | null
    dueDate?: DateTimeFilter<"book_borrowed"> | Date | string
    userId?: StringFilter<"book_borrowed"> | string
    bookId?: StringFilter<"book_borrowed"> | string
    returned?: BoolFilter<"book_borrowed"> | boolean
  }

  export type book_borrow_historyUpsertWithWhereUniqueWithoutUserInput = {
    where: book_borrow_historyWhereUniqueInput
    update: XOR<book_borrow_historyUpdateWithoutUserInput, book_borrow_historyUncheckedUpdateWithoutUserInput>
    create: XOR<book_borrow_historyCreateWithoutUserInput, book_borrow_historyUncheckedCreateWithoutUserInput>
  }

  export type book_borrow_historyUpdateWithWhereUniqueWithoutUserInput = {
    where: book_borrow_historyWhereUniqueInput
    data: XOR<book_borrow_historyUpdateWithoutUserInput, book_borrow_historyUncheckedUpdateWithoutUserInput>
  }

  export type book_borrow_historyUpdateManyWithWhereWithoutUserInput = {
    where: book_borrow_historyScalarWhereInput
    data: XOR<book_borrow_historyUpdateManyMutationInput, book_borrow_historyUncheckedUpdateManyWithoutUserInput>
  }

  export type book_borrow_historyScalarWhereInput = {
    AND?: book_borrow_historyScalarWhereInput | book_borrow_historyScalarWhereInput[]
    OR?: book_borrow_historyScalarWhereInput[]
    NOT?: book_borrow_historyScalarWhereInput | book_borrow_historyScalarWhereInput[]
    id?: StringFilter<"book_borrow_history"> | string
    borrowDate?: DateTimeFilter<"book_borrow_history"> | Date | string
    returnDate?: DateTimeNullableFilter<"book_borrow_history"> | Date | string | null
    userId?: StringFilter<"book_borrow_history"> | string
    bookId?: StringFilter<"book_borrow_history"> | string
    returned?: BoolFilter<"book_borrow_history"> | boolean
  }

  export type book_ratingUpsertWithWhereUniqueWithoutUserInput = {
    where: book_ratingWhereUniqueInput
    update: XOR<book_ratingUpdateWithoutUserInput, book_ratingUncheckedUpdateWithoutUserInput>
    create: XOR<book_ratingCreateWithoutUserInput, book_ratingUncheckedCreateWithoutUserInput>
  }

  export type book_ratingUpdateWithWhereUniqueWithoutUserInput = {
    where: book_ratingWhereUniqueInput
    data: XOR<book_ratingUpdateWithoutUserInput, book_ratingUncheckedUpdateWithoutUserInput>
  }

  export type book_ratingUpdateManyWithWhereWithoutUserInput = {
    where: book_ratingScalarWhereInput
    data: XOR<book_ratingUpdateManyMutationInput, book_ratingUncheckedUpdateManyWithoutUserInput>
  }

  export type book_ratingScalarWhereInput = {
    AND?: book_ratingScalarWhereInput | book_ratingScalarWhereInput[]
    OR?: book_ratingScalarWhereInput[]
    NOT?: book_ratingScalarWhereInput | book_ratingScalarWhereInput[]
    id?: StringFilter<"book_rating"> | string
    createAt?: DateTimeFilter<"book_rating"> | Date | string
    updateAt?: DateTimeFilter<"book_rating"> | Date | string
    rating?: FloatFilter<"book_rating"> | number
    review?: StringNullableFilter<"book_rating"> | string | null
    userId?: StringFilter<"book_rating"> | string
    bookId?: StringFilter<"book_rating"> | string
  }

  export type book_categoryCreateWithoutBooksInput = {
    id?: string
    createAt?: Date | string
    updateAt?: Date | string
    categoryName: string
  }

  export type book_categoryUncheckedCreateWithoutBooksInput = {
    id?: string
    createAt?: Date | string
    updateAt?: Date | string
    categoryName: string
  }

  export type book_categoryCreateOrConnectWithoutBooksInput = {
    where: book_categoryWhereUniqueInput
    create: XOR<book_categoryCreateWithoutBooksInput, book_categoryUncheckedCreateWithoutBooksInput>
  }

  export type book_borrowedCreateWithoutBookInput = {
    id?: string
    borrowDate?: Date | string
    returnDate?: Date | string | null
    dueDate: Date | string
    returned?: boolean
    user: book_userCreateNestedOneWithoutBorrowedInput
  }

  export type book_borrowedUncheckedCreateWithoutBookInput = {
    id?: string
    borrowDate?: Date | string
    returnDate?: Date | string | null
    dueDate: Date | string
    userId: string
    returned?: boolean
  }

  export type book_borrowedCreateOrConnectWithoutBookInput = {
    where: book_borrowedWhereUniqueInput
    create: XOR<book_borrowedCreateWithoutBookInput, book_borrowedUncheckedCreateWithoutBookInput>
  }

  export type book_borrowedCreateManyBookInputEnvelope = {
    data: book_borrowedCreateManyBookInput | book_borrowedCreateManyBookInput[]
    skipDuplicates?: boolean
  }

  export type book_borrow_historyCreateWithoutBookInput = {
    id?: string
    borrowDate?: Date | string
    returnDate?: Date | string | null
    returned?: boolean
    user: book_userCreateNestedOneWithoutBook_borrow_historyInput
  }

  export type book_borrow_historyUncheckedCreateWithoutBookInput = {
    id?: string
    borrowDate?: Date | string
    returnDate?: Date | string | null
    userId: string
    returned?: boolean
  }

  export type book_borrow_historyCreateOrConnectWithoutBookInput = {
    where: book_borrow_historyWhereUniqueInput
    create: XOR<book_borrow_historyCreateWithoutBookInput, book_borrow_historyUncheckedCreateWithoutBookInput>
  }

  export type book_borrow_historyCreateManyBookInputEnvelope = {
    data: book_borrow_historyCreateManyBookInput | book_borrow_historyCreateManyBookInput[]
    skipDuplicates?: boolean
  }

  export type book_ratingCreateWithoutBookInput = {
    id?: string
    createAt?: Date | string
    updateAt?: Date | string
    rating: number
    review?: string | null
    user: book_userCreateNestedOneWithoutBook_ratingInput
  }

  export type book_ratingUncheckedCreateWithoutBookInput = {
    id?: string
    createAt?: Date | string
    updateAt?: Date | string
    rating: number
    review?: string | null
    userId: string
  }

  export type book_ratingCreateOrConnectWithoutBookInput = {
    where: book_ratingWhereUniqueInput
    create: XOR<book_ratingCreateWithoutBookInput, book_ratingUncheckedCreateWithoutBookInput>
  }

  export type book_ratingCreateManyBookInputEnvelope = {
    data: book_ratingCreateManyBookInput | book_ratingCreateManyBookInput[]
    skipDuplicates?: boolean
  }

  export type book_categoryUpsertWithoutBooksInput = {
    update: XOR<book_categoryUpdateWithoutBooksInput, book_categoryUncheckedUpdateWithoutBooksInput>
    create: XOR<book_categoryCreateWithoutBooksInput, book_categoryUncheckedCreateWithoutBooksInput>
    where?: book_categoryWhereInput
  }

  export type book_categoryUpdateToOneWithWhereWithoutBooksInput = {
    where?: book_categoryWhereInput
    data: XOR<book_categoryUpdateWithoutBooksInput, book_categoryUncheckedUpdateWithoutBooksInput>
  }

  export type book_categoryUpdateWithoutBooksInput = {
    id?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categoryName?: StringFieldUpdateOperationsInput | string
  }

  export type book_categoryUncheckedUpdateWithoutBooksInput = {
    id?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categoryName?: StringFieldUpdateOperationsInput | string
  }

  export type book_borrowedUpsertWithWhereUniqueWithoutBookInput = {
    where: book_borrowedWhereUniqueInput
    update: XOR<book_borrowedUpdateWithoutBookInput, book_borrowedUncheckedUpdateWithoutBookInput>
    create: XOR<book_borrowedCreateWithoutBookInput, book_borrowedUncheckedCreateWithoutBookInput>
  }

  export type book_borrowedUpdateWithWhereUniqueWithoutBookInput = {
    where: book_borrowedWhereUniqueInput
    data: XOR<book_borrowedUpdateWithoutBookInput, book_borrowedUncheckedUpdateWithoutBookInput>
  }

  export type book_borrowedUpdateManyWithWhereWithoutBookInput = {
    where: book_borrowedScalarWhereInput
    data: XOR<book_borrowedUpdateManyMutationInput, book_borrowedUncheckedUpdateManyWithoutBookInput>
  }

  export type book_borrow_historyUpsertWithWhereUniqueWithoutBookInput = {
    where: book_borrow_historyWhereUniqueInput
    update: XOR<book_borrow_historyUpdateWithoutBookInput, book_borrow_historyUncheckedUpdateWithoutBookInput>
    create: XOR<book_borrow_historyCreateWithoutBookInput, book_borrow_historyUncheckedCreateWithoutBookInput>
  }

  export type book_borrow_historyUpdateWithWhereUniqueWithoutBookInput = {
    where: book_borrow_historyWhereUniqueInput
    data: XOR<book_borrow_historyUpdateWithoutBookInput, book_borrow_historyUncheckedUpdateWithoutBookInput>
  }

  export type book_borrow_historyUpdateManyWithWhereWithoutBookInput = {
    where: book_borrow_historyScalarWhereInput
    data: XOR<book_borrow_historyUpdateManyMutationInput, book_borrow_historyUncheckedUpdateManyWithoutBookInput>
  }

  export type book_ratingUpsertWithWhereUniqueWithoutBookInput = {
    where: book_ratingWhereUniqueInput
    update: XOR<book_ratingUpdateWithoutBookInput, book_ratingUncheckedUpdateWithoutBookInput>
    create: XOR<book_ratingCreateWithoutBookInput, book_ratingUncheckedCreateWithoutBookInput>
  }

  export type book_ratingUpdateWithWhereUniqueWithoutBookInput = {
    where: book_ratingWhereUniqueInput
    data: XOR<book_ratingUpdateWithoutBookInput, book_ratingUncheckedUpdateWithoutBookInput>
  }

  export type book_ratingUpdateManyWithWhereWithoutBookInput = {
    where: book_ratingScalarWhereInput
    data: XOR<book_ratingUpdateManyMutationInput, book_ratingUncheckedUpdateManyWithoutBookInput>
  }

  export type book_bookCreateWithoutCategoryInput = {
    id?: string
    createAt?: Date | string
    updateAt?: Date | string
    title: string
    author: string
    isbn: string
    description?: string | null
    publication: Date | string
    available?: boolean
    borrowed?: book_borrowedCreateNestedManyWithoutBookInput
    book_borrow_history?: book_borrow_historyCreateNestedManyWithoutBookInput
    book_rating?: book_ratingCreateNestedManyWithoutBookInput
  }

  export type book_bookUncheckedCreateWithoutCategoryInput = {
    id?: string
    createAt?: Date | string
    updateAt?: Date | string
    title: string
    author: string
    isbn: string
    description?: string | null
    publication: Date | string
    available?: boolean
    borrowed?: book_borrowedUncheckedCreateNestedManyWithoutBookInput
    book_borrow_history?: book_borrow_historyUncheckedCreateNestedManyWithoutBookInput
    book_rating?: book_ratingUncheckedCreateNestedManyWithoutBookInput
  }

  export type book_bookCreateOrConnectWithoutCategoryInput = {
    where: book_bookWhereUniqueInput
    create: XOR<book_bookCreateWithoutCategoryInput, book_bookUncheckedCreateWithoutCategoryInput>
  }

  export type book_bookCreateManyCategoryInputEnvelope = {
    data: book_bookCreateManyCategoryInput | book_bookCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type book_bookUpsertWithWhereUniqueWithoutCategoryInput = {
    where: book_bookWhereUniqueInput
    update: XOR<book_bookUpdateWithoutCategoryInput, book_bookUncheckedUpdateWithoutCategoryInput>
    create: XOR<book_bookCreateWithoutCategoryInput, book_bookUncheckedCreateWithoutCategoryInput>
  }

  export type book_bookUpdateWithWhereUniqueWithoutCategoryInput = {
    where: book_bookWhereUniqueInput
    data: XOR<book_bookUpdateWithoutCategoryInput, book_bookUncheckedUpdateWithoutCategoryInput>
  }

  export type book_bookUpdateManyWithWhereWithoutCategoryInput = {
    where: book_bookScalarWhereInput
    data: XOR<book_bookUpdateManyMutationInput, book_bookUncheckedUpdateManyWithoutCategoryInput>
  }

  export type book_bookScalarWhereInput = {
    AND?: book_bookScalarWhereInput | book_bookScalarWhereInput[]
    OR?: book_bookScalarWhereInput[]
    NOT?: book_bookScalarWhereInput | book_bookScalarWhereInput[]
    id?: StringFilter<"book_book"> | string
    createAt?: DateTimeFilter<"book_book"> | Date | string
    updateAt?: DateTimeFilter<"book_book"> | Date | string
    title?: StringFilter<"book_book"> | string
    author?: StringFilter<"book_book"> | string
    isbn?: StringFilter<"book_book"> | string
    description?: StringNullableFilter<"book_book"> | string | null
    publication?: DateTimeFilter<"book_book"> | Date | string
    categoryId?: StringFilter<"book_book"> | string
    available?: BoolFilter<"book_book"> | boolean
  }

  export type book_userCreateWithoutBorrowedInput = {
    id?: string
    createAt?: Date | string
    updateAt?: Date | string
    name: string
    email: string
    password: string
    role?: $Enums.book_role
    book_roleId: string
    book_borrow_history?: book_borrow_historyCreateNestedManyWithoutUserInput
    book_rating?: book_ratingCreateNestedManyWithoutUserInput
  }

  export type book_userUncheckedCreateWithoutBorrowedInput = {
    id?: string
    createAt?: Date | string
    updateAt?: Date | string
    name: string
    email: string
    password: string
    role?: $Enums.book_role
    book_roleId: string
    book_borrow_history?: book_borrow_historyUncheckedCreateNestedManyWithoutUserInput
    book_rating?: book_ratingUncheckedCreateNestedManyWithoutUserInput
  }

  export type book_userCreateOrConnectWithoutBorrowedInput = {
    where: book_userWhereUniqueInput
    create: XOR<book_userCreateWithoutBorrowedInput, book_userUncheckedCreateWithoutBorrowedInput>
  }

  export type book_bookCreateWithoutBorrowedInput = {
    id?: string
    createAt?: Date | string
    updateAt?: Date | string
    title: string
    author: string
    isbn: string
    description?: string | null
    publication: Date | string
    available?: boolean
    category: book_categoryCreateNestedOneWithoutBooksInput
    book_borrow_history?: book_borrow_historyCreateNestedManyWithoutBookInput
    book_rating?: book_ratingCreateNestedManyWithoutBookInput
  }

  export type book_bookUncheckedCreateWithoutBorrowedInput = {
    id?: string
    createAt?: Date | string
    updateAt?: Date | string
    title: string
    author: string
    isbn: string
    description?: string | null
    publication: Date | string
    categoryId: string
    available?: boolean
    book_borrow_history?: book_borrow_historyUncheckedCreateNestedManyWithoutBookInput
    book_rating?: book_ratingUncheckedCreateNestedManyWithoutBookInput
  }

  export type book_bookCreateOrConnectWithoutBorrowedInput = {
    where: book_bookWhereUniqueInput
    create: XOR<book_bookCreateWithoutBorrowedInput, book_bookUncheckedCreateWithoutBorrowedInput>
  }

  export type book_userUpsertWithoutBorrowedInput = {
    update: XOR<book_userUpdateWithoutBorrowedInput, book_userUncheckedUpdateWithoutBorrowedInput>
    create: XOR<book_userCreateWithoutBorrowedInput, book_userUncheckedCreateWithoutBorrowedInput>
    where?: book_userWhereInput
  }

  export type book_userUpdateToOneWithWhereWithoutBorrowedInput = {
    where?: book_userWhereInput
    data: XOR<book_userUpdateWithoutBorrowedInput, book_userUncheckedUpdateWithoutBorrowedInput>
  }

  export type book_userUpdateWithoutBorrowedInput = {
    id?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: Enumbook_roleFieldUpdateOperationsInput | $Enums.book_role
    book_roleId?: StringFieldUpdateOperationsInput | string
    book_borrow_history?: book_borrow_historyUpdateManyWithoutUserNestedInput
    book_rating?: book_ratingUpdateManyWithoutUserNestedInput
  }

  export type book_userUncheckedUpdateWithoutBorrowedInput = {
    id?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: Enumbook_roleFieldUpdateOperationsInput | $Enums.book_role
    book_roleId?: StringFieldUpdateOperationsInput | string
    book_borrow_history?: book_borrow_historyUncheckedUpdateManyWithoutUserNestedInput
    book_rating?: book_ratingUncheckedUpdateManyWithoutUserNestedInput
  }

  export type book_bookUpsertWithoutBorrowedInput = {
    update: XOR<book_bookUpdateWithoutBorrowedInput, book_bookUncheckedUpdateWithoutBorrowedInput>
    create: XOR<book_bookCreateWithoutBorrowedInput, book_bookUncheckedCreateWithoutBorrowedInput>
    where?: book_bookWhereInput
  }

  export type book_bookUpdateToOneWithWhereWithoutBorrowedInput = {
    where?: book_bookWhereInput
    data: XOR<book_bookUpdateWithoutBorrowedInput, book_bookUncheckedUpdateWithoutBorrowedInput>
  }

  export type book_bookUpdateWithoutBorrowedInput = {
    id?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    isbn?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    publication?: DateTimeFieldUpdateOperationsInput | Date | string
    available?: BoolFieldUpdateOperationsInput | boolean
    category?: book_categoryUpdateOneRequiredWithoutBooksNestedInput
    book_borrow_history?: book_borrow_historyUpdateManyWithoutBookNestedInput
    book_rating?: book_ratingUpdateManyWithoutBookNestedInput
  }

  export type book_bookUncheckedUpdateWithoutBorrowedInput = {
    id?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    isbn?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    publication?: DateTimeFieldUpdateOperationsInput | Date | string
    categoryId?: StringFieldUpdateOperationsInput | string
    available?: BoolFieldUpdateOperationsInput | boolean
    book_borrow_history?: book_borrow_historyUncheckedUpdateManyWithoutBookNestedInput
    book_rating?: book_ratingUncheckedUpdateManyWithoutBookNestedInput
  }

  export type book_userCreateWithoutBook_borrow_historyInput = {
    id?: string
    createAt?: Date | string
    updateAt?: Date | string
    name: string
    email: string
    password: string
    role?: $Enums.book_role
    book_roleId: string
    borrowed?: book_borrowedCreateNestedManyWithoutUserInput
    book_rating?: book_ratingCreateNestedManyWithoutUserInput
  }

  export type book_userUncheckedCreateWithoutBook_borrow_historyInput = {
    id?: string
    createAt?: Date | string
    updateAt?: Date | string
    name: string
    email: string
    password: string
    role?: $Enums.book_role
    book_roleId: string
    borrowed?: book_borrowedUncheckedCreateNestedManyWithoutUserInput
    book_rating?: book_ratingUncheckedCreateNestedManyWithoutUserInput
  }

  export type book_userCreateOrConnectWithoutBook_borrow_historyInput = {
    where: book_userWhereUniqueInput
    create: XOR<book_userCreateWithoutBook_borrow_historyInput, book_userUncheckedCreateWithoutBook_borrow_historyInput>
  }

  export type book_bookCreateWithoutBook_borrow_historyInput = {
    id?: string
    createAt?: Date | string
    updateAt?: Date | string
    title: string
    author: string
    isbn: string
    description?: string | null
    publication: Date | string
    available?: boolean
    category: book_categoryCreateNestedOneWithoutBooksInput
    borrowed?: book_borrowedCreateNestedManyWithoutBookInput
    book_rating?: book_ratingCreateNestedManyWithoutBookInput
  }

  export type book_bookUncheckedCreateWithoutBook_borrow_historyInput = {
    id?: string
    createAt?: Date | string
    updateAt?: Date | string
    title: string
    author: string
    isbn: string
    description?: string | null
    publication: Date | string
    categoryId: string
    available?: boolean
    borrowed?: book_borrowedUncheckedCreateNestedManyWithoutBookInput
    book_rating?: book_ratingUncheckedCreateNestedManyWithoutBookInput
  }

  export type book_bookCreateOrConnectWithoutBook_borrow_historyInput = {
    where: book_bookWhereUniqueInput
    create: XOR<book_bookCreateWithoutBook_borrow_historyInput, book_bookUncheckedCreateWithoutBook_borrow_historyInput>
  }

  export type book_userUpsertWithoutBook_borrow_historyInput = {
    update: XOR<book_userUpdateWithoutBook_borrow_historyInput, book_userUncheckedUpdateWithoutBook_borrow_historyInput>
    create: XOR<book_userCreateWithoutBook_borrow_historyInput, book_userUncheckedCreateWithoutBook_borrow_historyInput>
    where?: book_userWhereInput
  }

  export type book_userUpdateToOneWithWhereWithoutBook_borrow_historyInput = {
    where?: book_userWhereInput
    data: XOR<book_userUpdateWithoutBook_borrow_historyInput, book_userUncheckedUpdateWithoutBook_borrow_historyInput>
  }

  export type book_userUpdateWithoutBook_borrow_historyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: Enumbook_roleFieldUpdateOperationsInput | $Enums.book_role
    book_roleId?: StringFieldUpdateOperationsInput | string
    borrowed?: book_borrowedUpdateManyWithoutUserNestedInput
    book_rating?: book_ratingUpdateManyWithoutUserNestedInput
  }

  export type book_userUncheckedUpdateWithoutBook_borrow_historyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: Enumbook_roleFieldUpdateOperationsInput | $Enums.book_role
    book_roleId?: StringFieldUpdateOperationsInput | string
    borrowed?: book_borrowedUncheckedUpdateManyWithoutUserNestedInput
    book_rating?: book_ratingUncheckedUpdateManyWithoutUserNestedInput
  }

  export type book_bookUpsertWithoutBook_borrow_historyInput = {
    update: XOR<book_bookUpdateWithoutBook_borrow_historyInput, book_bookUncheckedUpdateWithoutBook_borrow_historyInput>
    create: XOR<book_bookCreateWithoutBook_borrow_historyInput, book_bookUncheckedCreateWithoutBook_borrow_historyInput>
    where?: book_bookWhereInput
  }

  export type book_bookUpdateToOneWithWhereWithoutBook_borrow_historyInput = {
    where?: book_bookWhereInput
    data: XOR<book_bookUpdateWithoutBook_borrow_historyInput, book_bookUncheckedUpdateWithoutBook_borrow_historyInput>
  }

  export type book_bookUpdateWithoutBook_borrow_historyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    isbn?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    publication?: DateTimeFieldUpdateOperationsInput | Date | string
    available?: BoolFieldUpdateOperationsInput | boolean
    category?: book_categoryUpdateOneRequiredWithoutBooksNestedInput
    borrowed?: book_borrowedUpdateManyWithoutBookNestedInput
    book_rating?: book_ratingUpdateManyWithoutBookNestedInput
  }

  export type book_bookUncheckedUpdateWithoutBook_borrow_historyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    isbn?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    publication?: DateTimeFieldUpdateOperationsInput | Date | string
    categoryId?: StringFieldUpdateOperationsInput | string
    available?: BoolFieldUpdateOperationsInput | boolean
    borrowed?: book_borrowedUncheckedUpdateManyWithoutBookNestedInput
    book_rating?: book_ratingUncheckedUpdateManyWithoutBookNestedInput
  }

  export type book_userCreateWithoutBook_ratingInput = {
    id?: string
    createAt?: Date | string
    updateAt?: Date | string
    name: string
    email: string
    password: string
    role?: $Enums.book_role
    book_roleId: string
    borrowed?: book_borrowedCreateNestedManyWithoutUserInput
    book_borrow_history?: book_borrow_historyCreateNestedManyWithoutUserInput
  }

  export type book_userUncheckedCreateWithoutBook_ratingInput = {
    id?: string
    createAt?: Date | string
    updateAt?: Date | string
    name: string
    email: string
    password: string
    role?: $Enums.book_role
    book_roleId: string
    borrowed?: book_borrowedUncheckedCreateNestedManyWithoutUserInput
    book_borrow_history?: book_borrow_historyUncheckedCreateNestedManyWithoutUserInput
  }

  export type book_userCreateOrConnectWithoutBook_ratingInput = {
    where: book_userWhereUniqueInput
    create: XOR<book_userCreateWithoutBook_ratingInput, book_userUncheckedCreateWithoutBook_ratingInput>
  }

  export type book_bookCreateWithoutBook_ratingInput = {
    id?: string
    createAt?: Date | string
    updateAt?: Date | string
    title: string
    author: string
    isbn: string
    description?: string | null
    publication: Date | string
    available?: boolean
    category: book_categoryCreateNestedOneWithoutBooksInput
    borrowed?: book_borrowedCreateNestedManyWithoutBookInput
    book_borrow_history?: book_borrow_historyCreateNestedManyWithoutBookInput
  }

  export type book_bookUncheckedCreateWithoutBook_ratingInput = {
    id?: string
    createAt?: Date | string
    updateAt?: Date | string
    title: string
    author: string
    isbn: string
    description?: string | null
    publication: Date | string
    categoryId: string
    available?: boolean
    borrowed?: book_borrowedUncheckedCreateNestedManyWithoutBookInput
    book_borrow_history?: book_borrow_historyUncheckedCreateNestedManyWithoutBookInput
  }

  export type book_bookCreateOrConnectWithoutBook_ratingInput = {
    where: book_bookWhereUniqueInput
    create: XOR<book_bookCreateWithoutBook_ratingInput, book_bookUncheckedCreateWithoutBook_ratingInput>
  }

  export type book_userUpsertWithoutBook_ratingInput = {
    update: XOR<book_userUpdateWithoutBook_ratingInput, book_userUncheckedUpdateWithoutBook_ratingInput>
    create: XOR<book_userCreateWithoutBook_ratingInput, book_userUncheckedCreateWithoutBook_ratingInput>
    where?: book_userWhereInput
  }

  export type book_userUpdateToOneWithWhereWithoutBook_ratingInput = {
    where?: book_userWhereInput
    data: XOR<book_userUpdateWithoutBook_ratingInput, book_userUncheckedUpdateWithoutBook_ratingInput>
  }

  export type book_userUpdateWithoutBook_ratingInput = {
    id?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: Enumbook_roleFieldUpdateOperationsInput | $Enums.book_role
    book_roleId?: StringFieldUpdateOperationsInput | string
    borrowed?: book_borrowedUpdateManyWithoutUserNestedInput
    book_borrow_history?: book_borrow_historyUpdateManyWithoutUserNestedInput
  }

  export type book_userUncheckedUpdateWithoutBook_ratingInput = {
    id?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: Enumbook_roleFieldUpdateOperationsInput | $Enums.book_role
    book_roleId?: StringFieldUpdateOperationsInput | string
    borrowed?: book_borrowedUncheckedUpdateManyWithoutUserNestedInput
    book_borrow_history?: book_borrow_historyUncheckedUpdateManyWithoutUserNestedInput
  }

  export type book_bookUpsertWithoutBook_ratingInput = {
    update: XOR<book_bookUpdateWithoutBook_ratingInput, book_bookUncheckedUpdateWithoutBook_ratingInput>
    create: XOR<book_bookCreateWithoutBook_ratingInput, book_bookUncheckedCreateWithoutBook_ratingInput>
    where?: book_bookWhereInput
  }

  export type book_bookUpdateToOneWithWhereWithoutBook_ratingInput = {
    where?: book_bookWhereInput
    data: XOR<book_bookUpdateWithoutBook_ratingInput, book_bookUncheckedUpdateWithoutBook_ratingInput>
  }

  export type book_bookUpdateWithoutBook_ratingInput = {
    id?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    isbn?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    publication?: DateTimeFieldUpdateOperationsInput | Date | string
    available?: BoolFieldUpdateOperationsInput | boolean
    category?: book_categoryUpdateOneRequiredWithoutBooksNestedInput
    borrowed?: book_borrowedUpdateManyWithoutBookNestedInput
    book_borrow_history?: book_borrow_historyUpdateManyWithoutBookNestedInput
  }

  export type book_bookUncheckedUpdateWithoutBook_ratingInput = {
    id?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    isbn?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    publication?: DateTimeFieldUpdateOperationsInput | Date | string
    categoryId?: StringFieldUpdateOperationsInput | string
    available?: BoolFieldUpdateOperationsInput | boolean
    borrowed?: book_borrowedUncheckedUpdateManyWithoutBookNestedInput
    book_borrow_history?: book_borrow_historyUncheckedUpdateManyWithoutBookNestedInput
  }

  export type study_reservationCreateWithoutUserInput = {
    uid?: string
    createAt?: Date | string
    updateAt?: Date | string
    startTime: Date | string
    endTime: Date | string
    status?: string
    seat: study_seatCreateNestedOneWithoutReservationsInput
  }

  export type study_reservationUncheckedCreateWithoutUserInput = {
    uid?: string
    createAt?: Date | string
    updateAt?: Date | string
    seatId: string
    startTime: Date | string
    endTime: Date | string
    status?: string
  }

  export type study_reservationCreateOrConnectWithoutUserInput = {
    where: study_reservationWhereUniqueInput
    create: XOR<study_reservationCreateWithoutUserInput, study_reservationUncheckedCreateWithoutUserInput>
  }

  export type study_reservationCreateManyUserInputEnvelope = {
    data: study_reservationCreateManyUserInput | study_reservationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type study_messageCreateWithoutUserInput = {
    uid?: string
    createAt?: Date | string
    updateAt?: Date | string
    content: string
    reply?: string | null
    status?: boolean
  }

  export type study_messageUncheckedCreateWithoutUserInput = {
    uid?: string
    createAt?: Date | string
    updateAt?: Date | string
    content: string
    reply?: string | null
    status?: boolean
  }

  export type study_messageCreateOrConnectWithoutUserInput = {
    where: study_messageWhereUniqueInput
    create: XOR<study_messageCreateWithoutUserInput, study_messageUncheckedCreateWithoutUserInput>
  }

  export type study_messageCreateManyUserInputEnvelope = {
    data: study_messageCreateManyUserInput | study_messageCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type study_reservationUpsertWithWhereUniqueWithoutUserInput = {
    where: study_reservationWhereUniqueInput
    update: XOR<study_reservationUpdateWithoutUserInput, study_reservationUncheckedUpdateWithoutUserInput>
    create: XOR<study_reservationCreateWithoutUserInput, study_reservationUncheckedCreateWithoutUserInput>
  }

  export type study_reservationUpdateWithWhereUniqueWithoutUserInput = {
    where: study_reservationWhereUniqueInput
    data: XOR<study_reservationUpdateWithoutUserInput, study_reservationUncheckedUpdateWithoutUserInput>
  }

  export type study_reservationUpdateManyWithWhereWithoutUserInput = {
    where: study_reservationScalarWhereInput
    data: XOR<study_reservationUpdateManyMutationInput, study_reservationUncheckedUpdateManyWithoutUserInput>
  }

  export type study_reservationScalarWhereInput = {
    AND?: study_reservationScalarWhereInput | study_reservationScalarWhereInput[]
    OR?: study_reservationScalarWhereInput[]
    NOT?: study_reservationScalarWhereInput | study_reservationScalarWhereInput[]
    uid?: StringFilter<"study_reservation"> | string
    createAt?: DateTimeFilter<"study_reservation"> | Date | string
    updateAt?: DateTimeFilter<"study_reservation"> | Date | string
    userId?: StringFilter<"study_reservation"> | string
    seatId?: StringFilter<"study_reservation"> | string
    startTime?: DateTimeFilter<"study_reservation"> | Date | string
    endTime?: DateTimeFilter<"study_reservation"> | Date | string
    status?: StringFilter<"study_reservation"> | string
  }

  export type study_messageUpsertWithWhereUniqueWithoutUserInput = {
    where: study_messageWhereUniqueInput
    update: XOR<study_messageUpdateWithoutUserInput, study_messageUncheckedUpdateWithoutUserInput>
    create: XOR<study_messageCreateWithoutUserInput, study_messageUncheckedCreateWithoutUserInput>
  }

  export type study_messageUpdateWithWhereUniqueWithoutUserInput = {
    where: study_messageWhereUniqueInput
    data: XOR<study_messageUpdateWithoutUserInput, study_messageUncheckedUpdateWithoutUserInput>
  }

  export type study_messageUpdateManyWithWhereWithoutUserInput = {
    where: study_messageScalarWhereInput
    data: XOR<study_messageUpdateManyMutationInput, study_messageUncheckedUpdateManyWithoutUserInput>
  }

  export type study_messageScalarWhereInput = {
    AND?: study_messageScalarWhereInput | study_messageScalarWhereInput[]
    OR?: study_messageScalarWhereInput[]
    NOT?: study_messageScalarWhereInput | study_messageScalarWhereInput[]
    uid?: StringFilter<"study_message"> | string
    createAt?: DateTimeFilter<"study_message"> | Date | string
    updateAt?: DateTimeFilter<"study_message"> | Date | string
    userId?: StringFilter<"study_message"> | string
    content?: StringFilter<"study_message"> | string
    reply?: StringNullableFilter<"study_message"> | string | null
    status?: BoolFilter<"study_message"> | boolean
  }

  export type study_floorCreateWithoutStoreInput = {
    uid?: string
    createAt?: Date | string
    updateAt?: Date | string
    floorNumber: number
    studyRooms?: study_roomCreateNestedManyWithoutFloorInput
  }

  export type study_floorUncheckedCreateWithoutStoreInput = {
    uid?: string
    createAt?: Date | string
    updateAt?: Date | string
    floorNumber: number
    studyRooms?: study_roomUncheckedCreateNestedManyWithoutFloorInput
  }

  export type study_floorCreateOrConnectWithoutStoreInput = {
    where: study_floorWhereUniqueInput
    create: XOR<study_floorCreateWithoutStoreInput, study_floorUncheckedCreateWithoutStoreInput>
  }

  export type study_floorCreateManyStoreInputEnvelope = {
    data: study_floorCreateManyStoreInput | study_floorCreateManyStoreInput[]
    skipDuplicates?: boolean
  }

  export type study_floorUpsertWithWhereUniqueWithoutStoreInput = {
    where: study_floorWhereUniqueInput
    update: XOR<study_floorUpdateWithoutStoreInput, study_floorUncheckedUpdateWithoutStoreInput>
    create: XOR<study_floorCreateWithoutStoreInput, study_floorUncheckedCreateWithoutStoreInput>
  }

  export type study_floorUpdateWithWhereUniqueWithoutStoreInput = {
    where: study_floorWhereUniqueInput
    data: XOR<study_floorUpdateWithoutStoreInput, study_floorUncheckedUpdateWithoutStoreInput>
  }

  export type study_floorUpdateManyWithWhereWithoutStoreInput = {
    where: study_floorScalarWhereInput
    data: XOR<study_floorUpdateManyMutationInput, study_floorUncheckedUpdateManyWithoutStoreInput>
  }

  export type study_floorScalarWhereInput = {
    AND?: study_floorScalarWhereInput | study_floorScalarWhereInput[]
    OR?: study_floorScalarWhereInput[]
    NOT?: study_floorScalarWhereInput | study_floorScalarWhereInput[]
    uid?: StringFilter<"study_floor"> | string
    createAt?: DateTimeFilter<"study_floor"> | Date | string
    updateAt?: DateTimeFilter<"study_floor"> | Date | string
    floorNumber?: IntFilter<"study_floor"> | number
    storeId?: StringFilter<"study_floor"> | string
  }

  export type study_storeCreateWithoutFloorsInput = {
    uid?: string
    createAt?: Date | string
    updateAt?: Date | string
    name: string
    local: string
    address: string
    status?: boolean
    remark?: string | null
  }

  export type study_storeUncheckedCreateWithoutFloorsInput = {
    uid?: string
    createAt?: Date | string
    updateAt?: Date | string
    name: string
    local: string
    address: string
    status?: boolean
    remark?: string | null
  }

  export type study_storeCreateOrConnectWithoutFloorsInput = {
    where: study_storeWhereUniqueInput
    create: XOR<study_storeCreateWithoutFloorsInput, study_storeUncheckedCreateWithoutFloorsInput>
  }

  export type study_roomCreateWithoutFloorInput = {
    uid?: string
    createAt?: Date | string
    updateAt?: Date | string
    name: string
    capacity: number
    status?: boolean
    seats?: study_seatCreateNestedManyWithoutRoomInput
  }

  export type study_roomUncheckedCreateWithoutFloorInput = {
    uid?: string
    createAt?: Date | string
    updateAt?: Date | string
    name: string
    capacity: number
    status?: boolean
    seats?: study_seatUncheckedCreateNestedManyWithoutRoomInput
  }

  export type study_roomCreateOrConnectWithoutFloorInput = {
    where: study_roomWhereUniqueInput
    create: XOR<study_roomCreateWithoutFloorInput, study_roomUncheckedCreateWithoutFloorInput>
  }

  export type study_roomCreateManyFloorInputEnvelope = {
    data: study_roomCreateManyFloorInput | study_roomCreateManyFloorInput[]
    skipDuplicates?: boolean
  }

  export type study_storeUpsertWithoutFloorsInput = {
    update: XOR<study_storeUpdateWithoutFloorsInput, study_storeUncheckedUpdateWithoutFloorsInput>
    create: XOR<study_storeCreateWithoutFloorsInput, study_storeUncheckedCreateWithoutFloorsInput>
    where?: study_storeWhereInput
  }

  export type study_storeUpdateToOneWithWhereWithoutFloorsInput = {
    where?: study_storeWhereInput
    data: XOR<study_storeUpdateWithoutFloorsInput, study_storeUncheckedUpdateWithoutFloorsInput>
  }

  export type study_storeUpdateWithoutFloorsInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    local?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    remark?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type study_storeUncheckedUpdateWithoutFloorsInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    local?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    remark?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type study_roomUpsertWithWhereUniqueWithoutFloorInput = {
    where: study_roomWhereUniqueInput
    update: XOR<study_roomUpdateWithoutFloorInput, study_roomUncheckedUpdateWithoutFloorInput>
    create: XOR<study_roomCreateWithoutFloorInput, study_roomUncheckedCreateWithoutFloorInput>
  }

  export type study_roomUpdateWithWhereUniqueWithoutFloorInput = {
    where: study_roomWhereUniqueInput
    data: XOR<study_roomUpdateWithoutFloorInput, study_roomUncheckedUpdateWithoutFloorInput>
  }

  export type study_roomUpdateManyWithWhereWithoutFloorInput = {
    where: study_roomScalarWhereInput
    data: XOR<study_roomUpdateManyMutationInput, study_roomUncheckedUpdateManyWithoutFloorInput>
  }

  export type study_roomScalarWhereInput = {
    AND?: study_roomScalarWhereInput | study_roomScalarWhereInput[]
    OR?: study_roomScalarWhereInput[]
    NOT?: study_roomScalarWhereInput | study_roomScalarWhereInput[]
    uid?: StringFilter<"study_room"> | string
    createAt?: DateTimeFilter<"study_room"> | Date | string
    updateAt?: DateTimeFilter<"study_room"> | Date | string
    name?: StringFilter<"study_room"> | string
    floorId?: StringFilter<"study_room"> | string
    capacity?: IntFilter<"study_room"> | number
    status?: BoolFilter<"study_room"> | boolean
  }

  export type study_floorCreateWithoutStudyRoomsInput = {
    uid?: string
    createAt?: Date | string
    updateAt?: Date | string
    floorNumber: number
    store: study_storeCreateNestedOneWithoutFloorsInput
  }

  export type study_floorUncheckedCreateWithoutStudyRoomsInput = {
    uid?: string
    createAt?: Date | string
    updateAt?: Date | string
    floorNumber: number
    storeId: string
  }

  export type study_floorCreateOrConnectWithoutStudyRoomsInput = {
    where: study_floorWhereUniqueInput
    create: XOR<study_floorCreateWithoutStudyRoomsInput, study_floorUncheckedCreateWithoutStudyRoomsInput>
  }

  export type study_seatCreateWithoutRoomInput = {
    uid?: string
    createAt?: Date | string
    updateAt?: Date | string
    seatNumber: string
    status?: boolean
    reservations?: study_reservationCreateNestedManyWithoutSeatInput
  }

  export type study_seatUncheckedCreateWithoutRoomInput = {
    uid?: string
    createAt?: Date | string
    updateAt?: Date | string
    seatNumber: string
    status?: boolean
    reservations?: study_reservationUncheckedCreateNestedManyWithoutSeatInput
  }

  export type study_seatCreateOrConnectWithoutRoomInput = {
    where: study_seatWhereUniqueInput
    create: XOR<study_seatCreateWithoutRoomInput, study_seatUncheckedCreateWithoutRoomInput>
  }

  export type study_seatCreateManyRoomInputEnvelope = {
    data: study_seatCreateManyRoomInput | study_seatCreateManyRoomInput[]
    skipDuplicates?: boolean
  }

  export type study_floorUpsertWithoutStudyRoomsInput = {
    update: XOR<study_floorUpdateWithoutStudyRoomsInput, study_floorUncheckedUpdateWithoutStudyRoomsInput>
    create: XOR<study_floorCreateWithoutStudyRoomsInput, study_floorUncheckedCreateWithoutStudyRoomsInput>
    where?: study_floorWhereInput
  }

  export type study_floorUpdateToOneWithWhereWithoutStudyRoomsInput = {
    where?: study_floorWhereInput
    data: XOR<study_floorUpdateWithoutStudyRoomsInput, study_floorUncheckedUpdateWithoutStudyRoomsInput>
  }

  export type study_floorUpdateWithoutStudyRoomsInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    floorNumber?: IntFieldUpdateOperationsInput | number
    store?: study_storeUpdateOneRequiredWithoutFloorsNestedInput
  }

  export type study_floorUncheckedUpdateWithoutStudyRoomsInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    floorNumber?: IntFieldUpdateOperationsInput | number
    storeId?: StringFieldUpdateOperationsInput | string
  }

  export type study_seatUpsertWithWhereUniqueWithoutRoomInput = {
    where: study_seatWhereUniqueInput
    update: XOR<study_seatUpdateWithoutRoomInput, study_seatUncheckedUpdateWithoutRoomInput>
    create: XOR<study_seatCreateWithoutRoomInput, study_seatUncheckedCreateWithoutRoomInput>
  }

  export type study_seatUpdateWithWhereUniqueWithoutRoomInput = {
    where: study_seatWhereUniqueInput
    data: XOR<study_seatUpdateWithoutRoomInput, study_seatUncheckedUpdateWithoutRoomInput>
  }

  export type study_seatUpdateManyWithWhereWithoutRoomInput = {
    where: study_seatScalarWhereInput
    data: XOR<study_seatUpdateManyMutationInput, study_seatUncheckedUpdateManyWithoutRoomInput>
  }

  export type study_seatScalarWhereInput = {
    AND?: study_seatScalarWhereInput | study_seatScalarWhereInput[]
    OR?: study_seatScalarWhereInput[]
    NOT?: study_seatScalarWhereInput | study_seatScalarWhereInput[]
    uid?: StringFilter<"study_seat"> | string
    createAt?: DateTimeFilter<"study_seat"> | Date | string
    updateAt?: DateTimeFilter<"study_seat"> | Date | string
    seatNumber?: StringFilter<"study_seat"> | string
    roomId?: StringFilter<"study_seat"> | string
    status?: BoolFilter<"study_seat"> | boolean
  }

  export type study_roomCreateWithoutSeatsInput = {
    uid?: string
    createAt?: Date | string
    updateAt?: Date | string
    name: string
    capacity: number
    status?: boolean
    floor: study_floorCreateNestedOneWithoutStudyRoomsInput
  }

  export type study_roomUncheckedCreateWithoutSeatsInput = {
    uid?: string
    createAt?: Date | string
    updateAt?: Date | string
    name: string
    floorId: string
    capacity: number
    status?: boolean
  }

  export type study_roomCreateOrConnectWithoutSeatsInput = {
    where: study_roomWhereUniqueInput
    create: XOR<study_roomCreateWithoutSeatsInput, study_roomUncheckedCreateWithoutSeatsInput>
  }

  export type study_reservationCreateWithoutSeatInput = {
    uid?: string
    createAt?: Date | string
    updateAt?: Date | string
    startTime: Date | string
    endTime: Date | string
    status?: string
    user: study_userCreateNestedOneWithoutReservationInput
  }

  export type study_reservationUncheckedCreateWithoutSeatInput = {
    uid?: string
    createAt?: Date | string
    updateAt?: Date | string
    userId: string
    startTime: Date | string
    endTime: Date | string
    status?: string
  }

  export type study_reservationCreateOrConnectWithoutSeatInput = {
    where: study_reservationWhereUniqueInput
    create: XOR<study_reservationCreateWithoutSeatInput, study_reservationUncheckedCreateWithoutSeatInput>
  }

  export type study_reservationCreateManySeatInputEnvelope = {
    data: study_reservationCreateManySeatInput | study_reservationCreateManySeatInput[]
    skipDuplicates?: boolean
  }

  export type study_roomUpsertWithoutSeatsInput = {
    update: XOR<study_roomUpdateWithoutSeatsInput, study_roomUncheckedUpdateWithoutSeatsInput>
    create: XOR<study_roomCreateWithoutSeatsInput, study_roomUncheckedCreateWithoutSeatsInput>
    where?: study_roomWhereInput
  }

  export type study_roomUpdateToOneWithWhereWithoutSeatsInput = {
    where?: study_roomWhereInput
    data: XOR<study_roomUpdateWithoutSeatsInput, study_roomUncheckedUpdateWithoutSeatsInput>
  }

  export type study_roomUpdateWithoutSeatsInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    floor?: study_floorUpdateOneRequiredWithoutStudyRoomsNestedInput
  }

  export type study_roomUncheckedUpdateWithoutSeatsInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    floorId?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
  }

  export type study_reservationUpsertWithWhereUniqueWithoutSeatInput = {
    where: study_reservationWhereUniqueInput
    update: XOR<study_reservationUpdateWithoutSeatInput, study_reservationUncheckedUpdateWithoutSeatInput>
    create: XOR<study_reservationCreateWithoutSeatInput, study_reservationUncheckedCreateWithoutSeatInput>
  }

  export type study_reservationUpdateWithWhereUniqueWithoutSeatInput = {
    where: study_reservationWhereUniqueInput
    data: XOR<study_reservationUpdateWithoutSeatInput, study_reservationUncheckedUpdateWithoutSeatInput>
  }

  export type study_reservationUpdateManyWithWhereWithoutSeatInput = {
    where: study_reservationScalarWhereInput
    data: XOR<study_reservationUpdateManyMutationInput, study_reservationUncheckedUpdateManyWithoutSeatInput>
  }

  export type study_userCreateWithoutReservationInput = {
    uid?: string
    createAt?: Date | string
    updateAt?: Date | string
    name: string
    account: string
    password: string
    isAdmin?: boolean
    message?: study_messageCreateNestedManyWithoutUserInput
  }

  export type study_userUncheckedCreateWithoutReservationInput = {
    uid?: string
    createAt?: Date | string
    updateAt?: Date | string
    name: string
    account: string
    password: string
    isAdmin?: boolean
    message?: study_messageUncheckedCreateNestedManyWithoutUserInput
  }

  export type study_userCreateOrConnectWithoutReservationInput = {
    where: study_userWhereUniqueInput
    create: XOR<study_userCreateWithoutReservationInput, study_userUncheckedCreateWithoutReservationInput>
  }

  export type study_seatCreateWithoutReservationsInput = {
    uid?: string
    createAt?: Date | string
    updateAt?: Date | string
    seatNumber: string
    status?: boolean
    room: study_roomCreateNestedOneWithoutSeatsInput
  }

  export type study_seatUncheckedCreateWithoutReservationsInput = {
    uid?: string
    createAt?: Date | string
    updateAt?: Date | string
    seatNumber: string
    roomId: string
    status?: boolean
  }

  export type study_seatCreateOrConnectWithoutReservationsInput = {
    where: study_seatWhereUniqueInput
    create: XOR<study_seatCreateWithoutReservationsInput, study_seatUncheckedCreateWithoutReservationsInput>
  }

  export type study_userUpsertWithoutReservationInput = {
    update: XOR<study_userUpdateWithoutReservationInput, study_userUncheckedUpdateWithoutReservationInput>
    create: XOR<study_userCreateWithoutReservationInput, study_userUncheckedCreateWithoutReservationInput>
    where?: study_userWhereInput
  }

  export type study_userUpdateToOneWithWhereWithoutReservationInput = {
    where?: study_userWhereInput
    data: XOR<study_userUpdateWithoutReservationInput, study_userUncheckedUpdateWithoutReservationInput>
  }

  export type study_userUpdateWithoutReservationInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    account?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    message?: study_messageUpdateManyWithoutUserNestedInput
  }

  export type study_userUncheckedUpdateWithoutReservationInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    account?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    message?: study_messageUncheckedUpdateManyWithoutUserNestedInput
  }

  export type study_seatUpsertWithoutReservationsInput = {
    update: XOR<study_seatUpdateWithoutReservationsInput, study_seatUncheckedUpdateWithoutReservationsInput>
    create: XOR<study_seatCreateWithoutReservationsInput, study_seatUncheckedCreateWithoutReservationsInput>
    where?: study_seatWhereInput
  }

  export type study_seatUpdateToOneWithWhereWithoutReservationsInput = {
    where?: study_seatWhereInput
    data: XOR<study_seatUpdateWithoutReservationsInput, study_seatUncheckedUpdateWithoutReservationsInput>
  }

  export type study_seatUpdateWithoutReservationsInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seatNumber?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    room?: study_roomUpdateOneRequiredWithoutSeatsNestedInput
  }

  export type study_seatUncheckedUpdateWithoutReservationsInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seatNumber?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
  }

  export type study_userCreateWithoutMessageInput = {
    uid?: string
    createAt?: Date | string
    updateAt?: Date | string
    name: string
    account: string
    password: string
    isAdmin?: boolean
    reservation?: study_reservationCreateNestedManyWithoutUserInput
  }

  export type study_userUncheckedCreateWithoutMessageInput = {
    uid?: string
    createAt?: Date | string
    updateAt?: Date | string
    name: string
    account: string
    password: string
    isAdmin?: boolean
    reservation?: study_reservationUncheckedCreateNestedManyWithoutUserInput
  }

  export type study_userCreateOrConnectWithoutMessageInput = {
    where: study_userWhereUniqueInput
    create: XOR<study_userCreateWithoutMessageInput, study_userUncheckedCreateWithoutMessageInput>
  }

  export type study_userUpsertWithoutMessageInput = {
    update: XOR<study_userUpdateWithoutMessageInput, study_userUncheckedUpdateWithoutMessageInput>
    create: XOR<study_userCreateWithoutMessageInput, study_userUncheckedCreateWithoutMessageInput>
    where?: study_userWhereInput
  }

  export type study_userUpdateToOneWithWhereWithoutMessageInput = {
    where?: study_userWhereInput
    data: XOR<study_userUpdateWithoutMessageInput, study_userUncheckedUpdateWithoutMessageInput>
  }

  export type study_userUpdateWithoutMessageInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    account?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    reservation?: study_reservationUpdateManyWithoutUserNestedInput
  }

  export type study_userUncheckedUpdateWithoutMessageInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    account?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    reservation?: study_reservationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type sys_accountCreateManyUserInput = {
    createAt?: Date | string
    updateAt?: Date | string
    provider: $Enums.sys_account_provider
    provider_id: string
  }

  export type sys_user_ban_menuCreateManyUserInput = {
    menuId: string
  }

  export type sys_accountUpdateWithoutUserInput = {
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    provider?: Enumsys_account_providerFieldUpdateOperationsInput | $Enums.sys_account_provider
    provider_id?: StringFieldUpdateOperationsInput | string
  }

  export type sys_accountUncheckedUpdateWithoutUserInput = {
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    provider?: Enumsys_account_providerFieldUpdateOperationsInput | $Enums.sys_account_provider
    provider_id?: StringFieldUpdateOperationsInput | string
  }

  export type sys_accountUncheckedUpdateManyWithoutUserInput = {
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    provider?: Enumsys_account_providerFieldUpdateOperationsInput | $Enums.sys_account_provider
    provider_id?: StringFieldUpdateOperationsInput | string
  }

  export type sys_user_ban_menuUpdateWithoutUserInput = {
    menu?: sys_menuUpdateOneRequiredWithoutUser_bansNestedInput
  }

  export type sys_user_ban_menuUncheckedUpdateWithoutUserInput = {
    menuId?: StringFieldUpdateOperationsInput | string
  }

  export type sys_user_ban_menuUncheckedUpdateManyWithoutUserInput = {
    menuId?: StringFieldUpdateOperationsInput | string
  }

  export type sys_menuCreateManyParentInput = {
    uid?: string
    createAt?: Date | string
    updateAt?: Date | string
    name: string
    path: string
    powers: number
    comment?: string | null
  }

  export type sys_menu_on_roleCreateManyMenuInput = {
    roleId: string
    power?: bigint | number
  }

  export type sys_user_ban_menuCreateManyMenuInput = {
    userId: string
  }

  export type sys_menuUpdateWithoutParentInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    powers?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    children?: sys_menuUpdateManyWithoutParentNestedInput
    roles?: sys_menu_on_roleUpdateManyWithoutMenuNestedInput
    user_bans?: sys_user_ban_menuUpdateManyWithoutMenuNestedInput
  }

  export type sys_menuUncheckedUpdateWithoutParentInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    powers?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    children?: sys_menuUncheckedUpdateManyWithoutParentNestedInput
    roles?: sys_menu_on_roleUncheckedUpdateManyWithoutMenuNestedInput
    user_bans?: sys_user_ban_menuUncheckedUpdateManyWithoutMenuNestedInput
  }

  export type sys_menuUncheckedUpdateManyWithoutParentInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    powers?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type sys_menu_on_roleUpdateWithoutMenuInput = {
    power?: BigIntFieldUpdateOperationsInput | bigint | number
    role?: sys_roleUpdateOneRequiredWithoutMenusNestedInput
  }

  export type sys_menu_on_roleUncheckedUpdateWithoutMenuInput = {
    roleId?: StringFieldUpdateOperationsInput | string
    power?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type sys_menu_on_roleUncheckedUpdateManyWithoutMenuInput = {
    roleId?: StringFieldUpdateOperationsInput | string
    power?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type sys_user_ban_menuUpdateWithoutMenuInput = {
    user?: sys_userUpdateOneRequiredWithoutBan_menusNestedInput
  }

  export type sys_user_ban_menuUncheckedUpdateWithoutMenuInput = {
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type sys_user_ban_menuUncheckedUpdateManyWithoutMenuInput = {
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type sys_menu_on_roleCreateManyRoleInput = {
    menuId: string
    power?: bigint | number
  }

  export type sys_userCreateManyRoleInput = {
    uid?: string
    createAt?: Date | string
    updateAt?: Date | string
    name: string
    password: string
    salt: string
  }

  export type sys_menu_on_roleUpdateWithoutRoleInput = {
    power?: BigIntFieldUpdateOperationsInput | bigint | number
    menu?: sys_menuUpdateOneRequiredWithoutRolesNestedInput
  }

  export type sys_menu_on_roleUncheckedUpdateWithoutRoleInput = {
    menuId?: StringFieldUpdateOperationsInput | string
    power?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type sys_menu_on_roleUncheckedUpdateManyWithoutRoleInput = {
    menuId?: StringFieldUpdateOperationsInput | string
    power?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type sys_userUpdateWithoutRoleInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    salt?: StringFieldUpdateOperationsInput | string
    accounts?: sys_accountUpdateManyWithoutUserNestedInput
    ban_menus?: sys_user_ban_menuUpdateManyWithoutUserNestedInput
  }

  export type sys_userUncheckedUpdateWithoutRoleInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    salt?: StringFieldUpdateOperationsInput | string
    accounts?: sys_accountUncheckedUpdateManyWithoutUserNestedInput
    ban_menus?: sys_user_ban_menuUncheckedUpdateManyWithoutUserNestedInput
  }

  export type sys_userUncheckedUpdateManyWithoutRoleInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    salt?: StringFieldUpdateOperationsInput | string
  }

  export type blog_postsCreateManyUserInput = {
    uid?: string
    createAt?: Date | string
    updateAt?: Date | string
    title: string
    content: string
    categoriesId?: string | null
  }

  export type blog_postsUpdateWithoutUserInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    categories?: blog_categoriesUpdateOneWithoutPostsNestedInput
    tags?: blog_posts_on_tagsUpdateManyWithoutPostsNestedInput
  }

  export type blog_postsUncheckedUpdateWithoutUserInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    categoriesId?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: blog_posts_on_tagsUncheckedUpdateManyWithoutPostsNestedInput
  }

  export type blog_postsUncheckedUpdateManyWithoutUserInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    categoriesId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type blog_postsCreateManyCategoriesInput = {
    uid?: string
    createAt?: Date | string
    updateAt?: Date | string
    title: string
    content: string
    userId: string
  }

  export type blog_postsUpdateWithoutCategoriesInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    user?: blog_userUpdateOneRequiredWithoutPostsNestedInput
    tags?: blog_posts_on_tagsUpdateManyWithoutPostsNestedInput
  }

  export type blog_postsUncheckedUpdateWithoutCategoriesInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    tags?: blog_posts_on_tagsUncheckedUpdateManyWithoutPostsNestedInput
  }

  export type blog_postsUncheckedUpdateManyWithoutCategoriesInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type blog_posts_on_tagsCreateManyPostsInput = {
    tagId: string
  }

  export type blog_posts_on_tagsUpdateWithoutPostsInput = {
    tag?: blog_tagUpdateOneRequiredWithoutBlog_posts_on_tagsNestedInput
  }

  export type blog_posts_on_tagsUncheckedUpdateWithoutPostsInput = {
    tagId?: StringFieldUpdateOperationsInput | string
  }

  export type blog_posts_on_tagsUncheckedUpdateManyWithoutPostsInput = {
    tagId?: StringFieldUpdateOperationsInput | string
  }

  export type blog_posts_on_tagsCreateManyTagInput = {
    postsId: string
  }

  export type blog_posts_on_tagsUpdateWithoutTagInput = {
    posts?: blog_postsUpdateOneRequiredWithoutTagsNestedInput
  }

  export type blog_posts_on_tagsUncheckedUpdateWithoutTagInput = {
    postsId?: StringFieldUpdateOperationsInput | string
  }

  export type blog_posts_on_tagsUncheckedUpdateManyWithoutTagInput = {
    postsId?: StringFieldUpdateOperationsInput | string
  }

  export type file_user_on_mediaCreateManyUserInput = {
    mediaId: string
    comment?: string | null
  }

  export type file_folderCreateManyUserInput = {
    uid?: string
    createAt?: Date | string
    updateAt?: Date | string
    name: string
    parentId?: string | null
  }

  export type file_keysCreateManyUserInput = {
    api_key: string
    api_secret: string
  }

  export type file_user_on_mediaUpdateWithoutUserInput = {
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    media?: file_mediaUpdateOneRequiredWithoutUsersNestedInput
  }

  export type file_user_on_mediaUncheckedUpdateWithoutUserInput = {
    mediaId?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type file_user_on_mediaUncheckedUpdateManyWithoutUserInput = {
    mediaId?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type file_folderUpdateWithoutUserInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    parent?: file_folderUpdateOneWithoutChildrenNestedInput
    children?: file_folderUpdateManyWithoutParentNestedInput
    medias?: file_media_on_folderUpdateManyWithoutFolderNestedInput
  }

  export type file_folderUncheckedUpdateWithoutUserInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    children?: file_folderUncheckedUpdateManyWithoutParentNestedInput
    medias?: file_media_on_folderUncheckedUpdateManyWithoutFolderNestedInput
  }

  export type file_folderUncheckedUpdateManyWithoutUserInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type file_keysUpdateWithoutUserInput = {
    api_key?: StringFieldUpdateOperationsInput | string
    api_secret?: StringFieldUpdateOperationsInput | string
  }

  export type file_keysUncheckedUpdateWithoutUserInput = {
    api_key?: StringFieldUpdateOperationsInput | string
    api_secret?: StringFieldUpdateOperationsInput | string
  }

  export type file_keysUncheckedUpdateManyWithoutUserInput = {
    api_key?: StringFieldUpdateOperationsInput | string
    api_secret?: StringFieldUpdateOperationsInput | string
  }

  export type file_blockCreateManyMediaInput = {
    uid?: string
    createAt?: Date | string
    updateAt?: Date | string
    hash_key: string
    size: number
  }

  export type file_user_on_mediaCreateManyMediaInput = {
    userId: string
    comment?: string | null
  }

  export type file_media_on_folderCreateManyMediaInput = {
    folderId: string
  }

  export type file_blockUpdateWithoutMediaInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hash_key?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
  }

  export type file_blockUncheckedUpdateWithoutMediaInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hash_key?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
  }

  export type file_blockUncheckedUpdateManyWithoutMediaInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hash_key?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
  }

  export type file_user_on_mediaUpdateWithoutMediaInput = {
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    user?: file_userUpdateOneRequiredWithoutMediasNestedInput
  }

  export type file_user_on_mediaUncheckedUpdateWithoutMediaInput = {
    userId?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type file_user_on_mediaUncheckedUpdateManyWithoutMediaInput = {
    userId?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type file_media_on_folderUpdateWithoutMediaInput = {
    folder?: file_folderUpdateOneRequiredWithoutMediasNestedInput
  }

  export type file_media_on_folderUncheckedUpdateWithoutMediaInput = {
    folderId?: StringFieldUpdateOperationsInput | string
  }

  export type file_media_on_folderUncheckedUpdateManyWithoutMediaInput = {
    folderId?: StringFieldUpdateOperationsInput | string
  }

  export type file_folderCreateManyParentInput = {
    uid?: string
    createAt?: Date | string
    updateAt?: Date | string
    name: string
    userId: string
  }

  export type file_media_on_folderCreateManyFolderInput = {
    mediaId: string
  }

  export type file_folderUpdateWithoutParentInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    user?: file_userUpdateOneRequiredWithoutFoldersNestedInput
    children?: file_folderUpdateManyWithoutParentNestedInput
    medias?: file_media_on_folderUpdateManyWithoutFolderNestedInput
  }

  export type file_folderUncheckedUpdateWithoutParentInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    children?: file_folderUncheckedUpdateManyWithoutParentNestedInput
    medias?: file_media_on_folderUncheckedUpdateManyWithoutFolderNestedInput
  }

  export type file_folderUncheckedUpdateManyWithoutParentInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type file_media_on_folderUpdateWithoutFolderInput = {
    media?: file_mediaUpdateOneRequiredWithoutFoldersNestedInput
  }

  export type file_media_on_folderUncheckedUpdateWithoutFolderInput = {
    mediaId?: StringFieldUpdateOperationsInput | string
  }

  export type file_media_on_folderUncheckedUpdateManyWithoutFolderInput = {
    mediaId?: StringFieldUpdateOperationsInput | string
  }

  export type book_borrowedCreateManyUserInput = {
    id?: string
    borrowDate?: Date | string
    returnDate?: Date | string | null
    dueDate: Date | string
    bookId: string
    returned?: boolean
  }

  export type book_borrow_historyCreateManyUserInput = {
    id?: string
    borrowDate?: Date | string
    returnDate?: Date | string | null
    bookId: string
    returned?: boolean
  }

  export type book_ratingCreateManyUserInput = {
    id?: string
    createAt?: Date | string
    updateAt?: Date | string
    rating: number
    review?: string | null
    bookId: string
  }

  export type book_borrowedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    borrowDate?: DateTimeFieldUpdateOperationsInput | Date | string
    returnDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    returned?: BoolFieldUpdateOperationsInput | boolean
    book?: book_bookUpdateOneRequiredWithoutBorrowedNestedInput
  }

  export type book_borrowedUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    borrowDate?: DateTimeFieldUpdateOperationsInput | Date | string
    returnDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    bookId?: StringFieldUpdateOperationsInput | string
    returned?: BoolFieldUpdateOperationsInput | boolean
  }

  export type book_borrowedUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    borrowDate?: DateTimeFieldUpdateOperationsInput | Date | string
    returnDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    bookId?: StringFieldUpdateOperationsInput | string
    returned?: BoolFieldUpdateOperationsInput | boolean
  }

  export type book_borrow_historyUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    borrowDate?: DateTimeFieldUpdateOperationsInput | Date | string
    returnDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    returned?: BoolFieldUpdateOperationsInput | boolean
    book?: book_bookUpdateOneRequiredWithoutBook_borrow_historyNestedInput
  }

  export type book_borrow_historyUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    borrowDate?: DateTimeFieldUpdateOperationsInput | Date | string
    returnDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bookId?: StringFieldUpdateOperationsInput | string
    returned?: BoolFieldUpdateOperationsInput | boolean
  }

  export type book_borrow_historyUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    borrowDate?: DateTimeFieldUpdateOperationsInput | Date | string
    returnDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bookId?: StringFieldUpdateOperationsInput | string
    returned?: BoolFieldUpdateOperationsInput | boolean
  }

  export type book_ratingUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rating?: FloatFieldUpdateOperationsInput | number
    review?: NullableStringFieldUpdateOperationsInput | string | null
    book?: book_bookUpdateOneRequiredWithoutBook_ratingNestedInput
  }

  export type book_ratingUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rating?: FloatFieldUpdateOperationsInput | number
    review?: NullableStringFieldUpdateOperationsInput | string | null
    bookId?: StringFieldUpdateOperationsInput | string
  }

  export type book_ratingUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rating?: FloatFieldUpdateOperationsInput | number
    review?: NullableStringFieldUpdateOperationsInput | string | null
    bookId?: StringFieldUpdateOperationsInput | string
  }

  export type book_borrowedCreateManyBookInput = {
    id?: string
    borrowDate?: Date | string
    returnDate?: Date | string | null
    dueDate: Date | string
    userId: string
    returned?: boolean
  }

  export type book_borrow_historyCreateManyBookInput = {
    id?: string
    borrowDate?: Date | string
    returnDate?: Date | string | null
    userId: string
    returned?: boolean
  }

  export type book_ratingCreateManyBookInput = {
    id?: string
    createAt?: Date | string
    updateAt?: Date | string
    rating: number
    review?: string | null
    userId: string
  }

  export type book_borrowedUpdateWithoutBookInput = {
    id?: StringFieldUpdateOperationsInput | string
    borrowDate?: DateTimeFieldUpdateOperationsInput | Date | string
    returnDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    returned?: BoolFieldUpdateOperationsInput | boolean
    user?: book_userUpdateOneRequiredWithoutBorrowedNestedInput
  }

  export type book_borrowedUncheckedUpdateWithoutBookInput = {
    id?: StringFieldUpdateOperationsInput | string
    borrowDate?: DateTimeFieldUpdateOperationsInput | Date | string
    returnDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    returned?: BoolFieldUpdateOperationsInput | boolean
  }

  export type book_borrowedUncheckedUpdateManyWithoutBookInput = {
    id?: StringFieldUpdateOperationsInput | string
    borrowDate?: DateTimeFieldUpdateOperationsInput | Date | string
    returnDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    returned?: BoolFieldUpdateOperationsInput | boolean
  }

  export type book_borrow_historyUpdateWithoutBookInput = {
    id?: StringFieldUpdateOperationsInput | string
    borrowDate?: DateTimeFieldUpdateOperationsInput | Date | string
    returnDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    returned?: BoolFieldUpdateOperationsInput | boolean
    user?: book_userUpdateOneRequiredWithoutBook_borrow_historyNestedInput
  }

  export type book_borrow_historyUncheckedUpdateWithoutBookInput = {
    id?: StringFieldUpdateOperationsInput | string
    borrowDate?: DateTimeFieldUpdateOperationsInput | Date | string
    returnDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: StringFieldUpdateOperationsInput | string
    returned?: BoolFieldUpdateOperationsInput | boolean
  }

  export type book_borrow_historyUncheckedUpdateManyWithoutBookInput = {
    id?: StringFieldUpdateOperationsInput | string
    borrowDate?: DateTimeFieldUpdateOperationsInput | Date | string
    returnDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: StringFieldUpdateOperationsInput | string
    returned?: BoolFieldUpdateOperationsInput | boolean
  }

  export type book_ratingUpdateWithoutBookInput = {
    id?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rating?: FloatFieldUpdateOperationsInput | number
    review?: NullableStringFieldUpdateOperationsInput | string | null
    user?: book_userUpdateOneRequiredWithoutBook_ratingNestedInput
  }

  export type book_ratingUncheckedUpdateWithoutBookInput = {
    id?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rating?: FloatFieldUpdateOperationsInput | number
    review?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type book_ratingUncheckedUpdateManyWithoutBookInput = {
    id?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rating?: FloatFieldUpdateOperationsInput | number
    review?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type book_bookCreateManyCategoryInput = {
    id?: string
    createAt?: Date | string
    updateAt?: Date | string
    title: string
    author: string
    isbn: string
    description?: string | null
    publication: Date | string
    available?: boolean
  }

  export type book_bookUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    isbn?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    publication?: DateTimeFieldUpdateOperationsInput | Date | string
    available?: BoolFieldUpdateOperationsInput | boolean
    borrowed?: book_borrowedUpdateManyWithoutBookNestedInput
    book_borrow_history?: book_borrow_historyUpdateManyWithoutBookNestedInput
    book_rating?: book_ratingUpdateManyWithoutBookNestedInput
  }

  export type book_bookUncheckedUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    isbn?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    publication?: DateTimeFieldUpdateOperationsInput | Date | string
    available?: BoolFieldUpdateOperationsInput | boolean
    borrowed?: book_borrowedUncheckedUpdateManyWithoutBookNestedInput
    book_borrow_history?: book_borrow_historyUncheckedUpdateManyWithoutBookNestedInput
    book_rating?: book_ratingUncheckedUpdateManyWithoutBookNestedInput
  }

  export type book_bookUncheckedUpdateManyWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    isbn?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    publication?: DateTimeFieldUpdateOperationsInput | Date | string
    available?: BoolFieldUpdateOperationsInput | boolean
  }

  export type study_reservationCreateManyUserInput = {
    uid?: string
    createAt?: Date | string
    updateAt?: Date | string
    seatId: string
    startTime: Date | string
    endTime: Date | string
    status?: string
  }

  export type study_messageCreateManyUserInput = {
    uid?: string
    createAt?: Date | string
    updateAt?: Date | string
    content: string
    reply?: string | null
    status?: boolean
  }

  export type study_reservationUpdateWithoutUserInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    seat?: study_seatUpdateOneRequiredWithoutReservationsNestedInput
  }

  export type study_reservationUncheckedUpdateWithoutUserInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seatId?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type study_reservationUncheckedUpdateManyWithoutUserInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seatId?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type study_messageUpdateWithoutUserInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    reply?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
  }

  export type study_messageUncheckedUpdateWithoutUserInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    reply?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
  }

  export type study_messageUncheckedUpdateManyWithoutUserInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    reply?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
  }

  export type study_floorCreateManyStoreInput = {
    uid?: string
    createAt?: Date | string
    updateAt?: Date | string
    floorNumber: number
  }

  export type study_floorUpdateWithoutStoreInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    floorNumber?: IntFieldUpdateOperationsInput | number
    studyRooms?: study_roomUpdateManyWithoutFloorNestedInput
  }

  export type study_floorUncheckedUpdateWithoutStoreInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    floorNumber?: IntFieldUpdateOperationsInput | number
    studyRooms?: study_roomUncheckedUpdateManyWithoutFloorNestedInput
  }

  export type study_floorUncheckedUpdateManyWithoutStoreInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    floorNumber?: IntFieldUpdateOperationsInput | number
  }

  export type study_roomCreateManyFloorInput = {
    uid?: string
    createAt?: Date | string
    updateAt?: Date | string
    name: string
    capacity: number
    status?: boolean
  }

  export type study_roomUpdateWithoutFloorInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    seats?: study_seatUpdateManyWithoutRoomNestedInput
  }

  export type study_roomUncheckedUpdateWithoutFloorInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    seats?: study_seatUncheckedUpdateManyWithoutRoomNestedInput
  }

  export type study_roomUncheckedUpdateManyWithoutFloorInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
  }

  export type study_seatCreateManyRoomInput = {
    uid?: string
    createAt?: Date | string
    updateAt?: Date | string
    seatNumber: string
    status?: boolean
  }

  export type study_seatUpdateWithoutRoomInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seatNumber?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    reservations?: study_reservationUpdateManyWithoutSeatNestedInput
  }

  export type study_seatUncheckedUpdateWithoutRoomInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seatNumber?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    reservations?: study_reservationUncheckedUpdateManyWithoutSeatNestedInput
  }

  export type study_seatUncheckedUpdateManyWithoutRoomInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seatNumber?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
  }

  export type study_reservationCreateManySeatInput = {
    uid?: string
    createAt?: Date | string
    updateAt?: Date | string
    userId: string
    startTime: Date | string
    endTime: Date | string
    status?: string
  }

  export type study_reservationUpdateWithoutSeatInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    user?: study_userUpdateOneRequiredWithoutReservationNestedInput
  }

  export type study_reservationUncheckedUpdateWithoutSeatInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type study_reservationUncheckedUpdateManyWithoutSeatInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}